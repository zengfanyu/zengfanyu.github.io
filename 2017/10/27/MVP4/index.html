<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android,MVP,okHttp," />





  <link rel="alternate" href="/atom.xml" title="THIS IS BIGZ" type="application/atom+xml" />






<meta name="description" content="摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。  官方给的例子 同步方法 OkHttpClien">
<meta name="keywords" content="Android,MVP,okHttp">
<meta property="og:type" content="article">
<meta property="og:title" content="Android当中的MVP模式（四）插曲-封装OkHttp">
<meta property="og:url" content="http://zengfanyu.top/2017/10/27/MVP4/index.html">
<meta property="og:site_name" content="THIS IS BIGZ">
<meta property="og:description" content="摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。  官方给的例子 同步方法 OkHttpClien">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.imgur.com/YGahFXU.png">
<meta property="og:image" content="https://i.imgur.com/OMByMTy.png">
<meta property="og:updated_time" content="2017-10-28T06:17:19.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android当中的MVP模式（四）插曲-封装OkHttp">
<meta name="twitter:description" content="摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。  官方给的例子 同步方法 OkHttpClien">
<meta name="twitter:image" content="https://i.imgur.com/YGahFXU.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zengfanyu.top/2017/10/27/MVP4/"/>





  <title>Android当中的MVP模式（四）插曲-封装OkHttp | THIS IS BIGZ</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">THIS IS BIGZ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Every little makes a mickel</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-server"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zengfanyu.top/2017/10/27/MVP4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BigZ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THIS IS BIGZ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android当中的MVP模式（四）插曲-封装OkHttp</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T20:37:15+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MVP/" itemprop="url" rel="index">
                    <span itemprop="name">MVP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><em>摘要</em>：<em>前两篇中使用的网络请求工具是 <code>OkHttp</code> ，并没有经过封装，都是简单的使用 <code>get</code> 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 <code>errorCode</code> 或者是 <code>errorMsg</code> 吧，所以这边文章就针对 <code>OkHttp</code> 进行封装，然后将封装之后的工具使用到上一小结的 <code>Demo</code> 之中。</em></p>
</blockquote>
<h2 id="官方给的例子"><a href="#官方给的例子" class="headerlink" title="官方给的例子"></a>官方给的例子</h2><ul>
<li><p>同步方法</p>
<pre><code>OkHttpClient client = new OkHttpClient();

String run(String url) throws IOException {
  Request request = new Request.Builder()
      .url(url)
      .build();

  Response response = client.newCall(request).execute();
  return response.body().string();
}
</code></pre></li>
</ul>
<ul>
<li><p>异步方法</p>
<pre><code>OkHttpClient client = new OkHttpClient();

Request request = new Request.Builder()
        .url(url)
        .build();

 client.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {

    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {

    }
}
</code></pre></li>
</ul>
<h2 id="对异步方法的分析"><a href="#对异步方法的分析" class="headerlink" title="对异步方法的分析"></a>对异步方法的分析</h2><p>结合上面异步方法，稍作分析，涉及到如下几个对象<font color="#FF8000"> <strong><code>OkHttpClient</code></strong> , <strong><code>Request</code></strong> , <strong><code>Call</code></strong>,<strong><code>Response</code></strong> </font>,其他的都一些方法的调用，所以我们的封装应该重点针对这三个对象来进行。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p><code>Request</code> 在 <code>Okhttp</code> 当中是抽象出来的一个请求对象，它封装了请求报文信息：请求的 <code>Url</code> 地址，请求的方法（<code>Get Post</code>等），各种请求头（<code>Content-Type Cookie</code>）以及可以选择的请求体，一般通过内部的 <code>Builder</code> 类来构建对象，建筑者设计模式。</p>
<p>那么我们这里就针对 <code>Post Get</code> 两种请求方式做封装，但是这里又涉及到一个问题，就是我们还需要参数，用于拼接请求 <code>Url</code> 的参数，举个栗子：</p>
<p>这是搜狐电视剧频道的 <code>API</code> 接口：</p>
<pre><code>http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22?cid=2&amp;o=1&amp;plat=6&amp;poid=1&amp;api_key=9854b2afa779e1a6bff1962447a09dbd&amp;%22%20+%20%22sver=6.2.0&amp;sysver=4.4.2&amp;partner=47&amp;page=1&amp;page_size=10
</code></pre><p>这么看可能特别的麻烦，我们把它拆分一下：</p>
<pre><code>String baseUrl=http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22
</code></pre><p>然后剩下的都是参数了，以键值对的形式存在：</p>
<p><img src="https://i.imgur.com/YGahFXU.png" alt=""></p>
<p>这些参数拼接在 <code>baseUrl</code> 后面的顺序是没有要求的，<strong>不一定要按照上面的顺序来，只要每个参数都按照固定的格式出现就可以</strong>。</p>
<p>看上面的完整 <code>Url</code> 可以发现规律，在 <code>baseUrl</code> 后面有一个 <code>？</code>， 然后就就是 <code>key1=value1&amp;key2=value2&amp;key3=value3</code> 这种形式的</p>
<p>其实遵循 <code>RESTful API</code> 设计的接口，都会是这种形式，所以这里也利于我们进行封装了。而 <code>key-value</code> 这种形式，就特别适合使用 <code>Map</code> 结构来封装。</p>
<p>说这么多，上代码，首先是对参数进行封装：</p>
<font color="#FF8000"><strong>RequestParam</strong></font>


<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 13:55
 * @desc: 封装url中的参数
 */
public class RequestParams {
    /**
     * 使用{@link ConcurrentHashMap}是为了保证线程安全
     */
    private ConcurrentHashMap&lt;String, String&gt; urlParams = new ConcurrentHashMap&lt;&gt;();

    public RequestParams() {
    }

    public RequestParams(Map&lt;String, String&gt; source) {
        for (Map.Entry&lt;String, String&gt; entry : source.entrySet()) {
            put(entry.getKey(), entry.getValue());
        }
    }

    public RequestParams(String key, String value) {
        put(key, value);

    }

    private void put(String key, String value) {
        if (!TextUtils.isEmpty(key) &amp;&amp; !TextUtils.isEmpty(value)) {
            urlParams.put(key, value);
        }
    }

    public ConcurrentHashMap&lt;String, String&gt; getUrlParams() {
        return urlParams;
    }


}
</code></pre><p>这地方使用 <code>ConcurrentHashMap</code> 就是为了保证线程安全的，这个类使用的是<font color="#FF8000">锁分段技术</font>，不同于一般的同步方法或者是同步代码块，它只会锁住其中一个 <code>segment</code>，其他的 <code>segment</code> 仍然是可以访问的，所以他的效率会比 <code>synchronized</code> 高。</p>
<p>有了 <code>RequestParam</code> 之后，就可以使用它来拼接 <code>url</code>，有了 <code>url</code> 之后，就可以使用它来构建 <code>Request</code>对象了。</p>
<font color="#FF8000"><strong>CommonRequest</strong> </font>

<pre><code> 1 /**
 2  * @author: fanyuzeng
 3  * @date: 2017/10/27 14:08
 4  * @desc: response for build various kind of {@link okhttp3.Request} include Get Post upload etc.
 5  */
 6 public class CommonRequest {
 7     private static final String TAG = &quot;CommonRequest&quot;;
 8     /**
 9      * create a Get request
10      *
11      * @param baseUrl base url
12      * @param params see {@link RequestParams}
13      * @return {@link Request}
14      * @created at 2017/10/27 14:39
15      */
16     public static Request createGetRequest(@NonNull String baseUrl, @Nullable RequestParams params) {
17         StringBuilder urlBuilder = new StringBuilder(baseUrl).append(&quot;?&quot;);
18         if (params != null) {
19             //将请求参数合并进url中
20             for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) {
21                 urlBuilder.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue()).append(&quot;&amp;&quot;);
22             }
23 
24             Log.d(TAG,&quot;&gt;&gt; createGetRequest &gt;&gt; &quot; + urlBuilder.toString());
25         }
26         return new Request.Builder().get().url(urlBuilder.substring(0, urlBuilder.length() - 1)).build();
27     }
28 
29     /**
30      * create a post request
31      *
32      * @param baseUrl base url
33      * @param params see {@link RequestParams}
34      * @return {@link Request}
35      * @created at 2017/10/27 14:39
36      */
37     public static Request createPostRequest(@NonNull String baseUrl, @NonNull RequestParams params) {
38         FormBody.Builder mFormBodyBuilder = new FormBody.Builder();
39         for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) {
40             mFormBodyBuilder.add(entry.getKey(), entry.getValue());
41         }
42         FormBody formBody = mFormBodyBuilder.build();
43         return new Request.Builder().post(formBody).url(baseUrl).build();
44     }
45 
46 }
</code></pre><p>第 <code>16</code> 行的 <code>createGetRequest</code> 方法是用于创建一个 <code>Get</code> 请求，主要就是使用 <code>StringBuilder</code> 进行 <code>Url</code> 的拼接，第 <code>37</code> 行的 <code>createPostRequest</code> 方法是用于创建一个 <code>Post</code> 请求的。 <code>Post</code> 请求是先创建 <code>FormBody</code> ，然后和 <code>baseUrl</code> 一个构造 <code>Request</code> 。</p>
<p>封装到这里， <code>Request</code> 就算是封装完了， 当然这里只封装了 <code>Post Get</code> ，也可以继续封装文件上传和文件下载的Request。</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>Call</code> 代表的是一个实际的 <code>HTTP</code> 请求，它是链接 <code>Request</code> 和 <code>Response</code> 的桥梁，通过 <code>Request</code> 对象的 <code>newCall</code> 方法可以得到一个 <code>Call</code> 对象，既支持同步获取数据，也支持异步，在上面官方例子里，也可以看出来，在异步回调中，当获取到数据，会将 <code>Response</code> 对象传入 <code>Callback</code> 的 <code>onSuccess</code> 方法中，如果请求没有成功，就会调用 <code>onFailure</code> 方法（<code>Response</code> 下面说）。那么看看  <code>Callback</code> 是什么。</p>
<p>先看看官方的 <code>Callback</code> 是什么 ：</p>
<pre><code>public interface Callback {

  void onFailure(Call call, IOException e);


  void onResponse(Call call, Response response) throws IOException;
}
</code></pre><p>对，把注释删除了之后，其实就是两个接口，简单的理解成，一个是请求成功时的回调，一个是请求失败时的回调。</p>
<p>那么对这一层的<strong>封装思路</strong>是这样子的：</p>
<p>一般来说，在上层，我们是需要去处理上面两个回调的，在 <code>onFailure</code> 中，请求失败，应该做什么操作，在 <code>onResponse</code> 中，<code>HTTP</code> 返回的状态码在 <code>[200,300）</code>之间应该有什么操作，在其他区间又应该有什么操作。<font color="#FF8000">那么在这里，我们就创建一个类，去实现这个接口，将基本的处理都在这个类里写好，出错误了，就拿到 <code>erroeCode errorMsg</code> 回调给上层，正确的返回信息，就直接回调给上一层</font>。</p>
<p>那么这里就涉及到我们自定义的一个 <code>Exception</code> 和 <code>Listener</code> 以及实现了 <code>Callback</code> 接口的 <code>CommonCallback</code> 类。</p>
<font color="#FF8000"><strong>OkHttpException</strong></font>

<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 13:44
 * @desc:
 */
public class OkHttpException extends Exception {

    private int mErrorCode;
    private String mErrorMsg;

    public OkHttpException(int errorCode, String errorMsg) {
        this.mErrorCode = errorCode;
        this.mErrorMsg = errorMsg;
    }

    public int getErrorCode() {
        return mErrorCode;
    }

    public String getErrorMsg() {
        return mErrorMsg;
    }
}
</code></pre><font color="#FF8000"><strong>DisposeDataListener</strong></font>

<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 13:49
 * @desc:
 */
public interface DisposeDataListener {
    /**
     * 请求服务器数据成功时回调的方法
     *
     * @param responseObj 需要回调到上层的请求结果
     */
    void onSuccess(Object responseObj);

    /**
     * 请求服务器失败时候的回调方法
     *
     * @param exception 需要回调到上层的错误反馈
     */
    void onFailure(OkHttpException exception);

}
</code></pre><p>再将这个 <code>Listener</code> 用<font color="#FF8000">代理设计模式</font>再封装一层</p>
<font color="#FF8000"><strong>DisposeDataHandler</strong></font>

<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 13:52
 * @desc: 代理模式,使用DisposeDataHandler 代理 DisposeDataListener的操作
 */
public class DisposeDataHandler {

    public DisposeDataListener mListener;
    public Class&lt;?&gt; mClass;

    public DisposeDataHandler(DisposeDataListener listener) {
        mListener = listener;
    }

    public DisposeDataHandler(DisposeDataListener listener, Class&lt;?&gt; aClass) {
        mListener = listener;
        mClass = aClass;
    }

    public void onSuccess(Object responseObj) {
        mListener.onSuccess(responseObj);
    }

    public void onFailure(OkHttpException exception) {
        mListener.onFailure(exception);
    }

    public Class&lt;?&gt; getClassType() {
        return mClass;
    }
} 
</code></pre><p>此处用代理模式，主要是为了优雅（装X）的处理 <code>Class&lt;?&gt;</code> 这个对象，这是用于映射的类型，在调用 <code>Listener</code> 的回到方法之后做判断这个对象是否存在，是，则再映射在返回，否，直接返回。</p>
<p>然后将三面三个类聚合到一起</p>
<font color="#FF8000"><strong>CommonJsonCallback</strong></font>

<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 14:41
 * @desc:
 */
public class CommonJsonCallback implements Callback {
    private static final String TAG = &quot;CommonJsonCallback&quot;;
    private static final String MSG_RESULT_EMPTY = &quot;request could not be ececuted&quot;;
    private static final String MSG_JSON_EMPTY = &quot;json is empty or null&quot;;
    private static final String MSG_RETURN_CODE = &quot;http return code is not [200,300)&quot;;


    private static final int NETWORK_ERROR = -1;
    private static final int JSON_ERROR = -2;

    private Handler mDeliveryHandler = new Handler(Looper.getMainLooper());

    private Gson mGson = new Gson();

    private DisposeDataHandler mDisposeDataHandler;


    public CommonJsonCallback(DisposeDataHandler dataHandler) {
        mDisposeDataHandler = dataHandler;
    }


    @Override
    public void onFailure(@NonNull Call call, @NonNull final IOException e) {
        mDeliveryHandler.post(new Runnable() {
            @Override
            public void run() {
                mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RESULT_EMPTY + e.getMessage()));
            }
        });
    }

    @Override
    public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException {
        if (!response.isSuccessful()) {
            mDeliveryHandler.post(new Runnable() {
                @Override
                public void run() {
                    mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RETURN_CODE + response.message()));
                }
            });
        }
        final String resultJson = response.body().string();
        mDeliveryHandler.post(new Runnable() {
            @Override
            public void run() {
                handleResponse(resultJson);
            }
        });
    }

    private void handleResponse(String resultJson) {
        if (TextUtils.isEmpty(resultJson)) {
            mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_JSON_EMPTY));
            return;
        }
        if (mDisposeDataHandler.getClassType() == null) {
            mDisposeDataHandler.onSuccess(resultJson);
        } else {
            Object mappedDataType = mGson.fromJson(resultJson, mDisposeDataHandler.getClassType());
            if (mappedDataType == null) {
                mDisposeDataHandler.onFailure(new OkHttpException(JSON_ERROR, MSG_JSON_EMPTY));
            } else {
                mDisposeDataHandler.onSuccess(mappedDataType);
            }
        }


    }
}
</code></pre><p>自我感觉用代理之后，处理对象都是 <code>DisposeHandler</code> ，不会在看到 <code>Listener</code> <code>Class&lt;?&gt;</code> ,适应起来方便些了。</p>
<p>要注意一点是，在 <code>onResponse</code> 方法中，还是在子线程中的，要及时切换线程。</p>
<p>到这里，就对 <code>Call</code> 这个对象封装完成了。</p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><code>Response</code> 类封装了响应报文信息：状态吗（<code>200</code>、<code>404</code> 等）、响应头（<code>Content-Type</code>、<code>Server</code> 等）以及可选的响应体。可以通过 <code>Call</code> 对象的 <code>execute()</code> 方法获得 <code>Response</code> 对象，异步回调执行 <code>Callback</code> 对象的 <code>onResponse</code> 方法时也可以获取 <code>Response</code> 对象。</p>
<p>这东西人家已经给我们封装好了， 需要什么直接去拿就行， 也不需要在封装。</p>
<h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p><a href="http://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="external">官方文档</a>有这么一句话：</p>
<blockquote>
<p>OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools.</p>
</blockquote>
<p>翻译一下：当你使用一个全局的 <code>OkHttpClient</code> ，并且重用它发起 <code>HTTP</code> 请求的时候，<code>OkHttp</code> 的能够发挥最 <code>NB</code> 的性能，因为每一个客户端都持有它的连接池和线程池，如果这俩东西可以重用的话，那么就能减少潜在的因素，并且节省内存，相反的，如果为每一个客户端的每一个请求都创建一个 <code>OkHttpClient</code> ，那么就会浪费空闲的连接池和线程池中的资源。</p>
<p>叽叽歪歪这么多，就是说用 <code>OkHttpClient</code> 的时候要用<font color="#ff8000"><strong>单例模式</strong></font>。</p>
<p>刚开始我是这么设计的：</p>
<font color="#FF8000"><strong>CommonokHttpClient</strong></font>

<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 15:21
 * @desc:
 */
@Deprecated
public class CommonOkHttpClient {
    private static final int TIME_OUT = 30;

    private static OkHttpClient sOkHttpClient;

    static {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.hostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
        builder.connectTimeout(TIME_OUT, TimeUnit.SECONDS);
        builder.readTimeout(TIME_OUT, TimeUnit.SECONDS);
        builder.writeTimeout(TIME_OUT, TimeUnit.SECONDS);
        //允许重定向
        builder.followRedirects(true);
        // TODO: 2017/10/27 https
        sOkHttpClient = builder.build();
    }

    /**
     * 请求服务器数据的方法
     *
     * @param request Use {@link com.project.fanyuzeng.mvpdemo.utils.okhttp.request.CommonRequest} to build
     * @param handler see {@link DisposeDataHandler}  proxy class
     */
    public static void requestServerData(Request request, DisposeDataHandler handler) {
        sOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler));
    }


}
</code></pre><p>恩，静态代码块中初始化实例化 <code>OkHttpClient</code>，我认为饿汉模式没有本质的区别， 但是这种方式比饿汗模式的初始化时间更早。</p>
<blockquote>
<p>好吧 ，我承认我懒，不想在整个单例类出来。。</p>
</blockquote>
<p>这样写，也没什么问题，但是外界在使用的使用，比较麻烦</p>
<ol>
<li>创建<code>RequestParams</code>，涉及到 <code>HashMap</code> 的好多 <code>put</code> 操作</li>
<li>用 <code>RequestParam</code>  去初始化 <code>CommonRequest</code></li>
<li>在上层根据请求方式去创建对应的 <code>Request</code></li>
<li>再实例化一个<code>DisposeHandler</code> </li>
</ol>
<p>所以只好接着封装吧，分析上面 <code>4</code> 个步骤，其中步骤 <code>1</code> 那是不能再简化了的，因为具体的请求参数肯定是要从外界传进来的，这里涉及到的 <code>HashMap</code> 以及它的 <code>put</code> 操作是不可避免的。步骤 <code>2</code> 和步骤 <code>3</code> 完全是可以封装一下的，步骤 <code>4</code> 也是需要从外外界回调的方法，类似于点击监听的 <code>onClick</code> 方法回调。</p>
<p>所以把 <code>CommonOkHttpClient</code> 给 <code>Deprecated</code> 掉，重新来一个</p>
<font color="#FF8000"><strong>OkHttpManager</strong></font>

<pre><code>/**
 * @author:fanyuzeng
 * @date: 2017/10/27 17:57
 * @desc:
 */
public class OkHttpManager {
    private static volatile OkHttpManager sManager;
    private  OkHttpClient mOkHttpClient;

    private OkHttpManager() {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.hostnameVerifier(new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
        builder.connectTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS);
        builder.readTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS);
        builder.writeTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS);
        //允许重定向
        builder.followRedirects(true);
        // TODO: 2017/10/27 https
        mOkHttpClient = builder.build();
    }


    public static OkHttpManager getInstance() {
        if (sManager == null) {
            synchronized (OkHttpManager.class) {
                if (sManager == null) {
                    sManager = new OkHttpManager();
                }
            }
        }
        return sManager;
    }

    /**
     * 使用{@link OkHttpClient}想服务器端请求数据的方法
     * @param method {@link Constants#HTTP_GET_METHOD} Get方式,{@link Constants#HTTP_POST_METHOD} Post方式
     * @param baseUrl baseUrl
     * @param paramsMap 请求url的参数,以键值对的形式存放
     * @param handler
     */
    public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) {
        RequestParams requestParams = new RequestParams(paramsMap);
        Request request = null;
        if (method == Constants.HTTP_GET_METHOD) {
            request = CommonRequest.createGetRequest(baseUrl, requestParams);
        } else if (method == Constants.HTTP_POST_METHOD) {
            request = CommonRequest.createPostRequest(baseUrl, requestParams);
        }
        if (request != null) {
            mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler));
        }

    }

}
</code></pre><blockquote>
<p>好吧，还是用双重锁模式的单例比较放心 。</p>
</blockquote>
<p>到此就封装完了，下面简单的使用一下。</p>
<h2 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h2><pre><code> 1  OkHttpManager.getInstance().requestServerData(method, url, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() {
 2             @Override
 3             public void onSuccess(Object responseObj) {
 4                 String responseJson = (String) responseObj;
 5                 Log.d(TAG, &quot;&gt;&gt; onSuccess &gt;&gt; &quot; + responseJson);
 6                 mPaginationPresenter.accessSuccess(responseJson);
 7             }
 8             @Override
 9             public void onFailure(OkHttpException exception) {
10                 Log.d(TAG, &quot;&gt;&gt; onFailure &gt;&gt; &quot; + exception.getErrorCode());
11                 mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url);
12             }
13         },null));
</code></pre><ul>
<li>没有将 <code>Json</code> 数据映射成实体类， 所以在 <code>13</code> 行构造 <code>DisposeDataHandler</code> 的时候，第二个 类参数传的是 <code>null</code>。</li>
<li>这个例子是结合上一篇请求分页数据来用的，所以这里直接将 <code>Json</code> 数据抛给 <code>Presenter</code> 层，让它去处理。</li>
<li>第 <code>1</code> 行的 <code>mPaginationPresenter.getParams()</code> 就是拿 <code>url</code> 中的参数。</li>
</ul>
<p>由于篇幅的限制，这一篇先到这里，下一篇再把这个封装的 <code>OkHttp</code> 工具用于分页数据的请求。</p>
<p>最后，贴个 <code>AS</code> 中封装之后工具的结构图。</p>
<p><img src="https://i.imgur.com/OMByMTy.png" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/MVP/" rel="tag"># MVP</a>
          
            <a href="/tags/okHttp/" rel="tag"># okHttp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/25/MVP3/" rel="next" title="Android当中的MVP模式（三）基于分页列表的封装">
                <i class="fa fa-chevron-left"></i> Android当中的MVP模式（三）基于分页列表的封装
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BigZ</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#官方给的例子"><span class="nav-number">1.</span> <span class="nav-text">官方给的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对异步方法的分析"><span class="nav-number">2.</span> <span class="nav-text">对异步方法的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Request"><span class="nav-number">2.1.</span> <span class="nav-text">Request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Call"><span class="nav-number">2.2.</span> <span class="nav-text">Call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response"><span class="nav-number">2.3.</span> <span class="nav-text">Response</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OkHttpClient"><span class="nav-number">2.4.</span> <span class="nav-text">OkHttpClient</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用姿势"><span class="nav-number">3.</span> <span class="nav-text">使用姿势</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BigZeng</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
