{"meta":{"title":"CODE FRAMER BIGZ","subtitle":"Every little makes a mickel","description":null,"author":"BIGZ","url":"http://zengfanyu.top"},"pages":[{"title":"分类","date":"2017-10-25T14:59:18.000Z","updated":"2017-10-25T15:05:10.156Z","comments":false,"path":"categories/index.html","permalink":"http://zengfanyu.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:58:45.000Z","updated":"2017-10-25T15:05:14.395Z","comments":false,"path":"tags/index.html","permalink":"http://zengfanyu.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2018 年终总结 + 12 月份面试总结","slug":"2018summary","date":"2018-12-31T12:32:16.000Z","updated":"2018-12-31T12:47:11.734Z","comments":true,"path":"2018/12/31/2018summary/","link":"","permalink":"http://zengfanyu.top/2018/12/31/2018summary/","excerpt":"","text":"2018.12 面试问题记录拼多多一面「现场面」 设计一个全平台唯一的id a b c 三个库同时引入了不同版本的 d库，然后 e 需要引入 a b c 三个库，如何解决兼容性的问题「如果是通过gradle方式远程依赖，可以用exclude关键字去剔除不同版本的包，以某一个版本的为准」？ ThreadLocal 进程之间通讯的方式 Actitivty旋转之后的生命周期怎么走 HashMap 和 ConcurrentHashMap ArrayList 和 LinkedList， ArrayList 怎么扩容的 输入一个域名，它整个的流程？如何优化这个流程？ 域名劫持知道吗？ 算法一： String 类型的List，去掉非法字符 “” 和 null，保证相对顺序不变 算法二： 在算法一的基础上，如何去掉重复的字符 二面「现场面」 项目中为什么使用webrtc，或者你跟我讲讲webrtc是什么，它做了哪些工作去保证低延迟？ http协议了解吗？ 讲一下它的作用 http协议是怎么分配端口号的 http1.1 和 1.0的区别 已经有了TCP，它本来就可以传输数据，为什么还需要HTTP？ TCP 和 UDP的区别，为什么TCP是可靠的？他是怎么完成的 项目当中日志sdk是怎么做的？打印日志格式化怎么格式化？ 怎么打印的行号？ 怎么传到服务端？ 上传SDK项目是怎么做的？SDK的流程？怎么实现并发的？ 算法，求一个二叉树的高度 「递归」 我们公司的工作时间你了解吗？ 能接受吗？ 目前公司的工作时间是怎么样的？ 你现在的薪资？期望的薪资？ 哔站一面「现场面」 毕业时间一年多，不长呀，为啥跳槽呀？这都年底了 在学校学哪些东西「软件、硬件、电子啥都学」？哪儿学的Android开发「自学」？ 数据结构、操作系统、计算机网络了解吗「了解，一直在学习」? HashMap用过吗？讲一下hashcode怎么计算，比如我给你一个类A，他有三个成员变量 String s, int i, boolean b, 怎么计算hashcode？ 如果我只用string s 去计算 hashcode，有什么问题吗「这儿我提到了如果不同的 A 类， s相同而其他变量不相同，会导致hash碰撞多，并且散列不均匀，导致map的插入在同一个链上，最终影响查找效率，针对这一点hashmap在java1.8增加了红黑树结构」？ 为什么当链表长度超过8就转换成红黑树「查找时间复杂度 o(n) 和 o(logn) 的区别」？ 为什么是转换成红黑数查找就是 o(logn)了 「二分查找，分治思想」，普通二叉树可以么「不行，普通二叉树不平衡，不能保证平均查找效率」？ SparseArray 知道么？它拿来干嘛的「google 建议替换 hashmap key 为 Integer情况」？为什么要用它去替换？它的数据结构是怎么样的？假设现在不考虑哈希碰撞和散列不均匀，10000个数据，你用hashmap还是sparseArray「我说sparseArray， 提到了对于 Integer int 的装箱和解箱操作」？ 你在开发中怎么用线程「runnable callable Future FutureTask ThreadPoolExecutor」？线程池怎么用？如何选择线程池，或者说它的参数怎么配置？假设我现在要做网络请求，高并发的，你怎么去配置线程池的参数或者说怎么使用Collections的工厂方法去创建「我从OkHttp源码中使用的是 核心线程数为0 最大线程数为 Integer 最大值，超时时间 60s 这里来回答的，采用这种配置，或者是使用 Collections.newCacheThreadPool， 从高并发和超时时间这里入手」？ HandlerThread什么原理？它和Thread有什么区别「Looper角度回答」？Looper是什么？普通线程有Looper吗？Looper怎么用「这里提到了ThreadLocal」？ ThreadLocal是干嘛的？在哪儿用的？怎么用？ OkHttp知道吗？用过吗？源码了解吗？画个流程图？你觉得源码设计最经典的是什么「责任链模式」？有哪些拦截器？调用顺序？普通interceptor和networkIntercptor有什么区别？怎么选择？连接网络在哪个拦截器？ 手写一个单例看看「volatile + 双重锁模式」。为什么这里要有volatile「从可见性和指令重排序角度分析」？为什么有两个判断？你用的synchronized代码块的this表示什么？如果我就以饿汗式去实现，它是安全的吗「这个问题没回答上，于是面试官换了一个问法」？这个static得成员变量在哪里初始化的「static是属于这个类的， 随类一起初始化」？具体是在哪儿呢「一脸懵逼，不知道」？了解过ClassLoader吗「听说过，不了解，面试官说静态的初始化在ClassLoader当中，是线程安全的，所以说，这种形式是可以保证安全的」？ 二面「现场面」 WebRTC这个项目你们几个人做？你在WebRTC 这个项目中的具体工作内容？ 你入职一年以来主要是在做哪个项目？ WebRTC 这个项目我看Android端主要是你在做的，能说说SDK大概的架构吗？ WebRTC 这个我看你做了重连模块？为什么要做这个模块？具体怎么做的？ 现在写C++有困难吗？ 你们这个视频上传的主要过程？ 为什么有这个日志上传的SDK，它主要做什么？ 。。。后面的时间太久，记不住了。 声网一面「电话面」 自我介绍下自己 为什么这个时候跳槽？ WebRTC 这个项目你们几个人做，分工是怎样的？ WebRTC 视频会议系统架构是怎么样的？项目的细节，房间流数目怎么限制的？分辨率怎么设置的？码率是多少？屏幕流时怎么采集的？ 你们WebRTC应该只是在国内用，那你们怎么进行连接的呢「ICE STUN + TURN」？ Android中多进程有哪些方式「Messenger、Socket、ContentProvider、文件、AIDL」？AILD的底层实现是什么「Binder」？Binder的工作原理？ Java GC 了解么「描述了一下Java运行时的内存分区，几种GC算法引用计数、停止复制、标记清除、分代收集」？ View SurfacView GLSurface 的区别了解吗「这个不知道。。。」？ TCP 和 UDP 区别「面向连接、可靠、字节流； 无连接、不可靠、用户数据报」？TCP做了哪些操作保证连接可靠？ UDP 使用的场景「WebRTC 中视频数据的分发」？ 你觉得你工作一年多遇到最大的挑战？ 你觉得你喜欢编程吗？ 多媒体流的格式？ 硬解软解这些有了解吗？ 二面「现场面」 约得下午两点，由于对路况不熟悉，所以提前出发了，一点多一点就到了，面试官都去吃饭了，于是一个阿姨联系HR之后，给了一份笔试题我先做做。 笔试题的内容主要包括三块： Android的基础知识、数据结构和算法的题目、两道程序题「看代码写出运行结果」、JNI相关题目、计算机网络相关。后来做完题面试官过来了，就正式开始了。 自我介绍一下 Android开发是怎么学习的？ 现在工作中主要是做哪一块？ 工作中有涉及到SDK技术支持吗？还是主要负责编码不做技术支持？ 你们SDK用Java写的，没有其他的语言的需求吗？你出了Java还会哪一门语言？ 对于Android程序的运行原理了解吗？就是在桌面上点击一个app图标只有，到app启动这一系列的过程？ JNI 和 NDK这一块了解吗？ Android 当中常用的异步方式有哪些？ Handler的运行机制？ThreadLoca？Looper？HandlerThread？ 按照你的描述，你平时开发应该是Java用的比较多，JMM了解吗？Java运行时内存区域划分？volatile synchronized？一个类的实例在内存空间的哪儿？方法局部变量存在内存空间的哪一块？类的成员变量存在类的哪一块？ abstract 和 interface？语法上的区别？使用上的区别？ WebRTC这个项目你主要是做哪一块？详细到WebRTC的一些使用细节 你用过我们的实时视频会议的app吗？你觉得跟你们的app比起来区别在哪？ 二面应该是对我个人做一个大概的定位，包括技术广度和深度。 三面「现场面」 面试官自我介绍是iOS的负责人，应该是属于交叉面吧。主要聊的是RTC项目细节 你们WebRTC项目你主要做哪一块？怎么分工的？ 你刚才说道日志记录上传模块，你是怎么做的「分SDK，策略设计模式、主动上报、被动上报」？ 哪种情况下被动上报「结合RTC项目描述了一下」？ web api 、socketio、peerconnetion 的重连逻辑细节。 按照你刚才的描述，如果现在是有wifi网络的，但是因为wifi的速度不快，没有成功连接，那么这时候日志还去上报，那么会不会导致网络更差？ 日志存在哪儿「本地文件」？多大「5M」？每次上报都传5M「不一定，要看上报时刻的大小，并且还会做压缩」？超过5M怎么办「删除文件重新写」？会不会刚好删除了文件，上吧之后是一个空的日志文件，或者说关键记录被删除了然后正好上报了「理论上会出现」？怎么解决「另开一个backup路径，这个路径用LRU算法，限制为10M，原有日志路径下的日志需要删除时，转移到此处，然后在上报时刻一起压缩上报」？ 日志这一块有专业的工具吗「demo的app层用到了云迹，后期接入方应该也会用这个工具」？那SDK日志你们是怎么分析的「上报日志、后台获取、人工定位分析」？你们一次进入频道三客户端正常交互，然后离开频道，这个过程日志有多少「几千行应该有」？说说你具体的分析过程，比如我现在进入频道，应该看到3个人，但是只看到两个，你拿到一个全量的日志，怎么分析？ 你们RTC项目对房间中流数量有限制吗？NAT穿透这块你们是怎么做的？JNI层你有涉及到吗「面试前两天，刚好是弄了一个ubuntu系统，把RTC的Android端源码拉下来成功编译了，就这个过程聊了一阵子」？编译出来之后，你有研究它的java层或者底层代码吗「刚编译出来就过来面试了。。平时开过摄像头画面采集这一块的java层代码」？ 算法题，判断链表是否成环「两指针ab，a一次走一步，b一次走两步，判断是否指向同一个节点」？两指针走任意不同步数可以吗？证明你的结论 你有什么要问我的「问了一些声网的业务，然后问了一下低延时实时视频通讯声网做到哪个程度了」？ 头条一面 二面「视频面」 头条问的问题太多了，记不清哪个是一面问的哪个是二面问的了，此处就统一记录了。 自我介绍一下 视频上传这个项目主要是干嘛的？ 视频上传具体的流程？ 如果是分段上传， 两个客户端传同一个文件，服务端怎么决策，各个客户端传的字节范围？ TCP 和 UDP 的区别？ TCP 和 UDP 能不能监听同一个端口号？ TCP 和 UDP 是运行在 TCP/IP模型的哪一层？ TCP 和 UDP 的头部大小，字段？ TTL 是什么？ 日志上报SDK只要是干嘛用的？ 日志上报SDK如何进行上传？ 日志上传上传的文件有多大「5M」？有没有压缩「项目中居然没有压缩。。。面试官说他觉得不压缩不行」？ 日志上传上传是什么策略？用什么进行上传的？ 如果网络断开怎么办「这一块是用handler将一个runnable post到子线程去上传，并且监听设备网络连接状态，如果网络断开，会将这个runnable给缓存起来，当网络连接上时，在尝试上传。回答的时候错说成将这个5M的文件给缓存到内存中了」？ websocket 和 http 区别？ websocket 的升级过程？ webRTC 你了解到哪个层面？底层音视频编解码了解过吗？ 算法 二叉树的非递归形式的前序遍历 卒。其中共有两个问题，面试官指出来他觉得不太好，第一个是问题4，他问我服务端怎么决策让那个客户端上传哪一段数据？我说不太清楚，我是直接调那个webapi接口，它返回的那个范围我就通过RandomAccessFile去读哪个字节。他说我对跟我业务相关的上下游的基础逻辑不太清楚，不利于问题的排查。第二个问题是12，他说我负责做上传的，但是在实际上传过程没有做压缩处理，他觉得不行，5M文件太大，会占用太多资源。这一块我们wiki上其实是说了要压缩成zip格式的，但是这块是同事开发的，我做了二次开发，优化了一下代码，当时发现没有压缩，问过同事，他说也可以传，哎，自己就没太多关注，后来回公司后，马上把这块做了压缩，压缩后的大小是之前的1/16。。。 面试之后的思考最近一共面了4家公司，对于我这么一个工作经验只有一年半的候选人来说，面试官都特别注重基础的问题，比如Android相关的源码分析「异步方式、线程池、消息机制」、Java语言相关「JMM、线程安全、GC、线程安全集合、线程同步方法」、数据结构「HashMap、SynchronizedHashMap、ConcurrentHashMap、ArrayList、LinkedList。。」、计算机网络「HTTP、TCP、UDP、IP、WebSocket、DNS。。」。其次就是对于我这一年半工作内容提问，具体到细节如何实现，在现有基础上的优化，包括我负责的模块相关上下游的问题，用于考察我对于项目的整个系统了解的程度。 在这一段时间的面试中，我发现了自己身上的一个很明的短板：编码语言掌握的过于单一，工作中只涉及到Java的编程。上述四家公司，几乎都问道了我会哪些编程语言，能不能做C/C++的开发，有没有接触过JNI，但是就目前来说，我确实在这一块是非常欠缺的。其次在声网的面试当中，我认识自己做的WebRTC项目主要是在SDK API 的封装加上应用层app开发，并没有深入到音视频的底层当中去，面试官建议如果想走音视频这一块，可以多了解一些音视频的协议、包括编解码、视频采集、渲染等相关的知识，然后学习一些开源的项目。 2018年的总结2018 是我的本命年，24岁了，工作一年半「用某人的话说，就是典型的三无人员，没车没房没老婆。。哈哈哈」，在去年这个时候，本来也是想写一个年终总结的，但是去年一年没干什么正经事，上半年忙于春招、实习、论文，毕业之后来到上海没两天，跑去南京培训三个月，再回上海就开始正式熟悉部门的项目，开始干活，于是去年就没有写年终总结，在今年的最后一天，睡到自然醒之后，煮了个饺子吃饱肚子，开始把这一个月的面试总结一下，顺便总结一下2018这一年了。 工作学习方面今年一年基本上是接触了部门当中所有的项目了，包括五个SDK，主要的精力是放在 WebRTC 的视频会议 SDK 上，这个项目是从去年十一月份开始的，一直做到现在，期间发生了一些人员动荡，所以中断了一段时间，后来项目重新启动之后，前后端架构调整，又开始了各种折腾。不过说实话，我还是挺喜欢这种感觉的，因为每天都很明确自己需要干什么。有几个SDK没能接触到真正含金量高的底层，一直在做 API 的包装和 DEMO 的实现，很是遗憾。 到今年下半年好多一起入职的应届生同事们都开始陆续离职，包括我的一位大学同学和一位高中同学，那段时间其实我也很迷茫，反复思考自己要不要也离职，后来综合各方面的因素，决定留下来，2018 年底或者是 2019 年初在考虑跳槽，然后在准备四个多月后，加上身边一些事情的影响，决定在 12 月开始面试，没能够去心仪的那一家公司。 总结一下今年做的一些琐事： 在被公司设备蹂躏了一年之后，在今年 8 月份决定买一台 Mac Book Pro 工作学习用，没想到没高兴一阵子，就把它摔的不忍直视。 用 Hexo 搭了一个博客，今年一共写了 30 篇，不过从 8 月分换了 Mac 以来，没有重新在 Mac 上搭环境，一些总结的笔记也就没有传到 Hexo 上「可能是天道有轮回，用了不到四个月的 Mac ，被我摔地上，A 面和 C 面摔了一个大凹槽，丑死。。不过幸好屏幕没破，还可以用。」，所以我决定在今年的最后一天，在 Mac 上把 Hexo 的环境搭起来，接着写博客。学习 MarkDown 语法，配合 Typora 写博客，简直不要太爽。 花了一段时间和团队测试学习抓包工具 WireShark、Charle、PostMan的使用，感觉这些工具真的是挺能提高效率的，然后会把一些书本上的理论知识在这些工具上真正的展示出来，比如说 TCP 三次握手 四次挥手、WebSocket 的连接请求升级、HTTPS 的握手过程在 WireShark 上看的清清楚楚。 年初对 MVP + RxJava + Dagger + Retrofit + OkHttp 这种模式的应用很感兴趣，于是花了好长一段时间去学习相关的知识，然后在博客中总结，并且按照这种模式，写了一个资讯类的应用。 年初说要系统的学习 Java 当中的 24 种设计模式，并且在 GitHub 上开了一个 Repo 专门提交代码，并且在博客中用文章记录。这个事情呢最后是没有坚持下来，只学习了 桥接、代理、适配器、责任链、简单工厂、工厂方法、抽象工厂方法这几种。后面 RTC 项目自己接手后，对于一个全新的东西，自己不了解更多时间放到这一块了，当然，这不是我半途而废的理由。 RTC 这个项目和网络这一块联系很紧密，WebAPI 用的是 OkHttp 库请求，长连接用的是 SocketIO 库，视频数据发送底层用的是 UDP 协议，所以今年把HTTP 、TCP、UDP、WebSocket 协议好好学习了一下，并且在日常工作中处处能体现出来这些之前在学校中完全没在意的课程的重要性。越发感觉在读书时候学的那些课程的重要性了。 看了一段时间的网络请求库 OkHttp 、老牌图片加载库 Universal-Image-Loadler、新晋图片加载库 Glide的源码，看了下 JDK 当中一写类源码： ConcurrentHashMap、SynchronizedHaahMap、LinkedBlockingQueue、LinkedHahsMap「LRUCahce 的底层实现」等等。 去了一趟 Google 开发者大会，感受了一下巨厂的技术氛围，顺便在从 Google 开发者大会回来之后决定，是时候开始准备复习面试了。 用 XMind 做了一个思维导图,展开后是特别大的一张思维导图，零零散散做了四个月的时间，涉及到 Java 基础、Android 基础、计算机网络、数据结构、设计模式、Git、SDK 开发的一些总结、项目总结等，在 12 月的面试当中验证，面试官问的问题很多在我思维导图中以及记录过了。所以我准备后期持续跟新这张思维导图，增加不同的模块。 看了几本书《Thinking In Java》 这本书是大三为了准备秋招买的，后来带来上海后，一直放着没看了，今年拿出来好好看了下；《图解HTTP》跟漫画一样的一本书，用来入门 HTTP 协议还是挺不错的；《Android 开发艺术探索》 Android面试宝典，之前读书时候 IPC 这个章节感觉看不懂，今年硬是把它给啃下来了， 不过还有一个四大组件的启动流程和各种ServerManager的交互这一章没看。《Gradle 权威指南》是因为做SDK经常要打包一些 aar jar 等各种包看完之后对于Gradle的一些基本操作有了了解，顺便学了一下 Groovy 这个脚本语言，在 gradle 文件中和 java 配合写一些脚本还是可以的；《WebRTC 权威指南》看的时间最长的一本书了，今年主要精力在做WebRTC的项目；《Java并发性和多线程》极客学院的 wiki 上下载，《Java并发编程实战》实战，这两本书是因为下半年做项目，遇到的多线程问题没解决，导致项目延期，后来老大亲自出手来改的bug，后来决定好好学习这一块的知识，所以买回来看的。 还有好几本书没来得及看，《Effective Java》也是大三为准备秋招买回来的书；《鸟哥的Linux私房菜 基础学习篇(第三版)》《 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》这两本书是当时和《Java并发编程实战》一起凑满减买的，也没来得及看。《Primer C++》都是眼泪。 周末有空做过一阵子外包活，挣到了几万块钱，但是做了一段时间之后发现，在经济上是会有一定的回报，但是占用时间确实过多，综合各方面因素，后面就没有接着做了。 12 月份的面试发现自己在技术方面的严重短板，掌握的编码语言过于单一，只会 Java， 但是做 Android 音视频这块，底层更多的需要的是 C/C++ ；日常工作只涉及到 app 、sdk 的开发，关于音视频的底层只有基础的认知没有深入的了解，比如各种编解码方式、各种容器封装格式、多媒体流协议、等等。 即使后面做其他的，C/C++ 也是必须要掌握的呀。对于面试的结果，五五开吧。 生活方面生活方面今年这一年实在是很单调，工作日上班、周末休息睡觉，不过学习了新技能，有收获，也有一些遗憾。 在家了几个月的饭，带到公司去吃，虽然是几个简单的菜，不过也算是会做饭的人了，哈哈哈 夏天坚持了三个月的锻炼，买了个瑜伽垫，每周末去跑步，体重一度降到 132 斤，不过冬天又反弹回来了。 可以一个人逛超市，吃火锅，看电影，也算是新技能了。 团队来了一些新的小伙伴，都是同龄的，每天工作算是比较开心了。 学习了一些投资理财方面的知识，在支付宝上买了几个基金练练手。 今年没能够出去旅游一次，很大的遗憾，一直想去找成都的大兄弟耍耍，又因为各种原因没去成。 2019TODOList经过去年的教训，Flag 不能立太多。 学 C/C++； 学 python； 把剩下几本书看完《Effective Java》、《 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》、《鸟哥的Linux私房菜 基础学习篇(第三版)》、《Primer C++》； 在新公司好好干； 办一张健身卡，坚持锻炼； 每星期给爸妈打一次电话，每个月给爷爷奶奶打一次电话，给小王把那几个色号的口口红给买全。","categories":[{"name":"年终总结","slug":"年终总结","permalink":"http://zengfanyu.top/categories/年终总结/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://zengfanyu.top/tags/总结/"}]},{"title":"记录 SDK 对外输出时碰到的两个问题","slug":"debug","date":"2018-08-18T10:00:16.000Z","updated":"2018-08-18T10:24:30.519Z","comments":true,"path":"2018/08/18/debug/","link":"","permalink":"http://zengfanyu.top/2018/08/18/debug/","excerpt":"摘要：compile provided 的运用，不同 moudule 之间依赖本地库和远程库的区别.","text":"摘要：compile provided 的运用，不同 moudule 之间依赖本地库和远程库的区别. 记录一下最近对接 SDK 碰到的一些问题，后面再次碰到时能够快速结局。 问题一 关于compile、provided背景：由于 SO 冲突的原因，我们对外提供的 SDK 现在需要从原来的 aar 形式改为 Jar + SO 的形式，假设我们统一对外提供的 SDK 叫 A.aar， A 在内部会依赖 SDK B.aar 和 So 库。 先复习一下 aar 和 jar 的压缩文件结构： aar 结构 res 中放置的是资源文件libs 中放置的是 jarjni 中放置的是 so jar 结构 里面就是 Library 的包结构以及类的 CLASS 文件。 一开始我把 SDK B 打包成 B.jar，然后在 SDK A 中依赖 B.jar ，然后在打 jar 包的时候将 B 一起给打进 A.jar 中（如何在打 jar 包时将 libs 下的 jar 一并打入: Android Studio 中打 jar 包和 aar 包姿势总结），然后对外提供新的 A.jar + SO ，但是使用方在编译时报出如下错误： 重点： android.view.inflateexception binary xml file line #0 error inflating class ... 在 inflate XML 文件的时候出错了，到这里，我立马就想到，是不是 SDK A 或者 B 中有用到一些资源文件，而 Jar 包并不能包含资源文件所导致的？ 回去检查后发现，SDK B 中确实依赖有一个 XML 文件，但是 jar 中是没有包含的，所以在运行时会报出错误。 这么说，直接将 B 的 jar 给 打进 A 的 jar 中这种方法因为资源文件的问题，是不可行的了，所以又想到一个方法： A SDK 还是依赖 B SDK 的 aar，然后在编译阶段是可以通过的，并且在最后打 jar 包时，是没办法将 B.aar 给打进总的 jar 中的，所以就额外提供 B.aar，最后对外输出是 A.jar + B.aar + so。 其中 A 的 gradle 文件如下： 这样使用方在使用的时候就正常了， 但是在混淆后打 APK 包时，又出现了一个错误： 重点： Duplicate zip entry [com/xxx/xxx/R$anim.class)) 通过包名可以确定 com/xxx/xxx/R$anim.class 是 B SDK 中的类。 问题很清楚了，是因为 B SDK 引用了两次，在打包时反射调用动画的 id 时报出来的错误，所以将 A.jar 重复依赖的 B.aar 给删除掉就行了。但是检查了一遍又一遍发现，B.aar 并没有被依赖多次。 但是从逻辑上来说，A.jar 依赖了 B.aar ，然后又额外提供了 B.aar ，只有这个地方是存在逻辑上的重复依赖的，但是并没有真的重复依赖。 注意上图中 compile(name:&#39;B&#39;,ext:&#39;aar&#39;) 其中 compile 的含义：对所有 buildType 以及 flavors 进行编译并打包到 apk。 到这里就基本清楚了， 我们在 A 中依赖的 B.aar 只是为了让编译通过，并不需要这里的 B 的相关数据给打包打 APK 中，需要打包到 APK 中的应该是额外提供的 B.aar。 所以将 comile 给换成 provided ，其作用是：只在编译时使用，只参与编译，不打包到最终 apk 。 这么一来，成功解决如上问题。 问题二 moudle 间本地和远程包依赖假设主 moudleA 依赖子 moudleB ，在 moudle B 中会依赖远程的库 pp-sdk： 12compile 'com.aaa.bbb:pp-sdk:1.0.14' moudle A B 之间的依赖关系： 123456789101112131415 #A的build.gradle文件 android &#123; ..... repositories &#123; flatDir &#123; dirs 'libs' &#125; &#125;&#125; dependencies &#123; compile project(':B')&#125; 这种依赖方式编译和运行都是没问题的，但是如果 B moudle 依赖的 pp-sdk 由远程仓库的变成本地的 aar: 12complie(name:'pp-sdk-v1.0.14',ext:'aar') 那么就会报错： 原因是 moudle A 用到了 pp-sdk 中的类，但是 moudle A 在它自己的 libs 文件夹下找不到这个类的地址，所以应该让 moudle A 也能找到 moudle B 中的 libs 路径，也就是说，如果有一个全局的地方，能够让 moudle A 设置一下 moudle B 的 libs 地址，那就可以了。 根目录下的 build.gradle 刚好就可以提供这样的功能： 12345678910allprojects &#123; repositories &#123; jcenter() //添加如下代码 flatDir&#123; dirs project(':B').file('libs') &#125; &#125;&#125; 在allprojects 这个方法下的配置是应用到所有的 moudle 中的，所以在这里将 moudle B 的 libs 地址给添加进来，moudle A 就能找到 moudle B 中 libs 目录下的 pp-sdk 了。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"BugFix","slug":"BugFix","permalink":"http://zengfanyu.top/tags/BugFix/"}]},{"title":"《图解 HTTP》 第六章 HTTP 首部读书笔记","slug":"HttpHeaders","date":"2018-06-09T09:25:16.000Z","updated":"2018-06-09T09:28:58.426Z","comments":true,"path":"2018/06/09/HttpHeaders/","link":"","permalink":"http://zengfanyu.top/2018/06/09/HttpHeaders/","excerpt":"","text":"《图解 HTTP》 第六章 HTTP 首部读书笔记","categories":[{"name":"计算机网络基础拾遗","slug":"计算机网络基础拾遗","permalink":"http://zengfanyu.top/categories/计算机网络基础拾遗/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://zengfanyu.top/tags/HTTP/"}]},{"title":"一口一口啃完Java中的24种设计模式---简单工厂模式、工厂方法模式、抽象工厂方法模式","slug":"工厂模式三兄弟","date":"2018-06-09T02:32:16.000Z","updated":"2018-06-09T02:32:09.619Z","comments":true,"path":"2018/06/09/工厂模式三兄弟/","link":"","permalink":"http://zengfanyu.top/2018/06/09/工厂模式三兄弟/","excerpt":"","text":"工厂模式总结 UML图简单工厂模式 UML 图 工厂方法模式 UML 图 抽象工厂方法模式 UML 图 Demo简单工厂模式 Demo比较简单，此处略去。 工厂方法模式 DemoFactory需求： 系统运行日志记录器(Logger)，该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以灵活地更换日志记录方式。 12345678/** * @author: fanyuzeng on 2018/5/26 10:54 */public interface LoggerFactory &#123; //此处创建 Logger 方法可重载 Logger createLogger();&#125; Product1234567/** * @author: fanyuzeng on 2018/5/26 10:53 */public interface Logger &#123; void writeLog();&#125; concreteFactory123456789101112131415161718192021222324252627/** * @author: fanyuzeng on 2018/5/26 10:55 */public class DatabaseLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 10:55 */public class FileLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; //创建文件日志记录器对象 Logger logger = new FileLogger(); //创建文件，代码省略 return logger; &#125;&#125; concreteProduct1234567891011121314151617181920/** * @author: fanyuzeng on 2018/5/26 10:53 */public class FileLogger implements Logger &#123; @Override public void writeLog() &#123; System.out.println(\"数据库日志记录。\"); &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 10:53 */public class DatabaseLogger implements Logger &#123; @Override public void writeLog() &#123; System.out.println(\"数据库日志记录。\"); &#125;&#125; Test12345678910111213/** * @author: fanyuzeng on 2018/5/26 10:58 */public class Test &#123; public static void main(String[] args) &#123; LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); //可引入配置文件实现 logger = factory.createLogger(); logger.writeLog(); &#125;&#125; 抽象工厂方法模式 Demo界面皮肤设计，用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，如下所示： 该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。 Factory1234567891011/** * @author: fanyuzeng on 2018/5/26 11:33 */public interface SkinFactory &#123; Button createButton(); TextField createTextField(); ComboBox createComboBox();&#125; Product123456789101112131415161718192021/** * @author: fanyuzeng on 2018/5/26 11:28 */public interface Button &#123; void display();&#125;/** * @author: fanyuzeng on 2018/5/26 11:29 */public interface ComboBox &#123; void display();&#125;/** * @author: fanyuzeng on 2018/5/26 11:29 */public interface TextField &#123; void display();&#125; concreteproduct123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author: fanyuzeng on 2018/5/26 11:30 */public class SpringButton implements Button &#123; @Override public void display() &#123; System.out.println(\"显示浅绿色按钮。\"); &#125;&#125; /** * @author: fanyuzeng on 2018/5/26 11:32 */public class SpringComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"显示绿色边框组合框。\"); &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 11:31 */public class SpringTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"显示绿色边框文本框。\"); &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 11:30 */public class SummerButton implements Button &#123; @Override public void display() &#123; System.out.println(\"显示浅蓝色按钮。\"); &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 11:31 */public class SummerComnoBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"显示蓝色边框组合框。\"); &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 11:31 */public class SummerTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"显示蓝色边框文本框。\"); &#125;&#125; concretefactory12345678910111213141516171819202122232425262728293031323334353637383940/** * @author: fanyuzeng on 2018/5/26 11:34 */public class SpringSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; return new SpringButton(); &#125; @Override public TextField createTextField() &#123; return new SpringTextField(); &#125; @Override public ComboBox createComboBox() &#123; return new SpringComboBox(); &#125;&#125;/** * @author: fanyuzeng on 2018/5/26 11:34 */public class SummerSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; return new SummerButton(); &#125; @Override public TextField createTextField() &#123; return new SummerTextField(); &#125; @Override public ComboBox createComboBox() &#123; return new SummerComnoBox(); &#125;&#125; Test12345678910111213141516171819202122232425262728/** * @author: fanyuzeng on 2018/5/26 11:35 */public class Test &#123; public static void main(String[] args) &#123; SkinFactory factory1, factory2; Button bt1, bt2; TextField tf1, tf2; ComboBox cb1, cb2; //创建夏天风格皮肤 factory1 = new SummerSkinFactory(); bt1 = factory1.createButton(); tf1 = factory1.createTextField(); cb1 = factory1.createComboBox(); bt1.display(); tf1.display(); cb1.display(); //创建春天风格皮肤 factory2 = new SpringSkinFactory(); bt2 = factory2.createButton(); tf2 = factory2.createTextField(); cb2 = factory2.createComboBox(); bt2.display(); tf2.display(); cb2.display(); &#125;&#125;","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/tags/Design-Patterns/"}]},{"title":"Android Studio 中打 jar 包和 aar 包姿势总结","slug":"Android Studio 与 jar aar 总结","date":"2018-06-09T02:28:16.000Z","updated":"2018-06-09T02:30:05.835Z","comments":true,"path":"2018/06/09/Android Studio 与 jar aar 总结/","link":"","permalink":"http://zengfanyu.top/2018/06/09/Android Studio 与 jar aar 总结/","excerpt":"","text":"好久没有写博客了，最近部门低延迟会议项目提测了新版本，这周六可以来公司看看书，写写博客。前阵子的工作中，有件事情还是耗费了我很长的时间的，就是重新打包对外输出的 SDK，之前只是用过了解过 aar 和 jar ，但并不明白他们之间的关，问题列举： 打的 jar 包中没有包含 libs 目录下引用的 jar 导致目标项目无法直接使用 打的 aar 包引用了 maven 库，目标项目无法直接使用 通过这篇博客，记录如何解决如下几个问题： 在 Android Studio 中如何打 jar 包、使用 jar 包 如何把 libs 目录下依赖的 jar 打进总的 jar 中 如何修改 jar 包中的类 如何在Android Studio 中打 aar 包、使用 aar 包 解决 aar 中依赖的 maven 库在目标工程中无法使用的问题 Android Studio 中打 jar 包总的来说，有两种方法，这两种方法的前提都是这个 module 的 gradle 文件使用 apply plugin: ‘com.android.library’ 直接编译实现直接 Rebuild Project ，然后在以下目录中可以找到 Jar 包： 图中红色框框中的 jar 包就是 media_upload 这个 moudle 的 jar 包。直接复制到其他 moudle 的 libs 文件夹下，然后进行相应的配置就可以使用。 通过 gradle 脚本实现首先将下面的 gradle 脚本添加到 media_upload moudle 的 gradle 文件中 123456task makeJar(type: Jar) &#123; archiveName = 'upload-sdk.jar' from('build/intermediates/classes/debug/') destinationDir = file('build/lib') &#125; makeJar： Task 的名字 type: Jar：告诉 gradle 新建的 task对象从 Jar 基类派生。 archiveName：生成 jar 包的名字 from(‘build/intermediates/classes/debug/‘)：将此路径下所有 class 文件都打包到 jar 包内（这里是 debug 版本） destinationDir：生成 jar 包的目录 然后到 gradle 窗口中，找到 media_upload moudle，然后在它下面的目录找到我们定义名字为 makeJar 的 task： 双击这个 task ，看到以下界面代表 task 执行成功： 这样，生成的 jar 包的名字就是 upload-sdk ，存放于 build/lib 路径处，如下图： 这种打包方法虽然比较麻烦，有一个优点：假设 media_upload 这个 module 还依赖于其他的 jar 包（位于 libs 目录下），那么使用这种方法可以将 media_upload 依赖的其他 jar 包也一并打入总的 upload-sdk.jar 中。 将 libs 下的 jar 打到总的 jar 包下 从上图中可以看到， media_upload 这个 moudle 是依赖于 httpclient 和 okhttputils 这两个 jar 包的，如果直接使用上面的第一种方法，直接编译，这两个 jar 是不会被打进总的 jar 中的；而使用第二种 gradle 脚本的方式，就可以实现，但是 gradle 的脚本需要改变一下： 123456789 task makeJar(type: Jar) &#123; archiveName = 'upload-sdk.jar' from('build/intermediates/classes/debug/') from (project.zipTree('libs/okhttputils-2_6_2.jar')) from (project.zipTree('libs/httpclient-4.2.3.jar')) destinationDir = file('build/lib')&#125; 多添加的两行也很好理解： from (project.zipTree(‘libs/okhttputils-2_6_2.jar’))：将 libs/okhttputils-2_6_2.jar 给打包进 upload-sdk.jar 中。 from (project.zipTree(‘libs/httpclient-4.2.3.jar’))：将 libs/httpclient-4.2.3.jar 给打包进 upload-sdk.jar 中。 这样最后生成的 upload-sdk.jar 中就已经包含了 httpclient 和 okhttputils 这两个 jar 包了。 在主 module 中使用依赖 jar至于使用 jar 包，先把 jar 包放置于主 moudle 的 libs 文件夹下，然后再主 module 的 gradle 文件的 dependencies 下添加： 12compile fileTree(dir: 'libs', include: ['*.jar']) 也就是引用 libs 文件夹下所有以 jar 结尾的包。 或者指定引用某一个： 12compile files('libs/xxxx.jar') 在平时编写 SDK 时，一般会存在一个或多个 library 的 moudle，然后会有一个主 moduel 用于针对 library 编写 demo 测试，这时主 moudle 是需要依赖 libray module 的，在主 module 的 gradle 文件中编写如下： 1234compile project(':aaaaa')compile project(':bbbbb')compile project(':ccccc') 其中 aaaaa bbbbb ccccc 分别为依赖的 moudle 的名字。不能忘了在 setting.gradle 中添加各个 moudle： 1234include ':aaaaa'include ':aaaaa'include ':aaaaa' 这样各个 moudle 才会被编译，Android Studio 中会自动添加。 替换 Jar 包中的类这个事情的场景是这样：我们上传的 SDK 在计算分段文件的 MD5 值时，计算失败的情况当时由于编码原因，并没有相关的回调到上层，这时候使用我们 SDK 的同事需要联系我们，然后让我们修改代码，重新打 Jar 包，在给他们，然后他们那边再更新验证。 其实添加个回调到上层很简单，但是如果 SDK 的开发部门和使用部门不是同一个，还是比较麻烦，为了避免以后我自己遇到这样的情况，我在想，能不能我自己修改 Jar 包中的类？ 修改第三方库中类的方法 下载并引入所有第三方类中的源码，然后对应修改。 使用 ASM 等工具直接修改对应类的字节码。 第一种方法的优点是不容易出错，debug 时方便，但是比较麻烦，如果碰上 okhttp 这种用 Maven 组织的项目，对于习惯 Gradle 组织项目的 Android 工程师来说，确实是一个很头疼的事情。 第二种方法的优点是非入侵，但是由于修改了字节码文件，无法和源码对应，同事会导致 debug 时出错几率增大 。 Duplicate Class相信很多人在打包 Apk 的编译期（Build Time）遇到过「Duplicate Class」的错误。原因是 Dex 构建工具在把所有类打包进同一个 Dex 的时候，如果发现如果有重复的类要打包进 Dex 的话，就会报错。 而在编辑期（Edit Time）的时候，如果我们的所有源码中有重复类的话，IDE 也会提示错误。但是如果我们的源码里有一个和第三方 Jar 包里重复的类，IDE 是不会提示错误的。为什么呢？ 因为重复类并不在同一个 Archive 里。Archive 可以看作类的容器，可以是一个 Jar 包，也可以是一个 Dex。当然你某个 Module 中的所有源码，也可以想像成是一个 Archive，所以源码有重复类是会提示错误的。 总结一下，在源码中的类和 Jar 包里的类有重复的情况下，在编辑期是不会提示错误的。只有当到了编译期，构建工具将你源码编译出来的类，和第三方 Jar 里的重复的类，混合到同一个 Archive 里的时候才会报错。 修改 Jar 中类的方法既然，IDE 允许源码中有和 Jar里的类重复的类。那么，对于开头提到的问题，我们可以提出一种新的解决方案： 只把 Jar 里想要修改的类的对应源码拷贝到项目中修改，然后在最终编译的时候把 Jar 包里这些类给删除掉。保证在打包进 Dex 的时候只有我们拷贝的源码编译出来的类即可。 这里引入一个库：JarFilterPlugin，它的作用在它主页上写的很明确： Before building the jars into android dex archives, filter files inside them. 使用方法： Intergate this gralde plugin: 123456789buildscript &#123; repositories &#123; maven &#123; url \"https://jitpack.io\" &#125; &#125; dependencies &#123; classpath \"com.github.nekocode:JarFilterPlugin:$&#123;lastest-verion&#125;\" &#125;&#125; Apply and configure the plugin: 假设我们想要修改 Android Support V7 包里的 AppCompatActivity 类。我们只需要把 AppCompatActivity 类的源码拷贝到我们的项目中，然后在 App Module 的 budil.gradle 下添加如下配置： 123456789101112131415161718apply plugin: 'jar-filter'jarFilters &#123; \"com.android.support:appcompat-v7:(.*)\" &#123; excludes = [ 'android/support/v7/app/AppCompatActivity.class', 'android/support/v7/app/AppCompatActivity\\\\$(.*).class' ] &#125; // Local jar \"android.local.jars:xxx.jar:(.*)\" &#123; includes = [ 'xxx' ] &#125;&#125; Android Studio 中打 aar 包aar 中依赖的 maven 库在目标工程中无法直接使用的问题部门经常对外输出 SDK ，Android 端是以 aar 或者 jar 的形式对外输出，并配套相关 demo ，jar 相关的上面已经记录了，这里记录一下 aar 相关。 假设我有一个 library 引用了 okhttp 的 maven 库，那么如果我在 demo 里使用 build project 从 outputs/aar 路径下拿出来的 aar，那么就会报错，找不到 okhttp 相关的类。 也就是说，直接 build project 这种方式输出的 aar ，在目标项目中直接引用，是没办法使用到 aar 当中的依赖的，当然，在目标项目中将 arr 的依赖再重新依赖一遍，是可以的使用的，但是这种操作确实不太优雅，和我们模块独立的想法也有冲突，那么就要有一种方法解决这个问题。 解决方案1将 aar 发布到本地或者发布到公司的私服上，私服上会自动让 aar 继续依赖其他的第三方库,这样在目标项目中就可以在 build.gradle 中以依赖的形式来集成aar，代码如下： 123456789101112131415161718192021222324252627282930313233ext &#123; PUBLISH_GROUP_ID = &apos;com.xxxx.yyyy&apos; PUBLISH_ARTIFACT_ID = &apos;zzzz-sdk&apos; PUBLISH_VERSION = &apos;0.0.7&apos;&#125;def getRepositoryUsername() &#123; return hasProperty(&apos;NEXUS_USERNAME&apos;) ? NEXUS_USERNAME : &quot;&quot; //账号 放置于 local.properties 不同步至 maven&#125;def getRepositoryPassword() &#123; return hasProperty(&apos;NEXUS_PASSWORD&apos;) ? NEXUS_PASSWORD : &quot;&quot;//密码 放置于 local.properties 不同步至 maven&#125;uploadArchives &#123; repositories.mavenDeployer &#123;// name = &apos;mavenCentralReleaseDeployer&apos; repository(url: &apos;http://maven.nnnn.com/content/repositories/releases/&apos;) &#123;//公司私服// repository(url:&apos;file:///E:/Library/nexus-2.12.0-01-bundle/sonatype-work/nexus/storage/releases&apos;)&#123; //本地仓库 authentication(userName: getRepositoryUsername(), password: getRepositoryPassword()) &#125; pom.project &#123; groupId project.PUBLISH_GROUP_ID artifactId project.PUBLISH_ARTIFACT_ID version project.PUBLISH_VERSION &#125; pom.packaging = &quot;aar&quot; &#125;&#125; 然后在目标项目的 root build.gradle 中引用本地仓库地址或者公司私服地址： 12345678910allprojects &#123; repositories &#123; jcenter() maven &#123; url &apos;http://maven.nnnn.com/content/repositories/releases&apos; &#125; &#125;&#125; 在目标项目的 build.gradle 中依赖： 12345dependencies &#123; compile(&quot;com.xxxx.yyyy:zzzz-sdk:0.0.7&quot;)&#125; 解决方案2 我们上传 SDK 依赖的 okhttp3 和 gson ，那么首先去下载这两个库对应版本的 jar，放置于 libs 目录下 okhttp 内部有使用 okio ，所以此处也需要引入进来。 在 liarbay 的 build.gradle 中添加 jar 的依赖 3.此时的 xxxxx-upload-sdk-v0.1.0.aar 结构如下： 已经将 gson、okhttp、okio、classes 都包含进来了。 build project 从 outputs/aar 路径中拿到 aar 放置于目标工程的 libs 目录下并配置使用 12345678910repositories &#123; flatDir &#123; dirs &apos;libs&apos; &#125;&#125;dependencies &#123; compile(name: &apos;xxxxx-upload-sdk-v0.1.0&apos;, ext:&apos;aar&apos;)&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"}]},{"title":"一口一口啃完Java中的24种设计模式---责任链模式","slug":"责任链模式","date":"2018-03-24T08:49:16.000Z","updated":"2018-03-25T14:58:19.725Z","comments":true,"path":"2018/03/24/责任链模式/","link":"","permalink":"http://zengfanyu.top/2018/03/24/责任链模式/","excerpt":"","text":"责任链模式总结 下面补充上图中的责任链模式 UML 图，责任链模式 Demo、 Android 源码中的责任链模式—事件分发。 责任链模式的UML图 Demo 在一家公司中，主任、副董事长、董事长、董事会都可以处理采购单，区别是每一个角色能够处理的采购单金额不同,采购订单需要一级一级处理，当已经被某一角色处理完了，就不会在交给下一个角色处理，写一个采购单处理系统。 针对上述需求，分析一下：当金额没有到达某一角色的处理的下限时，他是不负责处理的，当金额超过他负责处理的上限时，他就处理不了了，就会交给他的上级去处理，只有采购单金额刚好在他处理的范围之内，他才会去处理。那么这种结构就是一个典型的链式处理结构，并且无论订单多大，董事会总是可以处理的，所以这也是一个纯的责任链结构。 我们用责任链模式来处理。先上 UML 图： 根据 UML 图中的过程角色，代码如下： 抽象处理者1234567891011121314151617181920/** * 抽象处理者 * * @author: fanyuzeng on 2018/3/24 10:43 */public abstract class Approver &#123; /** * 后继处理者 */ public Approver mSuccessor; protected String mName; /** * 抽象处理方法 * * @param purchaseRequest 采购单实体类 */ public abstract void processPurchase(PurchaseRequest purchaseRequest);&#125; 具体处理者主任： 12345678910111213141516171819202122232425/** * 具体处理者:主任 &lt;p&gt; * 处理金额: [0,10k) * * @author: fanyuzeng on 2018/3/24 10:50 */public class Director extends Approver &#123; public Director(String name) &#123; mName = name; &#125; @Override public void processPurchase(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &gt;= 0 &amp;&amp; purchaseRequest.getAmount() &lt; 10000) &#123; System.out.println(\"我是主任\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount() + \",用于购买\" + purchaseRequest.getPurpose()+\",这笔采购单我来处理。\"); &#125; else &#123; System.out.println(\"我是主任\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount()+\"太大，我处理不了，交给下一级处理。\"); mSuccessor.processPurchase(purchaseRequest); &#125; &#125;&#125; 董事长： 123456789101112131415161718192021222324/** * 具体处理者：董事长 &lt;p&gt; * 处理金额: [10k,100k) * * @author: fanyuzeng on 2018/3/24 10:51 */public class Chairman extends Approver &#123; public Chairman(String name) &#123; mName = name; &#125; @Override public void processPurchase(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &gt;= 10000 &amp;&amp; purchaseRequest.getAmount() &lt; 100000) &#123; System.out.println(\"我是董事长\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount() + \",用于购买\" + purchaseRequest.getPurpose() + \",这笔采购单我来处理。\"); &#125; else &#123; System.out.println(\"我是董事长\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount() + \"太大，我处理不了，交给下一级处理。\"); mSuccessor.processPurchase(purchaseRequest); &#125; &#125;&#125; 董事会： 123456789101112131415161718192021/** * 具体处理者：董事会 &lt;p&gt; * 处理金额: [100k,+ infinity) * * @author: fanyuzeng on 2018/3/24 10:54 */public class BoardOfDirectors extends Approver &#123; public BoardOfDirectors(String name) &#123; mName = name; &#125; @Override public void processPurchase(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &gt;= 100000) &#123; System.out.println(\"我是董事长\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount() + \",用于购买\" + purchaseRequest.getPurpose() + \",这笔采购单我来处理。\"); &#125; &#125;&#125; 待处理需求实体类123456789101112131415161718192021222324252627/** * 采购单 Module * * @author: fanyuzeng on 2018/3/24 10:48 */public class PurchaseRequest &#123; /** * 采购金额 */ private long amount; /** * 采购编号 */ private int num; /** * 采购用途 */ private String purpose; public PurchaseRequest(long amount, int num, String purpose) &#123; this.amount = amount; this.num = num; this.purpose = purpose; &#125; //getter and setter 客户端类（测试类）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author: fanyuzeng on 2018/2/24 11:23 */public class Test &#123; private static ExecutorService mExecutorService = Executors.newSingleThreadExecutor(); public static void main(String[] args) &#123; final PurchaseRequest purchaseRequest1 = new PurchaseRequest(10000000, 12580, \"98K\"); final PurchaseRequest purchaseRequest2 = new PurchaseRequest(8000, 12581, \"M16\"); final PurchaseRequest purchaseRequest3 = new PurchaseRequest(70000, 12582, \"AUG\"); final Approver director = new Director(\"Jack\"); Approver chairmain = new Chairman(\"Tom\"); Approver boardOfDirectors = new BoardOfDirectors(\"NiubilityBoardOfDirectors\"); director.mSuccessor = chairmain; chairmain.mSuccessor = boardOfDirectors; mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest1 start-------------------\"); director.processPurchase(purchaseRequest1); System.out.println(\"---------purchaseRequest1 end---------------------\" + \"\\n\"); &#125; &#125;); mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest2 start-------------------\"); director.processPurchase(purchaseRequest2); System.out.println(\"---------purchaseRequest2 end---------------------\" + \"\\n\"); &#125; &#125;); mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest3 start-------------------\"); director.processPurchase(purchaseRequest3); System.out.println(\"---------purchaseRequest3 end---------------------\"); &#125; &#125;); &#125;&#125; 此时采购单处理流程：主任 jack —&gt; 董事长 tom —&gt; 董事会 出入内容如下： 123456789101112131415---------purchaseRequest1 start-------------------我是主任Jack,采购单编号：12580，金额：10000000太大，我处理不了，交给下一级处理。我是董事长Tom,采购单编号：12580，金额：10000000太大，我处理不了，交给下一级处理。我是董事长NiubilityBoardOfDirectors,采购单编号：12580，金额：10000000,用于购买98K,这笔采购单我来处理。---------purchaseRequest1 end------------------------------purchaseRequest2 start-------------------我是主任Jack,采购单编号：12581，金额：8000,用于购买M16,这笔采购单我来处理。---------purchaseRequest2 end------------------------------purchaseRequest3 start-------------------我是主任Jack,采购单编号：12582，金额：70000太大，我处理不了，交给下一级处理。我是董事长Tom,采购单编号：12582，金额：70000,用于购买AUG,这笔采购单我来处理。---------purchaseRequest3 end--------------------- 动态扩展假如公司采购单金额在 1k 范围以内的很多，主任又太忙了，所以他招了一个女实习 Rose 生来给他干，以后的采购单先给实习生去处理，如果她处理不了，在给主任。此时这个我们需要改变这个系统的处理链的逻辑。 首先增加女实习生的 Approve 1234567891011121314151617181920/** * @author: fanyuzeng on 2018/3/24 11:41 */public class Intern extends Approver &#123; public Intern(String name) &#123; mName = name; &#125; @Override public void processPurchase(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &gt;= 0 &amp;&amp; purchaseRequest.getAmount() &lt; 10000) &#123; System.out.println(\"我是实习生\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount() + \",用于购买\" + purchaseRequest.getPurpose()+\",这笔采购单我来处理。\"); &#125; else &#123; System.out.println(\"我是实习生\" + mName + \",采购单编号：\" + purchaseRequest.getNum() + \"，金额：\" + purchaseRequest.getAmount()+\"太大，我处理不了，交给下一级处理。\"); mSuccessor.processPurchase(purchaseRequest); &#125; &#125;&#125; 然后在客户端修改： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @author: fanyuzeng on 2018/2/24 11:23 */public class Test &#123; private static ExecutorService mExecutorService = Executors.newSingleThreadExecutor(); public static void main(String[] args) &#123; final PurchaseRequest purchaseRequest1 = new PurchaseRequest(10000000, 12580, \"98K\"); final PurchaseRequest purchaseRequest2 = new PurchaseRequest(8000, 12581, \"M16\"); final PurchaseRequest purchaseRequest3 = new PurchaseRequest(70000, 12582, \"AUG\"); final PurchaseRequest purchaseRequest4 = new PurchaseRequest(500, 12583, \"止痛药\"); final Approver intern = new Intern(\"Rose\"); Approver director = new Director(\"Jack\"); Approver chairmain = new Chairman(\"Tom\"); Approver boardOfDirectors = new BoardOfDirectors(\"NiubilityBoardOfDirectors\"); intern.mSuccessor = director; director.mSuccessor = chairmain; chairmain.mSuccessor = boardOfDirectors; mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest1 start-------------------\"); intern.processPurchase(purchaseRequest1); System.out.println(\"---------purchaseRequest1 end---------------------\" + \"\\n\"); &#125; &#125;); mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest2 start-------------------\"); intern.processPurchase(purchaseRequest2); System.out.println(\"---------purchaseRequest2 end---------------------\" + \"\\n\"); &#125; &#125;); mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest3 start-------------------\"); intern.processPurchase(purchaseRequest3); System.out.println(\"---------purchaseRequest3 end---------------------\"); &#125; &#125;); mExecutorService.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"---------purchaseRequest4 start-------------------\"); intern.processPurchase(purchaseRequest4); System.out.println(\"---------purchaseRequest4 end---------------------\"); &#125; &#125;); &#125;&#125; 在客户端重新修改采购单处理链： 增加 Intern 对象 Rouse 将所有采购统统交给 Rouse 处理，而不是之前的主任 Jack 此时采购单处理流程：实习生 Rose —&gt; 主任 jack —&gt; 董事长 tom —&gt; 董事会 此时的输出： 123456789101112131415161718192021---------purchaseRequest1 start-------------------我是实习生Rose,采购单编号：12580，金额：10000000太大，我处理不了，交给下一级处理。我是主任Jack,采购单编号：12580，金额：10000000太大，我处理不了，交给下一级处理。我是董事长Tom,采购单编号：12580，金额：10000000太大，我处理不了，交给下一级处理。我是董事长NiubilityBoardOfDirectors,采购单编号：12580，金额：10000000,用于购买98K,这笔采购单我来处理。---------purchaseRequest1 end------------------------------purchaseRequest2 start-------------------我是实习生Rose,采购单编号：12581，金额：8000,用于购买M16,这笔采购单我来处理。---------purchaseRequest2 end------------------------------purchaseRequest3 start-------------------我是实习生Rose,采购单编号：12582，金额：70000太大，我处理不了，交给下一级处理。我是主任Jack,采购单编号：12582，金额：70000太大，我处理不了，交给下一级处理。我是董事长Tom,采购单编号：12582，金额：70000,用于购买AUG,这笔采购单我来处理。---------purchaseRequest3 end------------------------------purchaseRequest4 start-------------------我是实习生Rose,采购单编号：12583，金额：500,用于购买止痛药,这笔采购单我来处理。---------purchaseRequest4 end--------------------- 这就是 纯的责任链模式的一个例子。至于不纯的责任链模式，在 Android 源码中有一个跟好的体现，就是 事件分发机制。 Android 源码中的责任链模式—事件分发机制 这里简述，不深入分析。 当用户触摸屏幕时，Android 系统会产生一个 MotionEvent 对象用于表示触摸事件，然后这个 MotionEvent 会从 ViewTree 的顶部从上而下的分发，经过 Windows —&gt; Activity —&gt; ViewGroup —&gt; View. ViewGroup 把 MotionEvent 不断的递归分发，查找可以消耗这个事件的 View （ViewGroup），然后被 onTouchEvent 方法所处理。 这个过程也是一个责任链的模式。 但是要注意的是：并且这是一个不纯的责任链模式，因为触摸事件 MotionEvent 可能没有任何一个 view 能够消耗它。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/tags/Design-Patterns/"}]},{"title":"Java 基础夯实 --- Java 对象的创建","slug":"JavaObjectConstruct","date":"2018-03-10T09:27:15.000Z","updated":"2018-03-11T07:39:23.566Z","comments":true,"path":"2018/03/10/JavaObjectConstruct/","link":"","permalink":"http://zengfanyu.top/2018/03/10/JavaObjectConstruct/","excerpt":"摘要：这篇博文总结一下 Java 当中实例化对象的方法和过程。并且涉及到多态特性在 Java 对象初始化过程中的表现","text":"摘要：这篇博文总结一下 Java 当中实例化对象的方法和过程。并且涉及到多态特性在 Java 对象初始化过程中的表现 [toc] Java 中创建对象的几种方法 通过构造函数 通过 Class 的 newInstace 方法（反射机制） 通过 Constructor 的 newInstance 方法（反射机制） 通过 clone 方法 通过序列化和反序列化机制 注意： Class 的 newInstance 方法只能通过反射调用对象的 public 的无惨构造函数，而 Constructor 的 newInstance 方法就强大得多，它不仅可以反射调用对象的带参构造方法，也可以调用其 private 构造方法。事实上Class的newInstance方法内部调用的也是Constructor的newInstance方法。 要想使用clone方法，我们就必须先实现Cloneable接口并实现其定义的clone方法,用clone方法创建对象的过程中并不会调用任何构造函数。 当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口 示例： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.Serializable;/** * @author: fanyuzeng * @date: 2018/3/10 10:39 */class Student implements Cloneable,Serializable &#123; private String mName; private int mAge; public Student(String name) &#123; mName = name; &#125; public Student() &#123; &#125; private Student(String name, int age) &#123; mName = name; mAge = age; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; public String printStudentInfo() &#123; return \"Student&#123;\" + \"mName='\" + mName + '\\'' + \", mAge=\" + mAge + '&#125;'; &#125;&#125; 注意三个构造方法的作用域以及参数。 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static void main(String[] args) &#123; try &#123; Utils.print(\"============1.调用构造方法函数创建对象=============\"); Student student1 = new Student(); Utils.println(\"student1:\" + student1); Utils.print(\"============2.调用Class类的newInstance方法，调用无参数的public的构造方法，创建对象=============\"); Student student2 = (Student) Class.forName(\"Student\").newInstance(); Utils.print(\"student2:\" + student2.printStudentInfo()); Student student22 = Student.class.newInstance(); Utils.println(\"student22:\" + student22.printStudentInfo()); Utils.print(\"============3.调用Constructor类的newInstance方法，调用带参数的public构造方法，创建对象=============\"); Constructor&lt;Student&gt; constructor = Student.class.getConstructor(String.class); Student student3 = constructor.newInstance(\"WalkerZeng\"); Utils.println(\"student3:\" + student3.printStudentInfo()); Utils.print(\"============4.调用Constructor类的newInstance方法，调用带参数的private构造方法，创建对象=============\"); Class&lt;?&gt; aStudent = Class.forName(\"Student\"); Constructor&lt;?&gt; declaredConstructor = aStudent.getDeclaredConstructor(String.class, int.class); declaredConstructor.setAccessible(true); Student student4 = (Student) declaredConstructor.newInstance(\"WalkerZeng\", 24); Utils.print(\"student4:\" + student4.printStudentInfo()); Utils.println(\"student4:\" + student4); Utils.print(\"============5.调用clone方法创建对象=============\"); Student student5 = (Student) student4.clone(); Utils.print(\"student5:\" + student5.printStudentInfo()); Utils.println(\"student5:\" + student5); Utils.print(\"============6.使用序列化机制创建对象=============\"); Constructor&lt;Student&gt; constructor1 = Student.class .getConstructor(String.class); Student student6 = constructor1.newInstance(\"WalkerWang\"); Utils.print(\"student6:\" + student6); Utils.print(\"student6:\" + student6.printStudentInfo()); //写对象 ObjectOutputStream output = new ObjectOutputStream( new FileOutputStream(\"student.bin\")); output.writeObject(student6); output.close(); //读对象 ObjectInputStream input = new ObjectInputStream(new FileInputStream( \"student.bin\")); Student student7 = (Student) input.readObject(); Utils.print(\"student7:\" + student7); Utils.print(\"student7:\" + student7.printStudentInfo()); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException | CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 输出情况： 123456789101112131415161718192021222324============1.调用构造方法函数创建对象=============student1:Student@140e19d ============2.调用Class类的newInstance方法，调用无参数的public的构造方法，创建对象=============student2:Student&#123;mName='null', mAge=0&#125;student22:Student&#123;mName='null', mAge=0&#125; ============3.调用Constructor类的newInstance方法，调用带参数的public构造方法，创建对象=============student3:Student&#123;mName='WalkerZeng', mAge=0&#125; ============4.调用Constructor类的newInstance方法，调用带参数的private构造方法，创建对象=============student4:Student&#123;mName='WalkerZeng', mAge=24&#125;student4:Student@17327b6 ============5.调用clone方法创建对象=============student5:Student&#123;mName='WalkerZeng', mAge=24&#125;student5:Student@14ae5a5 ============6.使用序列化机制创建对象=============student6:Student@131245astudent6:Student&#123;mName='WalkerWang', mAge=0&#125;student7:Student@1d6c5e0student7:Student&#123;mName='WalkerWang', mAge=0&#125; 简单说明几点： student4 是通过反射调用 Studet 带两个参数的 private 方法创建的。 student5 是通过 student4 clone 创建的，通过观察 student4 和 student5 两者的内存地址不同可知，student5 是一个新的对象。 student7 是通过 student6 反序列化创建的，同样观察两个对象的内存地址可知，student7 是一个新的对象。 Java 对象的创建过程流程如下图： 实例变量初始化与实例代码块初始化当申明一个对象的时候，可以同时对其进行赋值，这就是实例变量初始化，也可以使用代码块为其赋值。那么这些操作是在构造函数执行之前完成的。换言之，实例变量初始化和构造函数初始化的代码，实际上是被放在构造函数中，对超类构造函数调用代码之后，构造函数本身的代码之前的。 举个栗子： 1234567891011121314151617181920212223242526272829303132333435/** * @author: fanyuzeng * @date: 2018/3/10 11:45 */class Test1 &#123; private int i = 1; private int j = i + 1; public Test1(int var) &#123; //此处省略了 super() 超类的无参构造方法是可以省略不写出来的，但是有参构造方法必须写出 Utils.print(\"i=\" + i); Utils.print(\"j=\" + j); this.i = var; Utils.print(\"i=\" + i); Utils.print(\"j=\" + j); &#125; &#123; j += 4; &#125; public static void main(String[] args) &#123; Test1 test1 = new Test1(3); &#125;&#125;//output: i=1 j=6 i=3 j=6 根据上面标红的那句话，那么这段代码实际的执行顺序是： 12345678910111213141516171819202122232425/** * @author: fanyuzeng * @date: 2018/3/10 11:45 */class Test1 &#123; public Test1(int var) &#123; //此处省略了 super() 超类的无参构造方法是可以省略不写出来的，但是有参构造方法必须写出 private int i = 1; private int j = i + 1; &#123; j += 4; &#125; Utils.print(\"i=\" + i); Utils.print(\"j=\" + j); this.i = var; Utils.print(\"i=\" + i); Utils.print(\"j=\" + j); &#125; public static void main(String[] args) &#123; Test1 test1 = new Test1(3); &#125;&#125; 那么，这种在看上面的输出结果，就很显而易见了。这个例子也就验证了上面标红的结论 JVM先会给对象赋默认值上图中的第二步，JVM 给对象赋默认值，然后再按照代码的赋值情况，去给对象重新赋值。那么赋默认值这个过程到底是否存在呢？我们用代码来验证下： 1234567891011121314151617181920212223/** * @author: fanyuzeng * @date: 2018/3/10 11:57 */class Test2 &#123; private int j = getI(); private int i = 1; public Test2() &#123; i = 2; &#125; private int getI() &#123; Utils.print(\"getI() j=\"+j+\" i=\"+i); return i; &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); Utils.print(test2.j); &#125;&#125; 按照之前的结论，这段代码是可以等价成： 123456789101112131415161718192021222324252627/** * @author: fanyuzeng * @date: 2018/3/10 11:57 */class Test2 &#123; public Test2() &#123; private int j = getI(); private int i = 1; i = 2; &#125; private int getI() &#123; Utils.print(\"getI() j=\"+j+\" i=\"+i); return i; &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); Utils.print(test2.j); &#125;&#125;//output: getI() j=0 i=0 0 为什么会输出 0 ？ 分析一下，首先调用 Test2 的构造函数，那么就会去给 int 类型的 j 和 i 对象分配内存空间，并且赋默认值，int 类型的默认值是 0 。然后再按照代码的情况去给他们赋值，第 7 行是给 j 赋值的，这个值是 getI() 函数的返回值，那么来看看 getI() 函数，这个函数就是返回 i ，此时的 i 的值是 JVM 赋予的默认值，也就是 0 ，所以这么一来， 就是将 0 赋给 j。 所以这段代码是可以体现出 JVM 在申请内存空间的同时，是对变量进行了一个赋默认值的过程的。 构造函数初始化我们可以从上文知道，实例变量初始化与实例代码块初始化总是发生在构造函数初始化之前，那么我们下面着重看看构造函数初始化过程。众所周知，每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。在编译生成的字节码中，这些构造函数会被命名成 () 方法，参数列表与 Java 语言书写的构造函数的参数列表相同。 我们知道，Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。事实上，这一点是在构造函数中保证的：Java 强制要求 Object 对象( Object 是J ava 的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用,比如： 1234public class Test3 &#123;&#125; 另外有种情况， 当有重载构造函数时，我们经常会在一个构造函数中去调用另外一个构造函数。 1234567891011121314151617181920212223242526/** * @author: fanyuzeng * @date: 2018/3/10 12:21 */class Test3 &#123; int i; public Test3() &#123; //这里不是省略了 super() 而是根本就没有 this(0); &#125; public Test3(int i) &#123; //super() 这里省略了 this.i = i; &#125; public static void main(String[] args) &#123; Test3 test3 = new Test3(); Utils.print(\"test3.i=\" + test3.i); &#125;&#125; 对于这种情况， Java 只允许在 Test(int i) 中去调用超类的构造函数。 Java 做出这种限制，就是为了一个类在使用前，能够正确的被初始化。 小结一个类的创建过程，实际上是一个递归的过程，总结如下图： 递归的思想在 Android 中的事件分发机制以及 View 的绘制等过程中也有体现。拿事件分发来说，不同的是，事件分发是从上到下分发，然后从下到上递归，如下： 引用自： 图解 Android 事件分发机制 （作者：Kelin） 实例变量初始化、代码块初始化、构造函数初始化以及多态的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author: fanyuzeng * @date: 2018/3/10 13:03 */class Test4 &#123; static class Foo &#123; int i = 1; Foo() &#123; System.out.println(i); // -----------(1) int x = getValue(); System.out.println(x); // -----------(2) &#125; &#123; i = 2; &#125; protected int getValue() &#123; return i; &#125; &#125; //子类 static class Bar extends Foo &#123; int j = 1; Bar() &#123; j = 2; &#125; &#123; j = 3; &#125; @Override protected int getValue() &#123; return j; &#125; &#125; public static void main(String... args) &#123; Bar bar = new Bar(); System.out.println(bar.getValue()); // -----------(3) &#125;&#125; 根据上面的总结，Foo 和 Bar 的构造函数等价于： 123456789//Foo类构造函数的等价变换：Foo() &#123; i = 1; i = 2; System.out.println(i); int x = getValue(); System.out.println(x);&#125; 12345678//Bar类构造函数的等价变换Bar() &#123; Foo(); j = 1; j = 3; j = 2&#125; 这样程序就好看多了，我们一眼就可以观察出程序的输出结果。 在通过使用 Bar 类的构造方法 new 一个 Bar 类的实例时，首先会调用 Foo 类构造函数，因此(1)处输出是2，这从Foo类构造函数的等价变换中可以直接看出。 (2) 处输出是 0，为什么呢？因为在执行 Foo 的构造函数的过程中，由于 Bar 重载了 Foo 中的 getValue 方法，所以根据Java 的多态特性可以知道，其调用的 getValue 方法是被 Bar 重载的那个 getValue 方法。但由于这时 Bar 的构造函数还没有被执行，因此此时 j 的值还是默认值 0，因此 (2) 处输出是 0。 最后，在执行 (3) 处的代码时，由于 bar 对象已经创建完成，所以此时再访问 j 的值时，就得到了其初始化后的值 2，这一点可以从 Bar 类构造函数的等价变换中直接看出。","categories":[{"name":"Java","slug":"Java","permalink":"http://zengfanyu.top/categories/Java/"}],"tags":[{"name":"Java 基础夯实","slug":"Java-基础夯实","permalink":"http://zengfanyu.top/tags/Java-基础夯实/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （六） 背压策略","slug":"RxJava6","date":"2018-02-26T06:16:16.000Z","updated":"2018-02-28T13:57:25.190Z","comments":true,"path":"2018/02/26/RxJava6/","link":"","permalink":"http://zengfanyu.top/2018/02/26/RxJava6/","excerpt":"理解 RxJava2 中的被压策略","text":"理解 RxJava2 中的被压策略 文中措辞 被观察者 &lt;=&gt; 上游； 观察者 &lt;=&gt; 下游 是等价的。 宏观上解决流速不匹配的问题通过上一篇，我们知道，阻塞是因为上游发送事件的流速和下游接收处理事件的流速不匹配造成的（一般是 上游流速 &gt; 下游流速），那么要解决这个问题，「要么减少上游发送事件的数量」，「要么减少上游发送事件的频率」，但是我们又不能手动实现这一点，因为我们不知道上游道理应该发送多少事件和发送事件的速度，并且也不知道下游处理消耗事件的能力，所以简单的通过控制上游发送事件的数量和速度是不可行的。 那么我们这里抛开代码实现，从宏观上谈一下如何解决这个问题。 要解决阻塞，控制流速，需要上下游协同合作。比如说：下游告诉上游，我可以处理 20 个事件（响应式拉取），那么上游就发送 20 个事件（反馈控制），当下游处理完了之后，下游又告诉上游，我还可以再处理 30 个事件，那么上游又发送 30 个事件过来，我们知道，异步订阅，上游发送的事件是放在一个 缓存池 中的， 而下游直接从缓存池中去取，那么如果上游发送的事件个数大于下游的处理个数，缓存池就会有溢出的风险，所以在这里也得有一个方法来解决。 这种方法就类似于 Universal Image Loader 中提供的各种缓存策略，内存缓存的大小有限，所以用内存做缓存时要处理好当接近内存大小临界值时，如何丢弃现有的缓存，存入新的缓存？是最近最少使用的丢弃？还是暂用空间最小的丢弃？还是最先缓存的丢弃？这里就涉及到各种策略。RxJava2.0 中也提供了好几种策略，后面详细说。 通过上面描述的方案，就可以有效的解决上下游流速不匹配导致的阻塞问题。 总的来说： 要尽量避免出现流速不匹配。 当已经出现流速不匹配了，应该采取策略。 下面谈谈 RxJava2 中的背压策略。 背压策略定义一种控制事件流速的方法。 作用在 异步事件订阅 中，控制事件发送的速度和接收的速度。 解决的问题解决了 异步订阅中 因被观察者发送事件速度 与 观察者接收事件速度不匹配（一般是前者 快于 后者），从而导致观察者无法及时响应 / 处理所有被观察者发送事件的问题 原理 示意图： 与 Rxjava1 中被观察者的旧实现 Observable 相比： 图中出现了一个新的类， Flowable ，它就是 RxJava2.0 中被观察者的一种新的实现，同时也是背压策略的承载者，下面就来看看如何使用它。 背压策略的实现：FlowableFlowable 基本使用123456789101112131415161718192021222324252627282930313233343536373839Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; //1.ObservableOnSubscribe -&gt; FlowableOnSubscribe @Override //2.ObservableEmitter -&gt; FlowableEmitter public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"emitter 1\"); e.onNext(1); LogUtil.d(TAG, \"emitter 2\"); e.onNext(2); LogUtil.d(TAG, \"emitter 3\"); e.onNext(3); LogUtil.d(TAG, \"emitter complete\"); e.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR) //3.背压策略 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override //4.onSubscribe(Disposable d) -&gt; onSubscribe(Subscription s) public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); s.request(Long.MAX_VALUE);//5. 向上游请求的元素，响应式拉取 &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 1234567891002-25 10:09:11.591 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onSubscribe02-25 10:09:11.591 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 102-25 10:09:11.591 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=102-25 10:09:11.591 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 202-25 10:09:11.591 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=202-25 10:09:11.591 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 302-25 10:09:11.592 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=302-25 10:09:11.592 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter complete02-25 10:09:11.592 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onComplete 代码中已经注释出了 Flowable 相对于 Observable 使用的不同之处，这里总结一下 ObservableOnSubscribe -&gt; FlowableOnSubscribe ObservableEmitter -&gt; FlowableEmitter 背压策略 onSubscribe(Disposable d) -&gt; onSubscribe(Subscription s) s.request(Long.MAX_VALUE);// 向被观察者请求的元素，响应式拉取 下面针对这几点不同做讲解。 Subscription.request 控制观察者的接收速度我们从 request 方法开始看看 Flowable 的使用。 现在将19行的 s.request(Long.MAX_VALUE) 删掉，在看日志 123456789101112131415161718192021222324252627282902-25 10:03:53.949 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onSubscribe02-25 10:03:53.949 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 102-25 10:03:53.950 22450-22450/com.rengwuxian.rxjavasamples W/===RxJavaSample==: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411) at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377) at com.rengwuxian.rxjavasamples.Test$2$override.subscribe(Test.java:91) at com.rengwuxian.rxjavasamples.Test$2$override.access$dispatch(Test.java) at com.rengwuxian.rxjavasamples.Test$2.subscribe(Test.java:0) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) at io.reactivex.Flowable.subscribe(Flowable.java:12970) at io.reactivex.Flowable.subscribe(Flowable.java:12920) at com.rengwuxian.rxjavasamples.Test$override.onClick(Test.java:100) at com.rengwuxian.rxjavasamples.Test$override.access$dispatch(Test.java) at com.rengwuxian.rxjavasamples.Test.onClick(Test.java:0) at com.rengwuxian.rxjavasamples.Test_ViewBinding$1.doClick(Test_ViewBinding.java:37) at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22) at android.view.View.performClick(View.java:5619) at android.view.View$PerformClick.run(View.java:22295) at android.os.Handler.handleCallback(Handler.java:754) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:163) at android.app.ActivityThread.main(ActivityThread.java:6342) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:880) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)02-25 10:03:53.950 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 202-25 10:03:53.950 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 302-25 10:03:53.950 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter complete 在上游发送了第一个事件之后，下游就抛出了 MissingBackpressureException 异常，但是根据上一篇的内容，这里是同步订阅关系，上游要等下游处理完事件之后才回去发送下一个事件，所以应该不会阻塞，所以这里不应该会抛出异常啊！但事实还是抛出了异常，为什么呢？带着这个疑问，我们仍然将 19 行 s.request(Long.MAX_VALUE) 删掉并且将上下游放到不同的线程中再看看 1234567891011121314151617181920212223242526272829303132333435363738394041Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"emitter 1\"); e.onNext(1); LogUtil.d(TAG, \"emitter 2\"); e.onNext(2); LogUtil.d(TAG, \"emitter 3\"); e.onNext(3); LogUtil.d(TAG, \"emitter complete\"); e.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribeOn(Schedulers.io())//上游io线程 .observeOn(AndroidSchedulers.mainThread())//下游主线程 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 12345602-25 10:13:13.942 22450-22450/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onSubscribe02-25 10:13:13.943 22450-29562/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 102-25 10:13:13.944 22450-29562/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 202-25 10:13:13.944 22450-29562/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter 302-25 10:13:13.944 22450-29562/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== emitter complete 只能看到上游发送的事件，但是下游并没有获取到事件，这又是为什么？ 这是因为 Flowable 采用的是一种响应式拉取的方式，上游需要根据下游的能力去发送事件。而第 19 行的 s.request(Long.MAX_VALUE) 就相当于下游告知上游其本身的接收能力。 那么现在就可以解释上面代码的现象了。 当同步的订阅时，上游发送出一个事件后就抛出 MissingBackpressureException 异常，这是因为下游没有调用 request 方法，也就是说下游没有告知上游其处理事件的能力，那么上游就认为下游没有处理事件的能力，又因为是同步的，上游是需要等待下游处理完事件之后才发送下一个事件，现在下游没有处理事件的能力，那上游不能一直等着吧？所以就抛出异常咯。 当异步订阅的时候，会存在一个缓存池，上游发送的事件都放到这个缓存池里面去了，然后下游根据其能力 （request 方法的参数） 从缓存池里取出事件。然而此时并没有调用 request 方法，所以我们只看得到上游发送事件的日志，看不到下游响应事件的日志。但是一旦下游调用 request 时，就会从缓存池中去取出事件，是不是这样呢? 看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@OnClick(&#123;R.id.id_btn_request, R.id.id_btn_emitter&#125;) void onClick(View view) &#123; if (view.getId() == R.id.id_btn_emitter) &#123; LogUtil.d(TAG,\"emitter event\"); Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"emitter 1\"); e.onNext(1); LogUtil.d(TAG, \"emitter 2\"); e.onNext(2); LogUtil.d(TAG, \"emitter 3\"); e.onNext(3); LogUtil.d(TAG, \"emitter complete\"); e.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); mSubscription=s; &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); &#125; else if (view.getId() == R.id.id_btn_request) &#123; if (mSubscription != null) &#123; LogUtil.d(TAG,\"request invoked\"); mSubscription.request(1); &#125; else &#123; LogUtil.d(TAG, \"mSubscription is null\"); &#125; &#125; &#125; 可以看到，这里我们设置了两个按钮，当点击 btnEmitter 时会发送事件，并且在 onSubscribe 回调中将 Subscription 保存起来，然后当点击 btnRequest 按钮时，会调用 mSubscription.request(1)。这里我们点击 btnEmitter 一下，然后点击 btnRequest 3 下，看看日志： ok，验证了，确实是这样。 之前我们说到，上游会将事件发送到缓存池里，然后下游根据其能力从缓存池中取出事件，那么这个缓存池有多大呢？ 128 ！从上游发送 128 个事件和 129 个事件，分别观察日志即可证明，这里就不在写出代码。 到这里，下游已经可以通过 request 控制处理事件的能力了，但是上游还得获取这一信息呀，上游根据这一信息来控制其本身发送事件的速度，怎么获取呢？ FlowableEmitter.requested 控制被观察者发送事件的速度FlowableEmitter 的 requested 方法的返回值就是当前线程中，下游 subscription 的 request(n) 的 n 值，那么很显然，这里就分为同步订阅关系和异步订阅关系。 同步订阅情况下 看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 调用emitter.requested()获取当前观察者需要接收的事件数量 long n = emitter.requested(); Log.d(TAG, \"观察者可接收事件\" + n); // 根据emitter.requested()的值，即当前观察者需要接收的事件数量来发送事件 for (int i = 0; i &lt; n; i++) &#123; Log.d(TAG, \"发送了事件\" + i); emitter.onNext(i); &#125; &#125; &#125;, BackpressureStrategy.ERROR) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); // 设置观察者每次能接受10个事件 s.request(10); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 123456789101112131415161718192021222302-26 10:45:10.844 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: onSubscribe02-26 10:45:10.845 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 观察者可接收事件1002-26 10:45:10.845 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件002-26 10:45:10.845 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件002-26 10:45:10.845 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件102-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件102-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件202-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件202-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件302-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件302-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件402-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件402-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件502-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件502-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件602-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件602-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件702-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件702-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件802-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件802-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件902-26 10:45:10.846 23613-23613/com.rengwuxian.rxjavasamples D/==Test==: 接收到了事件9 并且在同步订阅当中使用 requested 时，有三个特性需要注意。 1. 可叠加性：下游可以连续调用 request，上游会进行叠加。 12345678910111213141516171819202122232425262728293031323334353637Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; long requested = e.requested(); LogUtil.d(TAG, \"subscribe requested=\" + requested); &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); s.request(10); s.request(20); s.request(30); &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 2. 实时更新性：每次发送事件后，emitter.requested() 会实时更新观察者能接受的事件 仅计算 onNext 事件，onComplete onError事件不算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; long requested = e.requested(); LogUtil.d(TAG, \"没有发送事件前， requested=\" + requested); e.onNext(1); requested = e.requested(); LogUtil.d(TAG, \"发送第一个事件之后， requested=\" + requested); e.onNext(2); requested = e.requested(); LogUtil.d(TAG, \"发送第二个事件之后， requested=\" + requested); e.onNext(3); requested = e.requested(); LogUtil.d(TAG, \"发送第三个事件之后， requested=\" + requested); e.onNext(4); requested = e.requested(); LogUtil.d(TAG, \"发送第四个事件之后， requested=\" + requested); e.onNext(5); requested = e.requested(); LogUtil.d(TAG, \"发送第五个事件之后， requested=\" + requested); &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); s.request(10); &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 3. 异常 当 FlowableEmitter.requested() 减到 0 时，则代表观察者已经不可接收事件，此时被观察者若继续发送事件，则会抛出MissingBackpressureException 异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; long requested = e.requested(); LogUtil.d(TAG, \"没有发送事件前， requested=\" + requested); e.onNext(1); requested = e.requested(); LogUtil.d(TAG, \"发送第一个事件之后， requested=\" + requested); e.onNext(2); requested = e.requested(); LogUtil.d(TAG, \"发送第二个事件之后， requested=\" + requested); e.onNext(3); requested = e.requested(); LogUtil.d(TAG, \"发送第三个事件之后， requested=\" + requested); e.onNext(4); requested = e.requested(); LogUtil.d(TAG, \"发送第四个事件之后， requested=\" + requested); &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); 这里下游只能处理 3 个事件，但是上游却发出了 4 个，那么看看发出第四个事件时，会发生什么情况： 抛出异常。 额外的一点，当下游没有调用 request 方法时，此时上游 requested 的返回值为 0 。 异步订阅情况下 123456789101112131415161718192021222324252627282930313233343536Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; long requested = e.requested(); LogUtil.d(TAG, \"没有发送事件前， requested=\" + requested); &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); s.request(3); &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 这里我们可以看到，下游调用 request 表明自己处理事件的能力为 3 ，但是上游 requested 方法返回的值仍然是 128； 所以，当上下游二者处于不同线程，上游无法通过 FlowableEmitter.requested() 知道下游自身接收事件能力，即 上游不能根据 下游自身接收事件的能力 控制发送事件的速度。 而在异步订阅关系中，反向控制的原理是：通过 RxJava 内部固定调用被观察者线程中的 request(n) 从而 反向控制被观察者的发送事件速度. 那么什么时候在 RxJava 内部调用 request(n)，并且 n 等于多少呢？ 看下图： 究竟是不是这样呢，还是要上代码来验证： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Flowable //Observable --&gt; Flowable .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"观察者可接收事件数量 = \" + e.requested()); boolean flag; //设置标记位控制 // 被观察者一共需要发送500个事件 for (int i = 1; i &lt; 501; i++) &#123; flag = false; // 若requested() == 0则不发送 while (e.requested() == 0) &#123; if (!flag) &#123; Log.d(TAG, \"不再发送\"); flag = true; &#125; &#125; // requested() ≠ 0 才发送 e.onNext(i); Log.d(TAG, \"发送了事件\" + i + \"，观察者可接收事件数量 = \" + e.requested()); &#125; &#125; &#125;, BackpressureStrategy.ERROR) //策略 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; LogUtil.d(TAG, \"onSubscribe\"); mSubscription = s; &#125; @Override public void onNext(Integer integer) &#123; LogUtil.d(TAG, \"onNext integer=\" + integer); &#125; @Override public void onError(Throwable t) &#123; LogUtil.w(TAG, t); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"onComplete\"); &#125; &#125;);@OnClick(R.id.id_btn_request)void onClick(View view) &#123; mSubscription.request(48);&#125; 程序启动： 12345678910111202-25 16:38:53.177 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onSubscribe02-25 16:38:53.179 16487-16512/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== 观察者可接收事件数量 = 12802-25 16:38:53.180 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件1，观察者可接收事件数量 = 12702-25 16:38:53.180 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件2，观察者可接收事件数量 = 12602-25 16:38:53.180 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件3，观察者可接收事件数量 = 12502-25 16:38:53.180 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件4，观察者可接收事件数量 = 124....02-25 16:38:53.186 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件126，观察者可接收事件数量 = 202-25 16:38:53.186 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件127，观察者可接收事件数量 = 102-25 16:38:53.186 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件128，观察者可接收事件数量 = 002-25 16:38:53.186 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 不再发送 上游发送事件 1~128，下游没有接收任何事件 第一次点击按钮调用 request(48): 123456789102-25 16:39:04.089 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=102-25 16:39:04.089 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=202-25 16:39:04.089 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=302-25 16:39:04.089 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=402-25 16:39:04.089 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=5...02-25 16:39:04.091 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=4602-25 16:39:04.091 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=4702-25 16:39:04.091 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=48 从缓存池中取出 48 个事件(1~48)，且上游没有重新发送事件，此时下游观察者接收事件 n=48 第二次点击按钮调用 request(48): 12345678910111213141516171802-25 16:39:25.661 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=4902-25 16:39:25.661 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=5002-25 16:39:25.661 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=5102-25 16:39:25.661 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=52...02-25 16:39:25.663 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=9402-25 16:39:25.663 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=9502-25 16:39:25.663 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=9602-25 16:39:25.663 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件129，观察者可接收事件数量 = 9502-25 16:39:25.663 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件130，观察者可接收事件数量 = 9402-25 16:39:25.663 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件131，观察者可接收事件数量 = 9302-25 16:39:25.663 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件132，观察者可接收事件数量 = 92...02-25 16:39:25.667 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件222，观察者可接收事件数量 = 202-25 16:39:25.667 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件223，观察者可接收事件数量 = 102-25 16:39:25.667 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件224，观察者可接收事件数量 = 002-25 16:39:25.667 16487-16512/com.rengwuxian.rxjavasamples D/==Test==: 不再发送 从缓存池中取出 48 个事件(49~96)，此时下游观察者接收事件 n=96，满足条件了，所以上游接着发送 96 个事件（129~224） 第三次点击按钮调用 request(48): 1234567802-25 16:39:55.555 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=9702-25 16:39:55.555 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=9802-25 16:39:55.555 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=99...02-25 16:39:55.557 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=14202-25 16:39:55.557 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=14302-25 16:39:55.557 16487-16487/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=144 从缓存池中取出 48 个事件(97~144)，此时下游观察者接收事件 n=48. 第四次点击按钮调用 request(48): 1234567891011121314151602-25 17:01:33.844 25959-25959/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=14502-25 17:01:33.845 25959-25959/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=14602-25 17:01:33.845 25959-25959/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=147...02-25 17:01:33.846 25959-25959/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=19002-25 17:01:33.846 25959-25959/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=19102-25 17:01:33.846 25959-25959/com.rengwuxian.rxjavasamples D/===RxJavaSample==: ==Test== onNext integer=19202-25 17:01:33.846 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件225，观察者可接收事件数量 = 9502-25 17:01:33.846 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件226，观察者可接收事件数量 = 9402-25 17:01:33.846 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件227，观察者可接收事件数量 = 93...02-25 17:01:33.850 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件318，观察者可接收事件数量 = 202-25 17:01:33.850 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件319，观察者可接收事件数量 = 102-25 17:01:33.850 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件320，观察者可接收事件数量 = 002-25 17:01:33.850 25959-26028/com.rengwuxian.rxjavasamples D/==Test==: 不再发送 从缓存池中取出 48 个事件(145~192)，此时下游观察者接收事件 n=96，满足条件了，所以上游接着发送 96 个事件（225~320） 这个情况和第二次点击按钮情况一直。 到这里就可以证明上面图片的正确性了。 到这里，避免上下游流速不匹配的方法就讲完了，下游响应式拉取，上游根据下游的能力控制发送速度。但是万一流速已经不匹配了呢？接下来就是解决这个问题的。 BackpressureStrategy 解决流速已经不匹配的问题看看源码 1234567891011121314151617181920212223242526272829/** * Represents the options for applying backpressure to a source sequence. */public enum BackpressureStrategy &#123; /** * OnNext events are written without any buffering or dropping. * Downstream has to deal with any overflow. * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators. */ MISSING, /** * Signals a MissingBackpressureException in case the downstream can't keep up. */ ERROR, /** * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it. */ BUFFER, /** * Drops the most recent onNext value if the downstream can't keep up. */ DROP, /** * Keeps only the latest onNext value, overwriting any previous value if the * downstream can't keep up. */ LATEST&#125; 根据注释，应该就可以很好的理解这几种策略了： MISSING：不丢弃不缓存的策略，给出友好提示 queue is full ？ ERROR：直接抛出 MissingBackpressureException 异常。 BUFFER：缓冲所有的 onNext 事件，直到下游消费它。就是相当于无限大的缓冲池。 DROP：当下游消费不了事件时，将事件直接丢弃 LATEST：当下游消费不了事件时，只向下游发送最近的事件 一个一个的展示。 BUFFER 策略：使用大小不受限制的缓存池 12345678910111213141516171819202122232425262728293031323334Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; i &lt; 500; i++) &#123; Log.d(TAG, \"emit \" + i); emitter.onNext(i); &#125; &#125;&#125;, BackpressureStrategy.BUFFER) //注意这里用的策略 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"onNext: \" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 12345678902-25 17:40:47.655 18477-18477/com.rengwuxian.rxjavasamples D/==Test==: onSubscribe02-25 17:40:47.658 18477-18501/com.rengwuxian.rxjavasamples D/==Test==: emit 002-25 17:40:47.658 18477-18501/com.rengwuxian.rxjavasamples D/==Test==: emit 102-25 17:40:47.658 18477-18501/com.rengwuxian.rxjavasamples D/==Test==: emit 2...02-25 17:40:47.685 18477-18501/com.rengwuxian.rxjavasamples D/==Test==: emit 49702-25 17:40:47.685 18477-18501/com.rengwuxian.rxjavasamples D/==Test==: emit 49802-25 17:40:47.685 18477-18501/com.rengwuxian.rxjavasamples D/==Test==: emit 499 使用无限大缓存池的 Flowable 表现出来的效果好像和 Observable 是一样的。但是单纯这种使用 Flowable 也需要注意 OOM 的情况，比如下面这个例子： 12345678910111213141516171819202122232425262728293031323334Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; Log.d(TAG, \"emit \" + i); emitter.onNext(i); &#125; &#125;&#125;, BackpressureStrategy.BUFFER) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"onNext: \" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 日志和内存情况： 这里可以看到，即使使用容量无限大的缓存池，对内存的压力也是特别大的，只是和使用 Observable 比较起来，这里的增长速度是比较慢的。这也看出 FLowable 相比 Observable, 在性能方面有些不足, 毕竟FLowable内部为了实现响应式拉取做了更多的操作, 性能有所丢失也是在所难免, 因此单单只是说因为 FLowable 是新兴产物就盲目的使用也是不对的, 也要具体分场景. DROP 策略：丢弃超过缓存区大小(128)的事件。比如发送 150 个事件，仅保存 1-128 个事件，129-150 个事件丢弃 12345678910111213141516171819202122232425262728293031323334353637Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 发送150个事件 for (int i = 0;i&lt; 150; i++) &#123; Log.d(TAG, \"发送了事件\" + i); emitter.onNext(i); &#125; emitter.onComplete(); &#125;&#125;, BackpressureStrategy.DROP) // 设置背压模式 = BackpressureStrategy.DROP .subscribeOn(Schedulers.io()) // 设置被观察者在io线程中进行 .observeOn(AndroidSchedulers.mainThread()) // 设置观察者在主线程中进行 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); mSubscription = s; // 通过按钮进行接收事件 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 看看日志： 下游只能从缓存池中取出前 128 个事件，后面再去取事件时，已经取不出来了，因为后面的时间已经被丢弃了，缓存池里没有其他的事件。 LATEST 策略：只保存最新(最后)的事件，其他的事件丢弃 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@OnClick(&#123;R.id.id_btn_request, R.id.id_btn_emitter&#125;) void onClick(View view) &#123; if (view.getId() == R.id.id_btn_request &amp;&amp; mSubscription != null) &#123; LogUtils.d(TAG,\"Request button clicked\"); mSubscription.request(128); &#125; if (view.getId() == R.id.id_btn_emitter) &#123; LogUtils.d(TAG,\"Emitter button clicked\"); Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // 发送150个事件 for (int i = 0; i &lt; 150; i++) &#123; Log.d(TAG, \"发送了事件\" + i); emitter.onNext(i); &#125; emitter.onComplete(); &#125; &#125;, BackpressureStrategy.LATEST) // 设置背压模式 = BackpressureStrategy.DROP .subscribeOn(Schedulers.io()) // 设置被观察者在io线程中进行 .observeOn(AndroidSchedulers.mainThread()) // 设置观察者在主线程中进行 .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); mSubscription = s; // 通过按钮进行接收事件 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, \"接收到了事件\" + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 下游第一次接受到了前 128 个事件， 第二次接收到了 第 150 个事件，其他事件都没有收到。 这里就体现出 DROP 和 LATEST 的区别了。 MISSING 策略和 ERROR 的体现方式类似，只是给出友好提示 这里就不贴出代码只贴出日志： 12345678910111213141516171819202122232402-26 11:23:20.493 13037-13037/com.rengwuxian.rxjavasamples D/==Test==: onSubscribe02-26 11:23:20.495 13037-13060/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件002-26 11:23:20.496 13037-13060/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件1...02-26 11:23:20.501 13037-13060/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件12702-26 11:23:20.501 13037-13060/com.rengwuxian.rxjavasamples D/==Test==: 发送了事件12802-26 11:23:20.521 13037-13037/com.rengwuxian.rxjavasamples W/==Test==: onError: io.reactivex.exceptions.MissingBackpressureException: Queue is full?! at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.onNext(FlowableObserveOn.java:114) at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.onNext(FlowableSubscribeOn.java:97) at io.reactivex.internal.operators.flowable.FlowableCreate$MissingEmitter.onNext(FlowableCreate.java:338) at com.rengwuxian.rxjavasamples.Test$2.subscribe(Test.java:52) at io.reactivex.internal.operators.flowable.FlowableCreate.subscribeActual(FlowableCreate.java:72) at io.reactivex.Flowable.subscribe(Flowable.java:12970) at io.reactivex.Flowable.subscribe(Flowable.java:12917) at io.reactivex.internal.operators.flowable.FlowableSubscribeOn$SubscribeOnSubscriber.run(FlowableSubscribeOn.java:82) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:59) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:760) 当 Flowable 不是我们自己创建时上面例子中红的 Flowable 都是我们自己手动创建的，但是存在部分情况 Flowable 不是右我们自己创建的，比如使用 interval 操作符创建 Flowable ， 那么这种情况下当流速不匹配时如何选择背压策略呢？ intetval 操作符：Interval运算符返回一个 Observable / Flowable，它发出一个升序整数(Long 类型)的无限序列，并在发射之间选择一个固定的时间间隔，默认运行在一个新的线程上。 看代码： 123456789101112131415161718192021222324252627282930Flowable.interval(1, TimeUnit.MILLISECONDS) // 1秒发送1000个事件 .observeOn(Schedulers.newThread()) // 观察者同样工作在一个新开线程中 .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); mSubscription = s; s.request(Long.MAX_VALUE); //默认可以接收Long.MAX_VALUE个事件 &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"onNext: \" + aLong); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 12345678910111202-26 11:59:29.497 3959-3959/com.rengwuxian.rxjavasamples D/==Test==: onSubscribe02-26 11:59:29.501 3959-4126/com.rengwuxian.rxjavasamples D/==Test==: onNext: 002-26 11:59:30.508 3959-4126/com.rengwuxian.rxjavasamples W/==Test==: onError: io.reactivex.exceptions.MissingBackpressureException: Can't deliver value 128 due to lack of requests at io.reactivex.internal.operators.flowable.FlowableInterval$IntervalSubscriber.run(FlowableInterval.java:87) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:428) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:278) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:273) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:760) 这是没有采取背压策略，缓冲区马上被充满，然后抛出 MissingBackpressureException 。 如何解决？ 上面抛出的异常是因为 RxJava2.0 在内部已经封装好了策略，默认使用的是 ERROR 策略，还有其他的三种： onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest() 使用 DROP 策略看看： 12345678910111213141516171819202122232425262728293031Flowable.interval(1, TimeUnit.MILLISECONDS) // 1秒发送1000个事件 .onBackpressureDrop()// 采用 DROP 策略 .observeOn(Schedulers.newThread()) // 观察者同样工作在一个新开线程中 .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, \"onSubscribe\"); mSubscription = s; s.request(Long.MAX_VALUE); //默认可以接收Long.MAX_VALUE个事件 &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, \"onNext: \" + aLong); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, \"onError: \", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, \"onComplete\"); &#125; &#125;); 日志： 注意 127 之后的序列，符合 DROP 的策略模式。 其他两种就不做演示了。 总结","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"一口一口啃完Java中的24种设计模式---适配器模式","slug":"适配器模式","date":"2018-02-24T06:36:16.000Z","updated":"2018-02-28T14:01:55.171Z","comments":true,"path":"2018/02/24/适配器模式/","link":"","permalink":"http://zengfanyu.top/2018/02/24/适配器模式/","excerpt":"","text":"&gt; 问题引入日常使用的笔记本的工作电压为 20v ，但是我国家庭用电的电压为 220V ，为了让笔记本电脑可以在国内所有的插座上充电使用，这里就会引入一个电源适配器，如图： 有了这个电源适配器之后，生活用电和笔记本电脑用电的电压就可以兼容。这里体现出来的设计模式就是 适配器模式。 对象适配器模式概述与笔记本电脑的电源适配器类似，在适配器模式中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象叫做适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。 【注：在适配器模式定义中所提及的 接口 是指广义的接口，它可以表示一个方法或者方法的集合。】 在适配器模式中，我们通过新增一个适配器类来解决接口不兼容的问题，使原本没有任何关系的类可以协同使用。 适配器模式有两种实现方式，这里先说其中一种，对象适配器模式，UML 图： 在对象适配器模式结构图中包含如下几个角色： Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 根据对象适配器模式结构图，在对象适配器中，客户端需要调用 request() 方法，而适配者类 Adaptee 没有该方法，但是它所提供的 specificRequest() 方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类 Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的 request() 方法中调用适配者的 specificRequest() 方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。 没有源码的算法库的适配器解决方案问题描述 背景：某公司之前开发过一个算法库，其中包括常用的算法，例如查找算法、排序算法等，在进行各类软件开发时经常会用到这个算法库。在为某学校开发教务管理系统时，开发人员发现需要对学生成绩进行排序和查找，该系统的设计人员已经开发了一个成绩操作接口 ScoreOperation，在该接口中声明了排序方法 sort(int[]) 和查找方法 search(int[], int)，为了提高排序和查找的效率，开发人员决定重用算法库中的快速排序算法类 QuickSort 和二分查找算法类 BinarySearch，其中 QuickSort 的 quickSort(int[]) 方法实现了快速排序，BinarySearch 的 binarySearch (int[], int) 方法实现了二分查找。 但由于某些原因，开发人员现在找不到该算法库的源码，不能通过复制粘贴的方式去实现 ScoreOperation 中的方法，并且部分开发人员已经针对 ScoreOperation 的接口进行了编程，如果再要求对该接口进行修改或要求大家直接使用 QuickSort 类和 BinarySearch 类将导致大量代码需要修改。 现在的问题就是：如何在既不修改现有接口又不需要任何算法库代码的基础上能够实现算法库的重用？ 因为 ScoreOperation 接口已经确定，并且基于该接口已经进行了后续的开发了，所以这个接口肯定是不能修改的，而算法库已经引用到各类软件中，修改算法库的代价太大也没有必要，这是就要可以引入一个适配器 Adapter， 将算法库的接口适配成 ScoreOperation 的接口。 UML 图结合上述对适配器模式的讲解，这个问题很符合适配器模式可以解决范围，UML 结构图如下： 编码实现target123456789101112131415161718192021222324/** * 成绩操作接口 * * @author: fanyuzeng on 2018/2/24 11:14 */public interface ScoreOperation &#123; /** * 对成绩进行排序 * * @param array 成绩数组 * @return 排序过后的成绩数组 */ int[] sort(int[] array); /** * 查找某一特定成绩 * * @param array 成绩数组 * @param key 特定成绩 * @return 若成绩数据中存在该特定成绩，则返回该特定成绩在成绩数组中的索引，否则返回 -1 */ int search(int[] array, int key);&#125; adaptee12345678910111213141516171819202122232425262728293031323334353637383940/** * 快速排序工具类 * * @author: fanyuzeng on 2018/2/24 11:18 */public class QuickSort &#123; public int[] quickSort(int array[]) &#123; sort(array, 0, array.length - 1); return array; &#125; private void sort(int array[], int p, int r) &#123; int q = 0; if (p &lt; r) &#123; q = partition(array, p, r); sort(array, p, q - 1); sort(array, q + 1, r); &#125; &#125; private int partition(int[] a, int p, int r) &#123; int x = a[r]; int j = p - 1; for (int i = p; i &lt;= r - 1; i++) &#123; if (a[i] &lt;= x) &#123; j++; swap(a, j, i); &#125; &#125; swap(a, j + 1, r); return j + 1; &#125; private void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125;&#125; 123456789101112131415161718192021222324/** * 二分查找工具类 * * @author: fanyuzeng on 2018/2/24 11:18 */public class BinarySearch &#123; public int binarySearch(int array[], int key) &#123; int low = 0; int high = array.length - 1; while (low &lt;= high) &#123; int mid = (low + high) / 2; int midVal = array[mid]; if (midVal &lt; key) &#123; low = mid + 1; &#125; else if (midVal &gt; key) &#123; high = mid - 1; &#125; else &#123; return mid; //找到元素返回索引 &#125; &#125; return -1; //未找到元素返回-1 &#125;&#125; adapter123456789101112131415161718192021222324252627/** * @author: fanyuzeng on 2018/2/24 11:22 */public class OperationAdapter implements ScoreOperation &#123; //适配者 private BinarySearch mBinarySearch; //适配者 private QuickSort mQuickSort; public OperationAdapter() &#123; mBinarySearch = new BinarySearch(); mQuickSort = new QuickSort(); &#125; @Override public int[] sort(int[] array) &#123; //调用适配者的快排方法 return mQuickSort.quickSort(array); &#125; @Override public int search(int[] array, int key) &#123; //调用适配者的二分查找方法 return mBinarySearch.binarySearch(array, key); &#125;&#125; client123456789101112131415161718192021222324252627282930313233343536373839/** * @author: fanyuzeng on 2018/2/24 11:23 */public class Test &#123; public static void main(String[] args) &#123; ScoreOperation operation; //针对抽象目标接口编程 operation = new OperationAdapter(); int scores[] = &#123;84, 76, 50, 69, 90, 91, 88, 96&#125;; //定义成绩数组 int result[]; int index; System.out.println(\"成绩排序结果：\"); result = operation.sort(scores); //遍历输出成绩 for (int i : scores) &#123; System.out.print(i + \",\"); &#125; System.out.println(); System.out.println(\"查找成绩90：\"); index = operation.search(result, 90); if (index != -1) &#123; System.out.println(\"找到成绩90。在数组中的所因为：\" + index); &#125; else &#123; System.out.println(\"没有找到成绩90。\"); &#125; System.out.println(\"查找成绩92：\"); index = operation.search(result, 92); if (index != -1) &#123; System.out.println(\"找到成绩92。在数组中的所因为：\" + index); &#125; else &#123; System.out.println(\"没有找到成绩92。\"); &#125; &#125;&#125; 输出为： 成绩排序结果： 50,69,76,84,88,90,91,96, 查找成绩90： 找到成绩90。 查找成绩92： 没有找到成绩92。 类适配器模式除了对象适配器模式之外，适配器模式还有一种形式，那就是 类适配器模式，类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系，类适配器模式结构如图所示： 典型代码： 1234567calss Adapter imlements Target extends Adaptee&#123; @override public void request()&#123; specificRequest(); &#125; &#125; 由于 Java、C# 等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类 Target 不是接口，而是一个类，就无法使用类适配器；此外，如果适配者 Adapter 为最终（Final）类，也无法使用类适配器。在 Java 等面向对象编程语言中，大部分情况下我们使用的是对象适配器，类适配器较少使用。 缺省适配器缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。缺省适配器模式的定义如下： 缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。UML 图如下： 在缺省适配器模式中，包含如下三个角色： ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。 AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在 ServiceInterface 接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。 ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。 在 JDK 类库的事件处理包 java.awt.event 中广泛使用了缺省适配器模式，如 WindowAdapter、KeyAdapter、MouseAdapter 等。下面我们以处理窗口事件为例来进行说明：在 Java 语言中，一般我们可以使用两种方式来实现窗口事件处理类，一种是通过实现 WindowListener 接口，另一种是通过继承 WindowAdapter 适配器类。 如果是使用第一种方式，直接实现 WindowListener 接口，事件处理类需要实现在该接口中定义的七个方法，而对于大部分需求可能只需要实现一两个方法，其他方法都无须实现，但由于语言特性我们不得不为其他方法也提供一个简单的实现（通常是空实现），这给使用带来了麻烦。 而使用缺省适配器模式就可以很好地解决这一问题，在 JDK 中提供了一个适配器类 WindowAdapter 来实现 WindowListener 接口，该适配器类为接口中的每一个方法都提供了一个空实现，此时事件处理类可以继承 WindowAdapter 类，而无须再为接口中的每个方法都提供实现。 适配器模式总结主要优点无论是对象适配器模式还是类适配器模式都具有如下优点： (1) 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 (2) 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 (3) 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 具体来说，类适配器模式还有如下优点： 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器模式还有如下优点： (1) 一个对象适配器可以把多个不同的适配者适配到同一个目标； (2) 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。 主要缺点类适配器模式的缺点如下： (1) 对于 Java、C# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者； (2) 适配者类不能为最终类，如在 Java 中不能为 final 类，C# 中不能为 sealed 类； (3) 在 Java、C# 等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。 对象适配器模式的缺点如下： 与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 适用场景在以下情况下可以考虑使用适配器模式： (1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。 (2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/tags/Design-Patterns/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （五） 背压问题引入","slug":"RxJava5","date":"2018-02-24T06:16:16.000Z","updated":"2018-02-28T13:54:00.606Z","comments":true,"path":"2018/02/24/RxJava5/","link":"","permalink":"http://zengfanyu.top/2018/02/24/RxJava5/","excerpt":"背压问题的引入","text":"背压问题的引入 问题引入在上一篇文章中谈到了 zip 操作符，其中 Observer 接收到的事件的数量是发送事件数量虽少的 Observable 发送的个数。那么现在有一种情况，如果有一个 Observable1 一直在发送事件，而 Observable2 只发送一个事件，并且两个 Observable 都不调用 onComplete 方法，那么这时 Observer 接收事件的顺序是怎么样的的呢？ 12345678910111213141516171819202122232425262728293031323334353637Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; int i = 0; while (true) &#123; e.onNext(i++); &#125; &#125;&#125;).subscribeOn(Schedulers.io());Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(\"A\"); &#125;&#125;).subscribeOn(Schedulers.io());Observable .zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; LogUtil.d(TAG, s); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; LogUtil.e(TAG, throwable.getMessage()); &#125; &#125;); 可以看到 Observable1 以机器指令的执行速度循环发送 onNext 事件，Observable2 只发送一个 onNext 事件，并且 Observable1 Observable2 Obserber 分别在各自的线程中执行。 看看内存占用情况。 是的，OOM 了，占用内存飙升到 500+M，报错信息： 12345678910111213141516W/art: Throwing OutOfMemoryError \"Failed to allocate a 28 byte allocation with 360 free bytes and 360B until OOM; failed due to fragmentation (required continguous free 4096 bytes for a new buffer where largest contiguous free 0 bytes)\" (recursive case)W/art: \"RxCachedThreadScheduler-1\" daemon prio=5 tid=17 RunnableW/art: | group=\"main\" sCount=0 dsCount=0 obj=0x32c06940 self=0x7fa349b600W/art: | sysTid=28826 nice=0 cgrp=default sched=0/0 handle=0x7f94aba450W/art: | state=R schedstat=( 20565055506 41440899 661 ) utm=1941 stm=115 core=4 HZ=100W/art: | stack=0x7f949b8000-0x7f949ba000 stackSize=1037KBW/art: | held mutexes= \"mutator lock\"(shared held)W/art: at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:366)W/art: at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:62)W/art: at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:51)W/art: at java.util.concurrent.FutureTask.run(FutureTask.java:237)W/art: at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:272)W/art: at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)W/art: at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)W/art: at java.lang.Thread.run(Thread.java:760) 为什么会这样呢？ 这里先不解释。 现在讲问题简化一下，只使用一个 Observable 12345678910111213141516171819Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; int i = 0; while (true) &#123; e.onNext(i++); &#125; &#125; &#125;) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); LogUtil.d(TAG, integer + \"\"); &#125; &#125;); 发送端循环发送事件，接收端接收处理事件前延迟 2 秒，并且两段工作在同一个线程中。 似乎很平静，和想象当中的不一样。 但是如果将发送端和接收端放置在不同的线程中会是什么情况呢？ 代码： 1234567891011121314151617181920Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; int i = 0; while (true) &#123; e.onNext(i++); &#125; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); LogUtil.d(TAG, integer + \"\"); &#125; &#125;); 发送端在 io 线程，接收端在主线程。 又像脱缰的野马一样，直接 OOM了。 为什么同一线程和不同线程区别这么大呢？这里就涉及到同步和异步的知识。 当接收端和发送端在同一个线程中时，这时是一种同步订阅关系，既然是同步的，那么发送端就必须等接收端处理完一个事件之后才可以去发送下一个事件。 当接收端和发送端在不同线程中时，这时是一种异步订阅关系，此时两个线程不能直接进行通讯，所以有一个异步的「缓存池」用于缓存接收端来不及处理的发送端发送的数据，因此当发送端发送速度太快，接收端取出事件处理速度太慢，缓存池就会阻塞溢出，最后导致 OOM。 同步订阅和异步订阅的区别在于是否有「缓存池」，那么到这里问题的源头也知道了，只要有缓存池就会出现发送端和接收端速度不平衡的情况。那么如何解决这种问题呢？ 总结一下两种订阅关系： 到这里对「背压」就有了一个直观的了解了，可以这么理解： 被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息，从而操作消息的阻塞现象。 如何解决阻塞首先，我们分析阻塞形成的原因，无非是因为下面的原因啊： 上游的水流过快（发送端发送事件过快） 上游的水流过大（接收端发送事件过多） 总结来说就是短时间发送的事件过多，接收端忙不过来！ 那么先使用第一种方法，让事件发送的顺序慢一点 123456789101112131415161718192021Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; int i = 0; while (true) &#123; Thread.sleep(2000); e.onNext(i++); &#125; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtil.d(TAG, integer + \"\"); &#125; &#125;); 还是看看日志和内存 稳稳地，没毛病。 再试试第二种方法，下游少接收一点事件。 1234567891011121314151617181920212223242526Observable .create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; int i = 0; while (true) &#123; e.onNext(i++); &#125; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer % 100 == 0; &#125; &#125;) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; LogUtil.d(TAG, integer + \"\"); &#125; &#125;); 这里只接收 100 的整数倍事件，看看日志： 这种情况，内存还是会爆掉，但是速度会相对来说慢一点。 那么在这里，对文章开头的 zip 操作符的例子，就可以使用上述两个方法去解决，这里就不写出代码了。 上面唠唠叨叨说了那么多，基本上也给是阐明了阻塞形成的原因和解决阻塞的方法，基本策略就是减少发送事件的频率和减少发送事件的数量。 But…… 我们手动让上游发送事件的速度满下来貌似是不可取的，你想让上游的速度是多快呢？上游需要等多久呢？ 还有…… 我们依旧无法知道下游处理事件的能力，无法很好地处理阻塞的事件。 所以这个时候，RxJava2 很好的支持了背压，对阻塞进行了比较好的处理。 下一篇详细讲解 RxJava2.0 中的背压策略。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"一口一口啃完Java中的24种设计模式---代理模式","slug":"代理模式","date":"2018-02-10T08:49:16.000Z","updated":"2018-02-10T08:50:29.602Z","comments":true,"path":"2018/02/10/代理模式/","link":"","permalink":"http://zengfanyu.top/2018/02/10/代理模式/","excerpt":"","text":"代理模式的引入东汉末年，大将军何进引董卓入京，想借西北王的军队对抗阉党，无奈自己先被阉党做掉，而后造成巨变，导致诸侯并起，最终形成三国鼎立局面。汉献帝即位后，初平三年（公元 192 年），治中从事毛玠向曹操建议“奉天子以令不臣”，曹操采纳了他的建议，迎接汉献帝来到许昌。汉献帝刘协在许都没有实际的权利，曹操不断地诛除公卿大臣，不断地集军政大权于一身。建安元年八月，曹操进驻洛阳，立刻趁张杨、杨奉兵众在外，赶跑了韩暹，接着做了三件事：杀侍中台崇、尚书冯硕等，谓“讨有罪”；封董承、伏完等，谓“赏有功”；追赐射声校尉沮俊，谓“矜死节”。然后在第九天趁他人尚未来得及反应的情况下，迁帝都许，使皇帝摆脱其他势力的控制。此后，他还加紧步伐剪除异己，提高自己的权势。他首先向最有影响力的三公发难，罢免太尉杨彪、司空张喜；其次诛杀议郎赵彦；再次是发兵征讨杨奉，解除近兵之忧；最后是一方面以天子名义谴责袁绍，打击其气焰，另一方面将大将军让予袁绍，稳定大敌。这就是历史上著名的“挟天子以令诸侯”。汉献帝与曹操的关系，是历史上两位伟大的政治家的联手，稳定了东汉政权，最终平稳交接给曹魏政权，也间接映射了“代理模式”。 代理模式代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节 ，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。 代理模式角色分为 4 种： 主题接口：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法； 真实主题：真正实现业务逻辑的类 代理主题：用于代理和封装真实主题 客户端：面向主题接口，使用代理主题完成一些工作。 UML 图如下： 但是在实际开发中，代理类的实现比上述 UML 要复杂的多，代理模式根据其目的和实现方式不同可以分为很多种类，下面列举几种常用的代理模式： (1) 远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使（Ambassador）。 (2) 虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 (3) 保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 (4) 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 (5) 智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。 在这些常用的代理模式中，有些代理类的设计非常复杂，例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。 应用实例结构分析 开发一个商务信息查询系统，要求如下： (1) 在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统； (2) 在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。 假设已经完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。 根据上述 UML 图，对这个系统进行建模： 根据上述需求「已经开发完成的商务信息查询模块」在图中用 RealSearcher 表示，其中用于查询信息的方法为 doSearch ，按照代理模式的思想，将 doSearch 这个方法给抽象出来，放置到 Search 接口中，然后 RealSearcher 去实现这个接口。 验证身份和记录次数这两个操作很明显一个是位于查询之前，一个是位于查询之后，并且作为一个商务信息查询系统，直接将 RealSearcher 开放给用户使用，明显是不安全的行为，所以此处提供一个 ProxySearcher 对象作为 RealSearcher 的代理，相同的去实现 Searcher 接口，并且在 ProxySearcher 当中可以封装好身份校验和查询次数记录的逻辑。 RealSeacher 和 ProxySeacher 都实现了 Searcher 接口，对外暴露的方法都是相同的，所以对于 Client 来说， 调用 RealSearcher 和 ProxySearcher 并没有实质性的区别，在代码上体现出来的就是，Client 面向的是 Search 接口，而不是它的实现类。 代码实现Subject1234567891011121314/** * @author: fanyuzeng on 2018/2/10 10:24 */public interface Searcher &#123; /** * 调用查询系统的接口 * * @param userId 用户名 * @param password 密码 * @return 查询结果 */ String doSeach(String userId, String password);&#125; RealSubject1234567891011/** * @author: fanyuzeng on 2018/2/10 10:30 */public class RealSearcher implements Searcher &#123; @Override public String doSeach(String userId, String password) &#123; //模拟查询信息 return \"userName:\"+ userId +\"success some info:........\"; &#125;&#125; ProxySubject12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @author: fanyuzeng on 2018/2/10 10:33 */@Modulepublic class ProxySearcher implements Searcher &#123; private static final String TAG = \"==ProxySearcher==\"; //持有真正进行查询过程对象的引用 private RealSearcher mRealSearcher; //验证用户身份的工具 private AccessValidator mAccessValidator; //记录查询次数的工具 private Logger mLogger; //这里代理对象使用单例模式 private static ProxySearcher sProxySearcher; private ProxySearcher() &#123; mRealSearcher = new RealSearcher(); mAccessValidator = new AccessValidator(); mLogger = new Logger(); &#125; public static ProxySearcher getInstance() &#123; if (sProxySearcher == null) &#123; sProxySearcher = new ProxySearcher(); &#125; return sProxySearcher; &#125; @Override public String doSeach(String userId, String password) &#123; if (userId == null || password == null) return \"params empty\"; String result = \"search fail\"; if (mAccessValidator != null) &#123; if (isVertify(userId)) &#123; if (mRealSearcher != null) &#123; //调用 RealSearcher 的 doReach 方法 result = mRealSearcher.doSeach(userId, password); &#125; &#125; else &#123; System.out.println(\"Access deny\"); &#125; &#125; if (!result.equals(\"search fail\")) &#123; logSearchCount(userId); &#125; return result; &#125; //检查用户身份是否合法 private boolean isVertify(String userId) &#123; return mAccessValidator.Validate(userId); &#125; //记录查询次数 private void logSearchCount(String userId) &#123; mLogger.searchLog(userId); &#125;&#125; Client123456789101112131415161718192021/** * @author: fanyuzeng on 2018/2/10 10:53 */public class Client &#123; private static Searcher mSearcher; public static void main(String[] args) &#123; if (mSearcher == null) &#123; mSearcher = getSearchInstance(); &#125; mSearcher.doSeach(\"ZFY\", \"blabala\"); &#125; //写入配置文件当中，然后通过反射调用，灵活性更高 private static Searcher getSearchInstance() &#123; return ProxySearcher.getInstance(); &#125;&#125; 辅助类，验证身份、记录查询次数1234567891011121314151617181920212223242526/** * 身份验证类 * * @author: fanyuzeng on 2018/2/10 10:33 */public class AccessValidator &#123; private static final String TAG = \"==AccessValidator==\"; /** * 模拟实现登录验证 * * @param userId * @return */ public boolean Validate(String userId) &#123; System.out.println(\"在数据库中验证用户\" + userId + \"是否是合法用户？\"); if (userId.equals(\"ZFY\")) &#123; System.out.println(\"登录成功！\" + userId); return true; &#125; else &#123; System.out.println(\"登录失败！\" + userId); return false; &#125; &#125;&#125; 12345678910111213141516171819/** * 用于记录查询次数 * * @author: fanyuzeng on 2018/2/10 10:37 */public class Logger &#123; private static final String TAG = \"==Logger==\"; /** * 模拟记录查询次数 * * @param userId */ public void searchLog(String userId) &#123; System.out.println(\"更新数据库，用户:\" + userId + \" 查询次数+1！\"); &#125;&#125; 输出","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/tags/Design-Patterns/"}]},{"title":"WebSocket、Socket、SocketIO、HTTP的关系","slug":"WebSocket_Socket_HTTP_SocketIO","date":"2018-02-03T02:16:16.000Z","updated":"2018-02-03T03:08:03.005Z","comments":true,"path":"2018/02/03/WebSocket_Socket_HTTP_SocketIO/","link":"","permalink":"http://zengfanyu.top/2018/02/03/WebSocket_Socket_HTTP_SocketIO/","excerpt":"摘要：最近部门在做一个基于 WebRTC 的视频会议系统，其中 Android 端代码需要连接三个服务器，分别是 RoomServer、MessageServer、MediaServer。 RoomServer 用于处理 client 请求（创建房间、发布视频等），并且将 MediaServer 的最新消息通过 MessageServer 推送至 client。 client 和 RoomServer 之间使用 http 连接实现；既然 client 需要接受 MessageServer 的消息推送，那么用 HTTP 明显是不能完成的，所以 client 到 MessageServer 之间使用了 WebSocket，用于保持长连接，这样 client 和 MessageServer 都可以主动发送消息； client 和 MediaServer 之间使用了 SocketIO，这样信令通道也是全双工的工作类型。 其中涉及到的 HTTP、WebSocket、SocketIO 的，一顿 google 之后，搞清楚了三者之间的关系，这里记录做下记录。","text":"摘要：最近部门在做一个基于 WebRTC 的视频会议系统，其中 Android 端代码需要连接三个服务器，分别是 RoomServer、MessageServer、MediaServer。 RoomServer 用于处理 client 请求（创建房间、发布视频等），并且将 MediaServer 的最新消息通过 MessageServer 推送至 client。 client 和 RoomServer 之间使用 http 连接实现；既然 client 需要接受 MessageServer 的消息推送，那么用 HTTP 明显是不能完成的，所以 client 到 MessageServer 之间使用了 WebSocket，用于保持长连接，这样 client 和 MessageServer 都可以主动发送消息； client 和 MediaServer 之间使用了 SocketIO，这样信令通道也是全双工的工作类型。 其中涉及到的 HTTP、WebSocket、SocketIO 的，一顿 google 之后，搞清楚了三者之间的关系，这里记录做下记录。 要搞清楚的问题说到底，这篇博文就是要搞清楚以下的问题，从宏观上了解，不深究细节部分。 socket 是觉得了什么问题？ WebSocket 为什么被引入？ 又解决了什么问题？ Socket 和 WebSocket 有哪些区别和联系？ WebSocket 和 HTML5 是什么关系？ 必须在浏览器中才能使用 WebSocket 吗？ WebSocket 能和 Socket 一样传输 raw 数据么？ WebSocket 和 HTTP 什么关系？有什么区别？ Socket.IO 是什么？ Socket.IO 与 WebSocket 之间是什么关系？ OSI模型与TCP/IP以下是 维基百科 中关于OSI 模型的说明： 开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，ISO/IEC 7498-1），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。 而 TCP/IP 协议可以看做是对 OSI 模型的一种简化（以下内容来自 维基百科）： 它将软件通信过程抽象化为四个抽象层，采取协议堆叠的方式，分别实作出不同通信协议。协议套组下的各种协议，依其功能不同，被分别归属到这四个阶层之中7，常被视为是简化的七层OSI模型。 这里有一张图详细介绍了 TCP/IP 协议族中的各个协议在 OSI模型 中的分布，一图胜千言（下图来自 科来）： HTTP 、WebSocket 等协议运行在应用层，TCP 协议运行在传输层，IP 协议运行在网络层。 WebSocket 与 HTTP从上图可以看出，HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的。我们可以把这些高级协议理解成对 TCP 的封装。 既然大家都使用 TCP 协议，那么大家的连接和断开，都要遵循 TCP 协议中的三次握手和四次挥手 ，只是在连接之后发送的内容不同，或者是断开的时间不同。 对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。 至于具体的这里就不展开了，可以参考： WebSocket详解（四）：刨根问底HTTP与WebSocket的关系(上篇) WebSocket详解（五）：刨根问底HTTP与WebSocket的关系(下篇) 为什么引入WebSocket协议从整个计算机网络的层面面知道了 WebSocket 的定位之后，接下来的问题就是：已经有了 HTTP 协议，为什么还需要 WebSocket 协议？ 现在提到 WebSocket，首先会想到 “及时通讯” 和 “推送” 这类词。在 WebSocket 以前，很多网站通过其他方式来推送信息，下面我们先看看以前的推送方式，这样，有比较才能看出 WebSocket 的优势以及为什么引入WebSocket协议。 (短)轮询（Polling） 这种方式下，client 每隔一段时间都会向 server 发送 http 请求，服务器收到请求后，将最新的数据发回给 client。一开始必须通过提交表单的形式，这样的后果就是传输很多冗余的数据，浪费了带宽。后来 Ajax 出现，减少了传输数据量。 如图所示，在 client 向 server 发送一个请求活动结束后，server 中的数据发生了改变，所以 client 向 server 发送的第二次请求中，server 会将最新的数据返回给 client。 但这种方式也存在弊端。比如在某个时间段 server 没有更新数据，但 client 仍然每隔一段时间发送请求来询问，所以这段时间内的询问都是无效的，这样浪费了网络带宽。将发送请求的间隔时间加大会缓解这种浪费，但如果 server 更新数据很快时，这样又不能满足数据的实时性。 Comet鉴于（短）轮询的弊端，一种基于 HTTP 长连接的 “服务器推” 的技术被 hack 了出来，这种技术被命名为 Comet。其与（短）轮询主要区别就是，在轮询方式下，要想取得数据，必须首先发送请求，在实时性要求较高的情况下，只能增加向 server 请求的频率；而 Comet 则不同，client 与 server 端保持一个长连接，只有数据发生改变时，server 才主动将数据推送给 client。Comet 又可以被细分为两种实现方式，一种是长轮询机制，一种是流技术。 长轮询（Long-polling） client 向 server 发出请求，server 接收到请求后，server 并不一定立即发送回应给 client，而是看数据是否更新，如果数据已经更新了的话，那就立即将数据返回给 client；但如果数据没有更新，那就把这个请求保持住，等待有新的数据到来时，才将数据返回给 client。 当然了，如果 server 的数据长时间没有更新，一段时间后，请求便会超时，client 收到超时信息后，再立即发送一个新的请求给 server。 如图所示，在长轮询机制下，client 向 server 发送了请求后，server会等数据更新完才会将数据返回，而不是像（短）轮询一样不管数据有没有更新然后立即返回。 这种方式也有弊端。当 server 向 client 发送数据后，必须等待下一次请求才能将新的数据发送出去，这样 client 接收到新数据的间隔最短时间便是 2 * RTT（往返时间），这样便无法应对 server 端数据更新频率较快的情况。 流技术（Http Streaming） 流技术基于 Iframe。Iframe 是 HTML 标记，这个标记的 src 属性会保持对指定 server 的长连接请求，server 就可以不断地向 client 返回数据。 可以看出，流技术与长轮询的区别是长轮询本质上还是一种轮询方式，只不过连接的时间有所增加，想要向 server 获取新的数据，client 只能一遍遍的发送请求；而流技术是一直保持连接，不需要 client 请求，当数据发生改变时，server 自动的将数据发送给 client。 如图所示，client 与 server 建立连接之后，便不会断开。当数据发生变化，server 便将数据发送给 client。 但这种方式有一个明显的不足之处，网页会一直显示未加载完成的状态。 WebSocket前人推出那么多的解决方案，想要解决的唯一的问题便是怎么让 server 将最新的数据以最快的速度发送给 client。 但 HTTP 是个懒惰的协议，server 只有收到请求才会做出回应，否则什么事都不干。因此，为了彻底解决这个 server 主动向 client 发送数据的问题，W3C 在 HTML5 中提供了一种 client 与 server 间进行全双工通讯的网络技术 WebSocket。WebSocket 是一个全新的、独立的协议，基于 TCP 协议，与 HTTP 协议兼容却不会融入 HTTP 协议，仅仅作为 HTML5 的一部分。 那 WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 相比于传统 HTTP 的每次“请求-应答”都要 client 与 server 建立连接的模式，WebSocket 是一种长连接的模式。具体什么意思呢？就是一旦 WebSocket 连接建立后，除非 client 或者 server 中有一端主动断开连接，否则每次数据传输之前都不需要 HTTP 那样请求数据。从上面的图可以看出，client 第一次需要与 server 建立连接，当 server 确认连接之后，两者便一直处于连接状态。直到一方断开连接，WebSocket 连接才断开。 从报文层面来说，如下： 首先，client 发起 WebSocket 连接，报文类似于 HTTP，但主要有几点不一样的地方： “Upgrade: websocket”： 表明这是一个 WebSocket 类型请求，意在告诉 server 需要将通信协议切换到 WebSocket “Sec-WebSocket-Key: *”: 是 client 发送的一个 base64 编码的密文，要求 server 必须返回一个对应加密的 “Sec-WebSocket-Accept” 应答，否则 client 会抛出 “Error during WebSocket handshake” 错误，并关闭连接 server 收到报文后，如果支持 WebSocket 协议，那么就会将自己的通信协议切换到 WebSocket，返回以下信息： “HTTP/1.1 101 WebSocket Protocol Handshake”：返回的状态码为 101，表示同意 client 的协议转换请求 “Upgrade: websocket” “Connection: Upgrade” “Sec-WebSocket-Accept: *” … 客户端请求响应报文：（引用自即时通讯网） 以上都是利用 HTTP 协议完成的。这样，经过“请求-响应”的过程， server 与 client 的 WebSocket 连接握手成功，后续便可以进行 TCP 通讯了，也就没有 HTTP 什么事了。可以查阅WebSocket 协议栈了解 WebSocket 的 client 与 server 更详细的交互数据格式。 什么是 Socket网络应用中，两个应用程序同时需要向对方发送消息的能力（即全双工通信），所利用到的技术就是 socket，其能够提供端对端的通信。 对于程序员而言，其需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP 连接，从而可以进行双向通信。 Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。 最早的一套 Socket API 是 Berkeley sockets ，采用 C 语言实现。它是 Socket 的事实标准，POSIX sockets 是基于它构建的，多种编程语言都遵循这套 API，在 JAVA、Python 中都能看到这套 API 的影子。 下面摘录一段更容易理解的文字： Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。 而 WebSocket 则不同，它是一个完整的 应用层协议，包含一套标准的 API 。 所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。 WebSocket 与 SocketWebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似 Socket 的双向通信机制。同时，WebSocket 又是一种新的应用层协议，包含一套标准的 API；而 socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP），所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。 HTML5 与 WebSocketWebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。 实际上，许多语言、框架和服务器都提供了 WebSocket 支持，例如： 基于 C 的 libwebsocket.org 基于 Node.js 的 Socket.io 基于 Python 的 ws4py 基于 C++ 的 WebSocket++ Apache 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel Nginx 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying lighttpd 对 WebSocket 的支持：mod_websocket 什么是 Socket.IOSocket.IO 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node。其屏蔽了所有底层细节，你不用关心里面用了什么连接方式,让顶层调用非常简单。 另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。 好了，基本搞清楚 WebSocket、Socket、HTTP、SocketIO 的概念以及之间的关系了。","categories":[{"name":"计算机网络基础拾遗","slug":"计算机网络基础拾遗","permalink":"http://zengfanyu.top/categories/计算机网络基础拾遗/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://zengfanyu.top/tags/HTTP/"}]},{"title":"SQLite IllegalStateException 的隐蔽 bug 修复","slug":"SQLiteException","date":"2018-01-20T10:00:16.000Z","updated":"2018-08-18T10:50:03.865Z","comments":true,"path":"2018/01/20/SQLiteException/","link":"","permalink":"http://zengfanyu.top/2018/01/20/SQLiteException/","excerpt":"摘要：java.lang.IllegalStateException: Couldn’t read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it.","text":"摘要：java.lang.IllegalStateException: Couldn’t read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it. 发生场景：查询数据库 报错日志如下： 12345678910111213141516171819202122232425262728293031323334353637java.lang.RuntimeException: An error occurred while executing doInBackground() at android.os.AsyncTask$3.done(AsyncTask.java:325) at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:354) at java.util.concurrent.FutureTask.setException(FutureTask.java:223) at java.util.concurrent.FutureTask.run(FutureTask.java:242) at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:243) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761)Caused by: java.lang.IllegalStateException: Couldn't read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it. at android.database.CursorWindow.nativeGetLong(Native Method) at android.database.CursorWindow.getLong(CursorWindow.java:511) at android.database.CursorWindow.getInt(CursorWindow.java:578) at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:69) at com.pplive.media.upload.db.UploadDataBaseManager.searchAllUploads(UploadDataBaseManager.java:146) at com.pplive.media.upload.UploadManager.searchAllUploads(UploadManager.java:400) at com.suning.mobile.ebuy.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1201) at com.suning.mobile.ebuy.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1196) at android.os.AsyncTask$2.call(AsyncTask.java:305) at java.util.concurrent.FutureTask.run(FutureTask.java:237) ... 4 morejava.lang.IllegalStateException: Couldn't read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it. at android.database.CursorWindow.nativeGetLong(Native Method) at android.database.CursorWindow.getLong(CursorWindow.java:511) at android.database.CursorWindow.getInt(CursorWindow.java:578) at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:69) at com.pplive.media.upload.db.UploadDataBaseManager.searchAllUploads(UploadDataBaseManager.java:146) at com.pplive.media.upload.UploadManager.searchAllUploads(UploadManager.java:400) at com.xxxx.zzzz.cccc.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1201) at com.xxxx.zzzz.cccc.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1196) at android.os.AsyncTask$2.call(AsyncTask.java:305) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:243) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761) 最开始一看这个日志「Couldn’t read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it」，应该是 SQLite 查询的时候字段写错了吧，因为这个情况之前也遇到过，所以 google 验证一下，确实很多都是因为字段写错了。于是我返回代码中去查看字段。 很遗憾的是，数据库相关字段我都是用 public static final String XXXX 的形式来定义，并且在创建数据库和查询表的时候，都是使用的 XXXX ，那么照理来说是不会出现建表和查询时，填错大小写或者多一个空格少一个空格的情况，那么这种情况被 pass。 接着又去检查 SQL 语句，因为之前会碰到一个 SQL 语句当中插入一个值，而没有用空格，导致的 SQL 语句不正确的情况，例如：”select from”+TABLENAME ,这样就不对，应该是：”select from “+TABLENAME，但是如果是 SQL 语句的问题，那么不应该是报这个错误呀，应该会报 SQL 语句相关的错误才对，于是这个情况也被 pass。 于是接着从日志当中的 -1 入手，cursor 的 getColumnIndex() 方法注解是这样的： 123456789101112/** * Returns the zero-based index for the given column name, or -1 if the column doesn't exist. * If you expect the column to exist use &#123;@link #getColumnIndexOrThrow(String)&#125; instead, which * will make the error more clear. * * @param columnName the name of the target column. * @return the zero-based column index for the given column name, or -1 if * the column name does not exist. * @see #getColumnIndexOrThrow(String) */int getColumnIndex(String columnName); 这么说，当前列如果不存在的话，那么这个方法的返回值是 -1 ，那么上面的报错日志就合理啦，于是我在查询之前打印了一下当前数据库的情况： 12UploadInfo&#123;status=0, ppfeature='null', fid='null', categoryId=0, state=0, size='null', name='null', localPath='null', id=6, progress=0, token='null', isPause=false, channel_web_id='null', pic_upload_url='null', startTime=1516106247809, length=0, channelId=0, userId=0, maxSpeed=0, minSpeed=0, fileState=0, isStop=false&#125; 对的，没问题，我要查询的那一列是存在的，并且这里的字段和建表语句是符合的。要查询的那一列不存在这种情况也被 pass。 到了这里，我感觉我已经把可能出现问题的地方都检查过了，但是还有一个地方，日志当中有这么一句： at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:69) 是不是 getInt 的问题？？ 看看源码注释： 12345678910111213/** * Returns the value of the requested column as an int. * * &lt;p&gt;The result and whether this method throws an exception when the * column value is null, the column type is not an integral type, or the * integer value is outside the range [&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;] is implementation-defined. * * @param columnIndex the zero-based index of the target column. * @return the value of that column as an int. */int getInt(int columnIndex); 「当结果为默认值」，「列值为空」，「不是 integer 类型」， 「integer 类型超出范围」，这几种情况下，该方法会不会引起异常，是由现实情况决定的。 现实情况决定的？？那就是可以理解成，跟设备相关咯（这个想法后来被证实是正确的，确实跟设备型号相关，上述异常在部分设备上不会抛出）。 那么这个注释的意思就是说：上述四种情况，我们去获取它，那么结果在不同的设备上不一样，有的设备上是可以正常获取到 SQLite 中定义的初始值的，有的就会直接抛异常。 以上几种情况，根据项目代码的一些限定和过滤以及之前的单元测试（业务相关），只有「当结果为默认值」这种情况可能会发生，也就是程序只创建了数据库和数据表，但是还没有往里面插入数据，就查询数据，那么这时数据表中的字段就应该是默认值。 怎么解决？ 既然出问题的是默认值，那么我就在应该返回默认值的时候，手动去赋一个默认值。 保证每次调用 cursor 的 getXXX 方法时，都需要检查返回值是否为空。用下面的代码去替代系统 cursor 的 getXXX 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private long getLong(Cursor cursor, String indexName) &#123; long value = 0; int columnIndex = -1; try &#123; columnIndex = cursor.getColumnIndex(indexName); if (!cursor.isNull(columnIndex)) &#123; value = cursor.getLong(columnIndex); &#125; &#125; catch (Throwable tr) &#123; LogUtils.error(\"columnIndex:\" + columnIndex + \"e:\" + tr.getMessage()); &#125; return value;&#125;private int getInt(Cursor cursor, String indexName) &#123; int value = 0; int columnIndex = -1; try &#123; columnIndex = cursor.getColumnIndex(indexName); if (!cursor.isNull(columnIndex)) &#123; value = cursor.getInt(columnIndex); &#125; &#125; catch (Throwable tr) &#123; LogUtils.error(\"columnIndex:\" + columnIndex + \"e:\" + tr.getMessage()); &#125; return value;&#125;private String getString(Cursor cursor, String indexName) &#123; String value = null; int columnIndex = -1; try &#123; columnIndex = cursor.getColumnIndex(indexName); if (!cursor.isNull(columnIndex)) &#123; value = cursor.getString(columnIndex); &#125; &#125; catch (Throwable tr) &#123; LogUtils.error(\"columnIndex:\" + columnIndex + \"e:\" + tr.getMessage()); &#125; return value;&#125; 使用后，异常完美解决。 还有一种思路没有实践： 既然是默认值的问题，那么在 SQLiteOpenHelper 的 onCreate 方法中建表的时候，就将默认值写死就好啦，就是在每一个字段的建表语句后加上一个 DEFAULT ，比如： 123456789101112131415161718@Overridepublic void onCreate(SQLiteDatabase db) &#123; db.execSQL(String.format( \"CREATE TABLE %s (%s INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, \" // BaseColumns._ID + \"%s TEXT DEFAULT null, \" // FIELD_LOCAL_PATH + \"%s TEXT DEFAULT null, \" // FIELD_NAME + \"%s TEXT DEFAULT null, \" // FIELD_TOKEN + \"%s TEXT DEFAULT null, \" // FIELD_SIZE + \"%s INTEGER DEFAULT 0, \" // FIELD_STATE + \"%s TEXT DEFAULT null, \" // FIELD_PPFEATURE + \"%s TEXT DEFAULT null, \" // FIELD_FID + \"%s TEXT DEFAULT null, \"// FIELD_CATEGORY_ID + \"%s TEXT DEFAULT null, \"// FIELD_CHANNEL_WEB_ID + \"%s INTEGERvDEFAULT 0, \" // CHANNEL_ID TABLE_UPLOAD, BaseColumns._ID, FIELD_LOCAL_PATH, FIELD_NAME, FIELD_TOKEN, FIELD_SIZE, FIELD_STATE, FIELD_PPFEATURE, FIELD_FID, FIELD_CATEGORY_ID, FIELD_CHANNEL_WEB_ID,CHANNEL_ID));&#125; 后面可以实践下。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"BugFix","slug":"BugFix","permalink":"http://zengfanyu.top/tags/BugFix/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （四） RxJava 调度器和操作符","slug":"RxJava4","date":"2018-01-20T06:16:16.000Z","updated":"2018-01-20T09:10:42.323Z","comments":true,"path":"2018/01/20/RxJava4/","link":"","permalink":"http://zengfanyu.top/2018/01/20/RxJava4/","excerpt":"摘要：之前的记录了一下 RxJava 最基本的使用方法，没有涉及到为什么这么多人使用它的具体原因，就是说没体现它的魅力所在嘛， 所以这一篇就记录一下我学习的RxJava 当中的变换操作符（Operator）和调度器（Scheduler），前者可以说是 RxJava 的核心功能之一，也是大多数人使用 RxJava 的主要原因，后者是可以让不同线程之间的代码在一条链路代码中书写，极大简化逻辑。","text":"摘要：之前的记录了一下 RxJava 最基本的使用方法，没有涉及到为什么这么多人使用它的具体原因，就是说没体现它的魅力所在嘛， 所以这一篇就记录一下我学习的RxJava 当中的变换操作符（Operator）和调度器（Scheduler），前者可以说是 RxJava 的核心功能之一，也是大多数人使用 RxJava 的主要原因，后者是可以让不同线程之间的代码在一条链路代码中书写，极大简化逻辑。 调度器（Scheduler）开发过程中经常会碰到这样的需求：子线程中去请求服务器数据，拿到数据之后进行解析，然后回调给主线程中的接口去展示。 这种需求有很多种写法，比如用 AsyncTask ，在 doInBackground 中进行耗时操作，然后在 onPostExecute 当中接受结果，进行处理；或者是直接在主线程中切进行耗时操作，然后通过用 Looper.getMainLooper() 创建的 Handler 将结果发送至主线程去处理。 上面提到的两种方法，主要要解决的问题就是切换线程，因为 Android 中规定耗时操作不能在主线程当中进行，但是 UI 的更新操作又必须在主线程中进行，而 UI 的更新状态往往是需要耗时操作所得到的结果来做支撑的。所以为了解决这一矛盾，Google 官方给了 AsyncTask 和 Handler 两个工具。 RxJava 当然也可以解决上述问题，并且是在同一条链路中，不存在各种接口的回调，起到这个作用的就是 Scheduler，线程调度器。RxJava 通过它来指定每一行代码应该运行在什么样的线程环境，RxJava 当中已经内置了好几种 Scheduler： Scheduler 的种类1. Schedulers.newThread() 这个 Scheduler 会创建一个新的线程，并且用这个 Scheduler 指定的代码会在新创建的线程中去执行。 2. Scheduler.io() 这个 Scheduler 适用于一些执行阻塞式 IO 操作的，比如说：读写文件、读写数据库、访问网络等。它在内部是使用 CacheThreadPool 实现的。 123456public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 这个线程池没有核心线程数，它会根据需要去创建线程，并且有 60秒 的超时机制。不要用这个 Scheduler 去指定计算操作的运行线程，这样可以避免创建多余的线程。 3. Schedulers.computation() 这个 Scheduler 适合执行 CPU 密集型的操作，比如事件循环，处理回调和其他计算工作。它内部使用的是固定线程数的线程池，大小等于 CPU 核数。不要用它去指定 IO 操作的代码运行线程环境，不然 IO 操作的等待会浪费 CPU。 4. AndroidScheculers.mainThread() 这个 Scheduler 是 Android 独有的， 用它指定的代码会运行在主线程当中。 Scheduler 的使用有了上述 Scheduler 之后， 就可以使用 subscribeOn() 和 observerOn() 两个方法来指定代码的运行环境了。 这里的代码使用的是 RxJava2 的 API1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); tv = findViewById(R.id.id_tv); Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; String result = getDataFromServer(); if (!TextUtils.isEmpty(result)) &#123; e.onNext(result); &#125; &#125; &#125;) .subscribeOn(Schedulers.io())//指定subscribe（）发生在io线程 .observeOn(AndroidSchedulers.mainThread())//指定 Subscriber 的回调发在主线程 .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String result) throws Exception &#123; LogUtil.d(TAG, \"[ accept ] \" + \"result=\" + result); LogUtil.d(TAG, \"[ accept ] \" + \"current thread is \" + Thread.currentThread().getName()); tv.setText(result); &#125; &#125;);&#125;public String getDataFromServer() &#123; LogUtil.d(TAG, \"[ getDataFromServer ] \" + \"current thread is \" + Thread.currentThread().getName()); LogUtil.d(TAG, \"[ getDataFromServer ] \" + \"get data from server\"); return \"Hello RxJava\";&#125; 看看 Log情况： 12345D/===RxJavaSample==: TestActivity [ getDataFromServer ] current thread is RxCachedThreadScheduler-1D/===RxJavaSample==: TestActivity [ getDataFromServer ] get data from serverD/===RxJavaSample==: TestActivity [ accept ] result=Hello RxJavaD/===RxJavaSample==: TestActivity [ accept ] current thread is main 很明显了， Observable 是在子线程中发送事件， 而 Obserber 接收并处理事件是在 主线程中进行的。 总结一下， subscribeOn() 用于指定 Observable 发送事件的线程。 obserberOn() 用于指定 Observer 接受并处理事件的线程。 关于两者多次使用的情况，做一下总结： subscribeOn()：多次调用，只有第一次有效。 observerOn()：每调用一次，下面的代码就会切换一次。 举个例子(使用了 lambda 表达式)： 123456789101112131415161718192021222324252627282930313233343536373839@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); tv = findViewById(R.id.id_tv); Observable.create((ObservableOnSubscribe&lt;String&gt;) e -&gt; &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"current thread is \" + Thread.currentThread().getName()); String token = getTokenFromServer(); LogUtil.d(TAG, \"[ subscribe ] \" + \"token:\" + token); e.onNext(token); &#125;) .subscribeOn(Schedulers.io())//第一次指定subscribe()在io线程 .subscribeOn(AndroidSchedulers.mainThread())//第二次指定subscribe()的线程在主线程 .observeOn(Schedulers.io())//指定下面map操作发生在io线程 .map(s -&gt; &#123; LogUtil.d(TAG, \"[ apply ] \" + \"current thread is \" + Thread.currentThread().getName()); String playUrl = getPlayUrl(s); LogUtil.d(TAG, \"[ apply ] \" + \"play url is \" + playUrl); return playUrl; &#125;) .observeOn(AndroidSchedulers.mainThread())//指定Observer接受事件是在主线程 .subscribe(s -&gt; &#123; LogUtil.d(TAG, \"[ accept ] \" + \"current thread is \" + Thread.currentThread().getName()); LogUtil.d(TAG, \"[ accept ] \" + \"s=\" + s); tv.setText(s); &#125;); &#125; public String getTokenFromServer() &#123; return \"token-123456\"; &#125; public String getPlayUrl(String token) &#123; return \"api.xxxx.com?a=12&amp;b=34&amp;token=\" + token; &#125; 输出结果： 123456701-07 18:45:51.191 12827-12853/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] current thread is RxCachedThreadScheduler-101-07 18:45:51.191 12827-12853/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] token:token-12345601-07 18:45:51.191 12827-12854/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ apply ] current thread is RxCachedThreadScheduler-201-07 18:45:51.191 12827-12854/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ apply ] play url is api.xxxx.com?a=12&amp;b=34&amp;token=token-12345601-07 18:45:51.351 12827-12827/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] current thread is main01-07 18:45:51.351 12827-12827/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] s=api.xxxx.com?a=12&amp;b=34&amp;token=token-123456 可以看到在第二次调用 subscribeOn(AndroidSchedulers.mainThread()) 并没有起作用，拿 token 的操作仍然是在 io 线程执行的。 而第一次调用 observeOn(Schedulers.io()) 之后，后面的 map 操作用 token 去拿 url 地址这个过程是在 io 线程执行的。 在第二次调用 observeOn(AndroidSchedulers.mainThread()) 之后，将 url 地址显示在 TextView 这个过程是在 主线程中执行的。 变换操作符在 只因为在众多框架中多看了你一眼 RxJava （二） 从概念上理解 RxJava 这篇中举了一个过滤的例子，那么我理解的 RxJava 的变换操作，就类似于过滤过程，“过滤” 就是这个变换，但是变换不仅仅包含过滤。下面记录一些常用的操作符。 mapmap 就是对 Observable 发出的每一个事件，都施加一个函数，使得每一个事件都按照指定的函数去变化，Observer 接收到的事件就是经过函数变化后的。 官方图： 用代码实现： 1234567891011121314Observable.just(1,2,3) .map(new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer) throws Exception &#123; return integer*10; &#125; &#125;) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer s) throws Exception &#123; LogUtil.d(TAG,\"[accept] \" + \"after map s:\"+s); &#125; &#125;); 从上面的代码和示意图能看出来， map 操作符是一种一对一的关系。 flatMap这个操作符通过例子来理解： 需求：打印出每一个学生所选修的课程，一个学生不止选修一门课程。 学生和课程的数据结构如下： 12345678910111213141516171819/** * @author: fanyuzeng on 2018/1/8 10:22 */public class Student &#123; private String mName; private List&lt;Course&gt;mCourses; //getter setter&#125;/** * @author: fanyuzeng on 2018/1/8 10:35 */public class Course &#123; private String courseName; //getter setter&#125; 常规写法： 12345678910Observable.fromIterable(mStudentList) .subscribe(new Consumer&lt;Student&gt;() &#123; @Override public void accept(@NonNull Student student) throws Exception &#123; for (Course course : student.getCourses()) &#123; LogUtil.d(TAG, \"[accept] \" + course.toString()); &#125; &#125; &#125;); mStudentList 中，xiaoming1 选修 yuwen1、yuwen2;xiaoming2 选修 yuwen3、yuwen4;xiaoming3 选修 yuwen5、yuwen6; 上述代码没报名，可以打印出每一个学生的选修课程，但是这对代码的复用性不高，我们希望的是在 Consumer 的 accept() 当中传入的参数就是一个一个的 Course 对象。 这个时候就要靠 flatMap 了。 123456789101112131415Observable.fromIterable(mStudentList) .flatMap(new Function&lt;Student, ObservableSource&lt;Course&gt;&gt;() &#123; @Override public ObservableSource&lt;Course&gt; apply(@NonNull Student student) throws Exception &#123; return Observable.fromIterable(student.getCourses()); &#125; &#125;) .subscribe(new Consumer&lt;Course&gt;() &#123; @Override public void accept(@NonNull Course course) throws Exception &#123; LogUtil.d(TAG, \"[accept] \" + course); &#125; &#125;); flatMap 将原始 Observable 发送的事件构造成多个 Observable 对象，然后将他们发送的事件整合到另外的一个单独的 Observable 中。 官方解释图： 扔物线的解释图： 还有一种图，很形象： flatMap 的原理： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable, 而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。 这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象「铺平」之后通过统一路径分发了下去。而这个「铺平」就是 flatMap() 所谓的 flat。 可以看得出来上面的示意图能看出来，flatMap 并不能保证事件的顺序，要想保证顺序，则用 ConcatMap。 从上面的代码和示意图能看出来， flatMap 操作符是一种一对多的关系。 flatMap 拓展传统的嵌套请求是需要嵌套回调机制来实现的，但是使用 flatMap 就可以把请求写在一条链中，使逻辑清晰，这也可以体现它的优势吧：随着程序逻辑越来越复杂，它仍然能保持简洁。 假设存在两个 Retrofit 接口， 一个用于注册，一个用于登录： 12345678public interface Api &#123; @GET Observable&lt;LoginResponse&gt; login(@Body LoginRequest request); @GET Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);&#125; (这里涉及到Rxjava + Retrofit 的使用) 1234567891011121314151617181920212223242526272829api.register(new RegisterRequest()) //发起注册请求 .subscribeOn(Schedulers.io()) //在IO线程进行网络请求 .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求注册结果 .doOnNext(new Consumer&lt;RegisterResponse&gt;() &#123; @Override public void accept(RegisterResponse registerResponse) throws Exception &#123; //先根据注册的响应结果去做一些操作 &#125; &#125;) .observeOn(Schedulers.io()) //回到IO线程去发起登录请求 .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;LoginResponse&gt;&gt;() &#123; @Override public ObservableSource&lt;LoginResponse&gt; apply(RegisterResponse registerResponse) throws Exception &#123; return api.login(new LoginRequest()); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求登录的结果 .subscribe(new Consumer&lt;LoginResponse&gt;() &#123; @Override public void accept(LoginResponse loginResponse) throws Exception &#123; Toast.makeText(MainActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, \"登录失败\", Toast.LENGTH_SHORT).show(); &#125; &#125;); concatconcat 操作符用于链接多个事件，只有当前面一个事件结束之后，才会发送后面的事件。 官方图： 我们获取网络数据的时候，经常会在本地缓存一份，然后在下一次获取数据的时候，会先从缓存中去拿数据，如果拿到了数据就直接返回，如果没有拿到数据，再去请求网络获取数据。 这样的需求就十分适合使用 concat 操作符来完成。 从缓存中拿数据的 Observable 123456789101112131415161718192021222324//从缓存获取数据Observable&lt;FidResponseBean&gt; getCacheDataObservable = Observable.create(new ObservableOnSubscribe&lt;FidResponseBean&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;FidResponseBean&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"current thread:\" + Thread.currentThread().getName()); //尝试从缓存弄中拿数据 FidResponseBean cacheData = CacheManager.getInstance().getCache(Network.fid); if (cacheData != null) &#123; isFromNet = false; LogUtil.d(TAG, \"[ subscribe ] \" + \"data from cache\"); runOnUiThread(() -&gt; tv.setText(\"data from: cahce\")); //调用 onNext 方法不会触发下一个 Observable e.onNext(cacheData); &#125; else &#123; isFromNet = true; LogUtil.d(TAG, \"[ subscribe ] \" + \"data from net\"); runOnUiThread(() -&gt; tv.setText(\"data from: net\")); //只有调用 onComplete 之后，才会执行下一个 Observable e.onComplete(); &#125; &#125;&#125;); 从网络拿数据的 Observable 123456//从网络获取数据Observable&lt;FidResponseBean&gt; getNetDataObservable = Network.getFidApi().getFidInfo( Network.name, Network.length, Network.ppfeature); 其中 Network 是封装好的 Retrofit 工具。 API： 1234567public interface FidApi &#123; @GET(\"uploadtest/uptoken\") Observable&lt;FidResponseBean&gt; getFidInfo(@Query(\"name\") String name, @Query(\"length\") String length, @Query(\"ppfeature\")String ppfeature);&#125; 使用 concat 操作符。 1234567891011121314151617181920212223Observable.concat(getCacheDataObservable, getNetDataObservable) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;FidResponseBean&gt;() &#123; @Override public void accept(@NonNull FidResponseBean fidResponseBean) throws Exception &#123; LogUtil.d(TAG, \"[ accept ] \" + \"subscribe success thread:\" + Thread.currentThread().getName()); show.setText(String.format(\"data: %s\", fidResponseBean.toString())); if (isFromNet) &#123; //缓存 CacheManager.getInstance().putCache(fidResponseBean); &#125; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(@NonNull Throwable throwable) throws Exception &#123; LogUtil.d(TAG, \"[ accept ] \" + \"subscribe fail thread:\" + Thread.currentThread().getName() + \"\\n\" + \"e:\" + throwable.toString()); &#125; &#125;); 输出结果： 12345678910//没有缓存的时候01-20 13:58:56.774 6750-7543/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] current thread:RxCachedThreadScheduler-101-20 13:58:56.775 6750-7543/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] data from net01-20 13:58:57.491 6750-6750/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] subscribe success thread:main//有缓存的时候01-20 14:06:32.625 6750-14144/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] current thread:RxCachedThreadScheduler-201-20 14:06:32.625 6750-14144/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] data from cache01-20 14:06:32.627 6750-6750/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] subscribe success thread:main zip关于 zip 操作符，官方的解释图： 另一种解释图： 详细版： 后两张水管图引用自： https://www.jianshu.com/p/bb58571cdb64 有了上面三张图， zip 操作符的作用就很好理解了，就是通过一个函数将多个 Observable 发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个 Observable 一样多的数据。 当然了，还有一些细节上的问题需要注意的，闲先总结： zip 可以将多个 Observable 发送的事件组合在一起，并且基于这个函数的结果，将每一个组合后的事件重新发送出去，并且一个事件只能被组合一次，组合的顺序是严格按照事件发送的顺序来进行的。 最终 Observer 接收到的事件的数量，是 Observable 发送事件最少的哪一个的事件数量。 举个栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 1\"); e.onNext(1); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 2\"); e.onNext(2); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 3\"); e.onNext(3); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 4\"); e.onNext(4); LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 1\"); e.onComplete(); &#125; &#125;); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter a\"); e.onNext(\"a\"); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter b\"); e.onNext(\"b\"); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter c\"); e.onNext(\"c\"); LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 2\"); e.onComplete(); &#125; &#125;); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(@NonNull Integer integer, @NonNull String s) throws Exception &#123; return integer+s; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtil.d(TAG, \"[ onSubscribe ] \"); &#125; @Override public void onNext(String s) &#123; LogUtil.d(TAG, \"[ onNext ] \" + \"s:\" + s); &#125; @Override public void onError(Throwable e) &#123; LogUtil.d(TAG, \"[ onError ] \" + e.toString()); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"[ onComplete ] \"); &#125; &#125;); 代码很简单，一个 Observable 发送 1、2、3、4、onCompele，另外一个 Observab 发送 a、b、c、onComplete。 打印出的结果： 照这个顺序看，似乎是先发送 Observable1 的事件，然后再发送 Observable2 的事件，并且每发送一个 Observable2 的事件就会触发 Observer 做出反应。 那么是不是这样呢？ 我们将每个发送事件的代码都延时 1s ，这里就不贴代码了。 似乎是这样哈？ 但是按照上面的解释图来说，不应该是这样呀，应该是 Observable1 发送一个事件，然后 Observable2 发送一个事件，然后组合了之后，Observer 接收一个事件 才对。 分析一下原因： 目前的代码，Observable1 和 Observable2 发送事件都在同一个线程当中，在同一个线程里代码的执行时有先后顺序的，当然是先执行完 Observable1 发送的所有事件之后，再执行 Observer2 发送的事件，然后组合，然后 Observer 接收。 如果将 Observa1 和 Observa2 发送事件分别放在两个线程当中呢？ 修改一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 1\"); e.onNext(1); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 2\"); e.onNext(2); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 3\"); e.onNext(3); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 4\"); e.onNext(4);//注意这里没有睡 1s LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 1\"); e.onComplete(); &#125; &#125;).subscribeOn(Schedulers.io()); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter a\"); e.onNext(\"a\"); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter b\"); e.onNext(\"b\"); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter c\"); e.onNext(\"c\"); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 2\"); e.onComplete(); &#125; &#125;).subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(@NonNull Integer integer, @NonNull String s) throws Exception &#123; return integer + s; &#125; &#125;) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtil.d(TAG, \"[ onSubscribe ] \"); &#125; @Override public void onNext(String s) &#123; LogUtil.d(TAG, \"[ onNext ] \" + \"s:\" + s); &#125; @Override public void onError(Throwable e) &#123; LogUtil.d(TAG, \"[ onError ] \" + e.toString()); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"[ onComplete ] \"); &#125; &#125;); 跟之前的代码比较，就是将两个 Observab 放在子线程中去执行了。 看看 Log 动态图： 这次的 Log 是不是就比较合理了！两个 Observable 同时开始发送，每发送一个 zip 就会组合一个，然后发送给 Observer，然后当事件少的哪一个 Observab2 发送了 onComplete 之后，虽然 Observable1 还是会继续发送，但是 Obserber 不会接收了。 还有一点要注意的：上面图片中的 红色的框框，会发现并不一定就是 observable1 发一个，然后 Observable2 发送一个，两者可能是交错进行的，这个涉及到某一时刻是哪个线程获取到 cpu 的执行权，所以上面代码多运行几次，log 并不相同，比如还有这种情况： 并且把延迟的代码去掉之后，再看看 log 对的，毫无规律可言，因为当前是哪个线程拿到 cpu 的控制权是不确定的，并且在每一轮当中的时间片长短也有差别，所以日志中会出现这种情况。 这个部分就总结到这了，后面看看背压相关的。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （三） RxJava 最基础的使用","slug":"RxJava3","date":"2018-01-06T08:27:16.000Z","updated":"2018-01-06T09:04:10.179Z","comments":true,"path":"2018/01/06/RxJava3/","link":"","permalink":"http://zengfanyu.top/2018/01/06/RxJava3/","excerpt":"摘要：上一篇理解了概念之后，这里就要用代码来实现以下了，这一篇只涉及到 RxJava 的最基础的用法，不涉及高级特性。","text":"摘要：上一篇理解了概念之后，这里就要用代码来实现以下了，这一篇只涉及到 RxJava 的最基础的用法，不涉及高级特性。 RxJava的基本用法RxJava 的基本实现,总结起来,主要有三点: 创建 Observer 创建 Observable 订阅 创建 Observer 观察者Observer 即观察者,它决定当事件发生的时候,会有怎么样的行为.RxJava 中 Observer 接口的实现方式: 1234567891011121314151617Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了 Observer 接口之外, Rxjava 当中还内置了一个实现了 Observer 接口的抽象类, Subscriber , Subscriber 对 Observer 做了扩展,但是两者的使用方式是完全一样的. 1234567891011121314151617Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 既然 观察者的作用是 决定当事件触发时,会有什么样的行为,那么我们能不能直接有方法定义出行为就可以了呢? 123456789101112131415161718192021222324Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;//Action1接口是RxJava当中定义的,其中只有一个call(T param)方法,这个call方法有1个参数,无返回值Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;//Action0接口是RxJava当中定义的,其中只有一个call()方法,这个call方法无参数无返回值Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, \"completed\"); &#125;&#125;; 至于 onNextAction onErrorAction onCompletedAction 如何使用,为什么几个 Action 就能代表 Subscriber 的 onNext onError onCompleted 方法呢 ? 下面 Subscribe 订阅的时候说. 创建 Observable 被观察者Observable 指的是被观察者,它决定事件什么时候触发,以及触发何种事件. RxJava 用 create() 方法来创建一个 Observable ,并为它定义触发规则. 12345678910Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Java\"); subscriber.onNext(\"C++\"); subscriber.onNext(\"Python\"); subscriber.onCompleted(); &#125;&#125;); 这里参数传入的是 OnSubscribe 对象,这个对象会被存储在 Observable 中,充当一个计划表的角色,具体的计划内容就是 call 方法中的实现. call() 方法的参数 Subscriber 就是观察者,两者关系的建立看下面. 当 Observable 被订阅的时候, OnSubscribe 的 call 方法会被自动调用,然后去执行计划,上面的代码的计划就是执行三次 onNext() ,然后执行一次 onCompleted(). 到这里就实现了事件由被观察者向观察者的传递. 看上面的代码,被观察者的作用就是触发事件,那么可不可以有一种类似于 Java8 当中的便捷构造流的方法一样(Stream.of(T…)),直接将事件按照顺序创建出来就行了?当然有 just(T…) 1234Observable observable = Observable.just(\"Java\", \"C++\", \"Python\");//上述代码等价于创建被观察者,然后依次调用了观察者的 onNext(\"Java\"), onNext(\"C++\"),onNext(\"Python\"),onCompleted() from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 1234String[] words = &#123;\"Java\", \"C++\", \"Python\"&#125;;Observable observable = Observable.from(words);// 效果和上面一样 Subscribe 订阅之前创建了 Observer 和 Observable 之后,就要将两者关联起来了,这就相当于创建了 Button 和 OnClickListener 之后,需要有一个 setOnClickListener 方法,将两者关联起来,这样当 Button 上有点击事件发生的时候,它就回去调用 OnClickListener 的 onClick 方法.这里的 Subscribe 订阅起的作用和 setOnClickListener 是一样的. 123456observable.subscribe(observer);//或者observable.subscribe(subscriber);//这个过程就类似于//button.setOnClickListener(mOnClickListener); Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）: 123456public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 订阅过程做三件事: 调用 subscriber.onStart() 做预处理工作. 调用 onSubscribe.call(subscriber) 方法.(这也就是为什么在上面创建被观察者时,我们说 「当 Observable 被订阅的时候, OnSubscribe 的 call 方法会被自动调用,然后去执行计划.」) 将传入的 subscriber 返回,便于 unSubscribe(). 现在可以说说之前在创建 Observer 时,创建的三个 Action 了. 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。 1234567// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 我们观察可以发现, Subscriber 的 onNext , onError 方法的返回类型是 void , 并带有一个参数,分别是 String , Throwable 而 Action1 接口里面的 call 方法也是有一个参数 T ,返回类型是 void. Subscriber 的 onCompleted 方法的返回类型是 void, 没有参数,而 Action0 接口里的 call 方法也是没有参数的, 并且返回值为 void. 这么一总结,上面这个操作是不是就像 java8 当中的 lamuda 表达式了 ? 我在学习lambda表达式时总结的一篇文章 123456789101112//Before Java8mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; System.out.println(\"Button clicked!\"); &#125; &#125;);//In java8 way mButton.setOnClickListener((v)-&gt; &#123; System.out.println(\"Button clicked!\"); &#125;); 注意看下面的 lambda 表达式中的 (V) ,这里的 v 形参, 就是代表的是上面回调方法中的 view ,后面的 -&gt;System.out.println(“Button clicked!”) ,就是用于定义 onClick() 的方法体的. 确实类似,这里相当于其他语言中的 「闭包」. 到这里,就已经说完了 RxJava 当中最基础的三个角色了. 那么也可以简单的使用一下啦. 简单使用1)打印一串字符串 12345678Observable.just(\"Java\",\"C++\",\"Python\") .subscribe(new Action1&lt;String&gt;()&#123; @override public void call(String languageName)&#123; log.d(\"RxJava\",\"languageName\"); &#125; &#125;) 2)根据 drawable 资源名, 取出 drawable,然后显示到 imageView 上. 12345678910111213141516171819202122232425int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （二） 从概念上理解 RxJava","slug":"RxJava2","date":"2018-01-06T08:27:15.000Z","updated":"2018-01-06T09:23:54.313Z","comments":true,"path":"2018/01/06/RxJava2/","link":"","permalink":"http://zengfanyu.top/2018/01/06/RxJava2/","excerpt":"摘要：一开始学习 RxJava ，觉得这东西特抽象，不好把握，但是在阅读了一些文章之后，也逐渐对 RxJaba 在宏观上有一个大概的认识，这一篇就记录一下我对 RxJava 最基础的理解。","text":"摘要：一开始学习 RxJava ，觉得这东西特抽象，不好把握，但是在阅读了一些文章之后，也逐渐对 RxJaba 在宏观上有一个大概的认识，这一篇就记录一下我对 RxJava 最基础的理解。 RxJava 是什么想要知道 RxJava 是什么，当然还是要去看看 RxJava 在 Github 上面的主页，毕竟官方的介绍是最准确的。 RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM. 对，这就是官方对 RxJava 的解释，翻译一下：RxJava—JVM的反应式扩展。 是一个使用可观测的序列来组成异步的，基于事件序列的库。这么一说，我还是不能理解这个库到底是干嘛的，毕竟这是官方站在一定的高度上对 RxJava 的总结，就类似于在 Java 中的一句话：Everything is objects，刚开始接触 Java 时肯定也无法理解这句话的意思 。 既然官方的解释对于初学者的我来说这么难懂，那就先看看 Rx 是什么意思吧。Rx—全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。 这么一捋之后，我似乎有一点点理解了，它完成的功能似乎就是和 Google 官方的 AsyncTask Handler 类似，解决异步问题的，但是为什么大家都用它而不去使用 AsyncTask Handler 呢？ 这些也都是解决异步的呀？ 答案是：简洁，逻辑上的简洁。 所以这里就一句话，RxJava 是用一种扩展的观察者模式解决异步问题的基于事件序列的库。 所以我就从观察者模式开始学习了。 观察者模式那就要先说说观察者模式了。 打个比方来说，我们公司外面的馄饨店，每天中午好多人都回去哪里吃馄饨，大家过去了之后「点了一碗馄饨并付账」，就坐在那里等着老板叫号了。老板一叫：25号鲜肉小馄饨好了，那么一哥们听到之后，就立马「屁颠颠的跑过去端回来吃」，老板又叫：28号荠菜大馄饨好了，一妹子又「屁颠颠的跑过去端回来吃」。这个过程就是一个观察者模式。 这里涉及到三个对象，观察者：坐着等馄饨的吃货们。被观察者：馄饨店老板。订阅关系：点了一碗馄饨并付账。 还涉及到一个具体的反应过程：「屁颠颠的跑过去端回来吃」。 图解： 再说说在 Android 开发中会经常接触到的观察者模式，对一个 Button 的监听。Button 是被观察者，OnClickListener 是观察者，两者通过 setOnClickListener 方法达成订阅关系，那么此时 OnClickListener 就对 Button 的点击事件高度敏感了，只要 Button 以被用户点击，那么 OnClickListener 就会“立马”（这个立马，要打个引号，应为这里还涉及到事件的分发过程，不展开说了）做出反应，也就是调用它的 onClick 方法。 图解： 其实上面两个过程我们也可以这样理解，观察者和被观察者之间先有订阅关系，然后被观察者发出了一个事件，然后观察者接收到这个事件之后，做出了响应。 在从事件出发的角度捋捋上面两个过程： 吃货去馄饨店里「点了一碗馄饨并付账」，那么就订阅了馄饨店老板发出的 HuntunReady 事件。当馄饨店老板发出了一个 HuntunReady 的事件（图中没有画出）的时候，吃货A接收到这个事件并做出反应，也就是调用了 onHuntunReady 方法去处理,具体的处理逻辑就是：「屁颠颠的跑过去端回来吃」（图中也没有画出）。 OnClickListener 通过 setOnclickListener 订阅 Button 的 Click 事件，当Button 发出了一个 Click 的事件， OnClickListener 接受到了这个事件，就要做出了反映，也就是调用 onClick 方法，执行当中的逻辑。 对照表： 那么我们把这个概念抽象为观察者，被观察者，订阅，那么图应该是这样的： RxJava 当中的观察者模式有了上面两个例子的铺垫，这里就推导出，RxJava 就是 Observer 和 Observable 两者先发生订阅关系，然后 Observable 发出事件序列，Observer 接受事件并响应处理。 但之前又说到 RxJava 使用的是一种扩展的观察者模式，那么跟上面两个例子中肯定是有不同的。它扩展之后的形式如下： 区别（一）看的出来， RxJava 中的观察者模式跟传统观察者模式比起来，事件的回调方法除了普通事件 onNext（相当于上面例子中的 onClick 和 onHuntunReady）之外，还定义了两个特殊的事件， onCompleted()， onError(); 这三个事件遵从一定的规则： Observable 可以发送无限个 onNext 事件，Observer 可以接受无限个 onNext 事件。 当 Observable 发送了 onCompleted 或者 onError 序列之后，之后的事件序列仍然会发送，但是 Observer 这边在接收到 onCompleted 或者 onError 事件之后，是不会在继续接收之后的事件序列的。 Observable 可以不发送 onCompleted 或者 onError 事件。 onCompleted 和 onError 事件必须互斥。也就是说在一个事件序列中，要么是没有 onCompleted 和 onError 事件，要么有且只能有其中一个。 区别（二）就是 Observable 在发送事件到 Observer 的过程中，多了一个 Operate 过程，这个操作就是对事件进行一系列的处理，然后再发送至 Observer。要说到这个操作就不得不提 Java8 当中的 Stream 和它对其中每一个元素进行的函数式操作。 我们用“过滤”这个操作来打个比方， 就像下面这幅图中画的那样，我有一杯混合着大大小小石子的蓝色的水。 现在按照我们关于“流”的定义，我用下图中的方法将水转化成“流”。 为了让水变成水流，我把水从一个杯子倒进另一个杯子 里。现在我想去掉水中的大石子，所以我造了一&gt; 个可以帮我滤掉大石子的过滤器。“大石子过滤器”如下图所示。 现在，将这个过滤器作用在水流上，这会得到不包含大石子的水。如下图所示。 接下来，我想从水中清除掉所有石子。已经有一个过滤大石子的过滤器了，我们需要造一个新的来过滤&gt;小石子。“小石子过滤器”如下图所示。 像下图这样，将两个过滤器同时作用于水流上。 接下来，我想把水的颜色从蓝色变成黑色。为了达到这个目的，我需要造一个像下图这样的“水颜色转换器（mapper）”。 像下图这样使用这个转换器。 把水转换成水流后，我们做了很多事情。我先用一个过滤器去掉了大石子，然后用另一个过滤器去掉了&gt;小石子， 最后用一个转换器（map）把水的颜色从蓝色变成黑色。 这个过程就是 Java8 当中对流的操作的一个具体的体现。 好了，现在可以回到 Rxjava 当中了。 RxJava 当中的 operate 过程也类似于上面的过滤过程，在 Observable 发出事件之后，可以利用「操作符」对事件进行一系列的操作，包括但不仅仅局限于 “过滤”、“合并”、“线程切换”等等，得到我们最终想要的“过滤”后的事件。 恩，这就是 RxJava 当中最基础的东西了，先对 RxJava 有一个宏观上的认识，后面才好继续学习。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （一）","slug":"Rxjava1","date":"2018-01-04T13:27:15.000Z","updated":"2018-01-06T08:47:39.021Z","comments":true,"path":"2018/01/04/Rxjava1/","link":"","permalink":"http://zengfanyu.top/2018/01/04/Rxjava1/","excerpt":"","text":"前言年关将近,部门里任务也多了起来,最近一个月多都在忙着部门项目,因为突然接手了三个项目,虽然已经开发了一个版本,但是我还是花了很多时间去消化现有的版本,然后接着迭代开发,昨天上线了,现在有了空余的时间,准备接着写博客了。 之前在写 MVP 系列第一篇文章的时候就立了一个 Flag， 要学习 MVP、okHttp、Rxjava、Retrofit2、Dagger2，然后用这些流行开源框架撸一个 APP。现在 MVP 系列算是有了基础的了解了，并在学 MVP 的时候，把 OkHttp 也封装着在 Model 层使用，Retrofit2 也零零散散看过一些 Demo ，Dagger2 之前也总结了一篇文章 Dagger2基础内容归纳。剩下比较难啃的就是 RxJava了。这个任务已经被我添加到我 2018 年的计划当中了。 在两年前刚开始接触到 RxJava 的时候，是被它的链式调用所吸引，子线程操作、主线程操作、线程切换、事件变换在链式调用里一气呵成，再也看不到 AsyncTask 中繁琐的各种方法，同时也被它的各种高级特性所迷惑，各种操作符，各种闭包特性。之前在学校里的时候就看过「扔物线」大神的经典入门文章给 Android 开发者的 RxJava 详解 ，但是当时忙于找工作、实习，之后忙着毕业论文、毕业疯，一直没有好好实践，现在准备好好学习一下时发现，已经到了 RxJava2 的时代了，之前「扔物线」大神的那篇是基于 Rxjava1 写的，是先学学 RxJava1 再去学习 2 好呢，还是直接去学习 2 ，思来想去感觉这个问题就像： 学习 java 之前要先学习 C 吗？ 抛开别的不说，「扔物线」的那篇入门文章是质量是相当高的，深入浅出，对于我这样的初学者来说，学习的价值是十分大的，然后在看完这篇 RxJava2 vs RxJava1 对比的文章之后，我觉得还是很有必要去了解一下 Rxjava1 的，这样才能知道 2 改进在哪里，为什么这么改进， 是因为 1 中使用有什么问题。 并且后来在学习了 java8 当中的 Lambda 以及 Streams 之后发现，RxJava 当中很多实现都和其十分相似，比如说「闭包」特性的体现，和 Stream 当中对元素的挨个处理再返回，以及函数式编程的思想。 刚接触RxJava的情景还原说说最开始接触到 RxJava 的代码吧，应该是 2016 年的某一天。 一开始看到的是下面这两段代码： 12345678910111213141516171819202122232425//被观察者Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext(\"Hello, world!\"); sub.onCompleted(); &#125; &#125;);//观察者Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125;&#125;;//订阅myObservable.subscribe(mySubsciber); 好了，一个简单的使用 RxJava 的代码就完成了，最初我看到这段代码，心中就是 打印一个字符串搞这个复杂？？ 这是靠代码量算工资吗？？？ 后来人家说，上面那样写太复杂了，正确姿势： 12345678Observable.just(\"Hello, world!\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;); 人家说这样跟上面那一梭代码功能是一样的。 后来又有人说，这还是太复杂，要简化一下： 123Observable.just(\"Hello, world!\") .subscribe(s -&gt; System.out.println(s)); 我的内心： 之后我知道，原来这段单代码使用了 Java8 Lambda 表达式，利用函数式编程的优势，简化了程序中余的代码，所以在学习 RxJava 之前我应该先去学习一下 Java8 lambda 。总结文章：新姿势学习之Java8—Lambda Expressions。 我以为这就行了，但是接下来看到的代码更是让我更加坚定。。。 要想在 Subscriber 当中打印出 Observable 发送出来的每一个字符串后面加上 &quot;-ZFY&quot;: 123456789Observable.just(\"Hello, world!\") .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s + \" -ZFY\"; &#125; &#125;) .subscribe(s -&gt; System.out.println(s)); 同样的用 Lambda 简化； 1234Observable.just(\"Hello, world!\") .map(s -&gt; s + \" -ZFY\") .subscribe(s -&gt; System.out.println(s)); 然后我突然又想输出 接受的字符串拼接上”-ZFY” 的HashCode 的字符串， 那么可以这样： 12345Observable.just(\"Hello, world!\") .map(s -&gt; s.hashCode()) .map(i -&gt; Integer.toString(i)) .subscribe(s -&gt; System.out.println(s)); 到这里还没有涉及到线程切换的问题，还没有涉及到和 Retrofit 配合使用，虽然那时候我都不知道 这个 map 是干嘛的，总之觉得这个操作很 NB ，但是单单就上面那些特性，就足以对我产生强大的吸引力。 就在这一刻，我决定，Lambda 、Stream、函数式编程、RxJava 我也要学，我也要写出上面那样简洁高效的代码。 这就是我刚看到 RxJava 的情景。 到现在 Java8 Lambda Stream 函数式编程这些相关的， 我已经学习了一阵子了，该开始 RxJava 了。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"一口一口啃完Java中的24种设计模式---桥接模式","slug":"桥接模式","date":"2018-01-04T08:27:16.000Z","updated":"2018-01-06T09:23:45.290Z","comments":true,"path":"2018/01/04/桥接模式/","link":"","permalink":"http://zengfanyu.top/2018/01/04/桥接模式/","excerpt":"","text":"问题引入:蜡笔与毛笔在正式介绍桥接模式之前，先谈谈两种常见文具的区别，它们是毛笔和蜡笔。假如我们需要大中小 3 种型号的画笔，能够绘制 12 种不同的颜色，如果使用蜡笔，需要准备 3×12 = 36 支，但如果使用毛笔的话，只需要提供 3 种型号的毛笔，外加 12 个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与 36 支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有 12 种颜色，对应的蜡笔需增加 12 支，而毛笔只需增加一支。为什么会这样呢？通过分析我们可以得知：在蜡笔中，颜色和型号两个不同的变化维度（即两个不同的变化原因）融合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方都没有任何影响。如果使用软件工程中的术语，我们可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也更为方便。在软件开发中，我们也提供了一种设计模式来处理与画笔类似的具有多变化维度的情况. 跨平台图像浏览系统开发一个跨平台图像浏览系统，要求该系统能够显示 BMP、JPG、GIF、PNG 等多种格式的文件，并且能够在 Windows、Linux、Unix 等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵（Matrix），然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。系统需具有较好的扩展性以支持新的文件格式和操作系统。 某公司的开发人员针对上述要求，提出了一个初始设计方案，其基本结构如图所示： 在图的初始设计方案中，使用了一种多层继承结构，Image 是抽象父类，而每一种类型的图像类，如 BMPImage、JPGImage 等作为其直接子类，不同的图像文件格式具有不同的解析方法，可以得到不同的像素矩阵；由于每一种图像又需要在不同的操作系统中显示，不同的操作系统在屏幕上显示像素矩阵有所差异，因此需要为不同的图像类再提供一组在不同操作系统显示的子类，如为 BMPImage 提供三个子类 BMPWindowsImp、BMPLinuxImp 和 BMPUnixImp，分别用于在 Windows、Linux 和 Unix 三个不同的操作系统下显示图像。 我们现在对该设计方案进行分析，发现存在如下两个主要问题： (1)由于采用了多层继承结构，导致系统中类的个数急剧增加，图中，在各种图像的操作系统实现层提供了12个具体类，加上各级抽象层的类，系统中类的总个数达到了 17 个，在该设计方案中，具体层的类的个数 = 所支持的图像文件格式数×所支持的操作系统数。 (2)系统扩展麻烦，由于每一个具体类既包含图像文件格式信息，又包含操作系统信息，因此无论是增加新的图像文件格式还是增加新的操作系统，都需要增加大量的具体类，例如在图中增加一种新的图像文件格式 TIF，则需要增加 3 个具体类来实现该格式图像在3种不同操作系统的显示；如果增加一个新的操作系统 Mac OS，为了在该操作系统下能够显示各种类型的图像，需要增加 4 个具体类。这将导致系统变得非常庞大，增加运行和维护开销。 如何解决这两个问题？我们通过分析可得知，该系统存在两个独立变化的维度：图像文件格式和操作系统，如图所示： 在图中，如何将各种不同类型的图像文件解析为像素矩阵与图像文件格式本身相关，而如何在屏幕上显示像素矩阵则仅与操作系统相关。正因为图所示结构将这两种职责集中在一个类中，导致系统扩展麻烦，从类的设计角度分析，具体类 BMPWindowsImp、BMPLinuxImp 和 BMPUnixImp 等违反了“单一职责原则”，因为不止一个引起它们变化的原因，它们将图像文件解析和像素矩阵显示这两种完全不同的职责融合在一起，任意一个职责发生改变都需要修改它们，系统扩展困难。 如何改进？我们的方案是将图像文件格式（对应图像格式的解析）与操作系统（对应像素矩阵的显示）两个维度分离，使得它们可以独立变化，增加新的图像文件格式或者操作系统时都对另一个维度不造成任何影响。看到这里，大家可能会问，到底如何在软件中实现将两个维度分离呢？这里就可以使用 桥接模式. 处理多维度变化——桥接模式概述桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。 桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下： 桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体（Handle and Body）模式或接口（Interface）模式。 角色关系桥接模式的结构与其名称一样，存在一条连接两个继承等级结构的桥，桥接模式结构如图所示： 在桥接模式结构图中包含如下几个角色： Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个 Implementor（实现类接口）类型的对象并可以维护该对象，它与 Implementor 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。 RefinedAbstraction（扩充抽象类）：扩充由 Abstraction 定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在 Abstraction 中声明的抽象业务方法，在 RefinedAbstraction 中可以调用在 Implementor 中定义的业务方法。 Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor 接口仅提供基本操作，而 Abstraction 定义的接口可能会做更多更复杂的操作。Implementor 接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用到 Implementor 中定义的方法，使用关联关系来替代继承关系。 ConcreteImplementor（具体实现类）：具体实现 Implementor 接口，在不同的 ConcreteImplementor 中提供基本操作的不同实现，在程序运行时，ConcreteImplementor 对象将替换其父类对象，提供给抽象类具体的业务操作方法。桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。 简单实现在使用桥接模式时，我们首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，我们将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此我们可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。在此，型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分，结构示意图如图所示： 在图中，如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。 在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了使两者之间耦合度降低，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分”维度，典型的实现类接口代码如下所示： 1234 interface Implementor &#123; public void operationImpl(); &#125; 在实现 Implementor 接口的子类中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法。对于另一“抽象部分”维度而言，其典型的抽象类代码如下所示： 12345678910abstract class Abstraction &#123; protected Implementor impl; //定义实现类接口对象 public void setImpl(Implementor impl) &#123; this.impl=impl; &#125; public abstract void operation(); //声明抽象业务方法 &#125; 在抽象类 Abstraction 中定义了一个实现类接口类型的成员对象 impl，再通过注入的方式给该对象赋值，一般将该对象的可见性定义为 protected，以便在其子类中访问 Implementor 的方法，其子类一般称为扩充抽象类或细化抽象类（RefinedAbstraction），典型的 RefinedAbstraction 类代码如下所示： 12345678 class RefinedAbstraction extends Abstraction &#123; public void operation() &#123; //业务代码 impl.operationImpl(); //调用实现类的方法 //业务代码 &#125; &#125; 对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。 适用范围 一个类存在两个或者以上的维度独立变化,并且这两个维度都需要扩展. 不希望使用继承或者因为多层次继承而导致整个系统类个数急剧增加的系统. 如果一个系统需要在构建的抽象画角色和具体化角色之间增加更多的灵活性,避免在两个层次之间建立静态的继承联系,可以通过桥接模式使它们在抽象层建立一个关联关系. 任何多维度之间的耦合都可以用桥接模式来解耦. 桥接模式在跨平台图片浏览系统中的应用为了减少所需生成的子类数目，实现将操作系统和图像文件格式两个维度分离，使它们可以独立改变，Sunny 公司开发人员使用桥接模式来重构跨平台图像浏览系统的设计，其基本结构如图所示： 代码实现: 像素矩阵类123456//像素矩阵类：辅助类，各种格式的文件最终都被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵class Matrix &#123; //此处代码省略&#125; 抽象图像类(其中一个变化维度)123456789101112131415/** * 抽象图像类 * * @author: fanyuzeng on 2018/1/4 14:46 */public abstract class Image &#123; protected IOperatorSystem os; public void setOS(IOperatorSystem os) &#123; this.os = os; &#125; public abstract void praseFileIntoImage(String filePath);&#125; 扩充图像类123456789101112131415161718/** * BMP格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:57 */public class BMPImage extends Image &#123; private static final String TAG = \"==BMPImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \",格式为:BMP\"); &#125;&#125; 123456789101112131415161718/** * GIF格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:58 */public class GIFImage extends Image &#123; private static final String TAG = \"==GIFImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \",格式为:GIF\"); &#125;&#125; 123456789101112131415161718/** * JPG格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:56 */public class JPGImage extends Image &#123; private static final String TAG = \"==JPGImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \"格式为:JPG\"); &#125;&#125; 123456789101112131415161718/** * PNG格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:51 */public class PNGImage extends Image &#123; private static final String TAG = \"==PNGImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \",格式为:PNG\"); &#125;&#125; 抽象操作系统接口(另外一个变化维度)123456789101112 /** * @author: fanyuzeng on 2018/1/4 14:48 */ public interface IOperatorSystem &#123; /** * 各个操作系统自带的将像素矩阵显示到屏幕上的方法 * * @param m 像素矩阵 */ void showImage(Matrix m);&#125; 具体操作系统实现类12345678910111213/** * Linux 操作系统 * * @author: fanyuzeng on 2018/1/4 15:02 */public class LinuxOS implements IOperatorSystem &#123; private static final String TAG = \"==LinuxOS==\"; @Override public void showImage(Matrix m) &#123; System.out.print(\"[showImage] \" + \"在Linux操作系统中显示像素矩阵 \"); &#125;&#125; 1234567891011121314/** * Unix 操作系统 * * @author: fanyuzeng on 2018/1/4 15:02 */public class UnixOS implements IOperatorSystem &#123; private static final String TAG = \"==UnixOS==\"; @Override public void showImage(Matrix m) &#123; System.out.print(\"[showImage] \" + \"在Unix操作系统中显示像素矩阵 \"); &#125;&#125; 123456789101112/** * Window操作系统 * @author: fanyuzeng on 2018/1/4 15:01 */public class WindowsOS implements IOperatorSystem &#123; private static final String TAG = \"==WindowsOS==\"; @Override public void showImage(Matrix m) &#123; System.out.print(\"[showImage] \" + \"在Windows操作系统中显示像素矩阵 \"); &#125;&#125; 测试类1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; Image image1=new JPGImage(); image1.setOS(new WindowsOS()); image1.praseFileIntoImage(\"e:/pic/image1\"); System.out.println(\"===============================\"); Image image2=new GIFImage(); image2.setOS(new WindowsOS()); image2.praseFileIntoImage(\"e:/pic/image2\"); System.out.println(\"===============================\"); Image image3=new BMPImage(); image3.setOS(new LinuxOS()); image3.praseFileIntoImage(\"e:/pic/image3\"); System.out.println(\"===============================\"); Image image4=new PNGImage(); image4.setOS(new UnixOS()); image4.praseFileIntoImage(\"e:/pic/image4\"); &#125;&#125; 输出12345678[showImage] 在Windows操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image1格式为:JPG===============================[showImage] 在Windows操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image2,格式为:GIF===============================[showImage] 在Linux操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image3,格式为:BMP===============================[showImage] 在Unix操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image4,格式为:PNG 扩展假设此时又需要支持一个 tiff 格式的图片,并且还要支持 MacOS,在这种模式下只需要继续在 Image 和 IOperatorSystem 下继续扩展和实现即可,大大提升了系统的可扩展性,降低了耦合性 Demo地址https://github.com/zengfanyu/23DesignPatterns","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/tags/Design-Patterns/"}]},{"title":"Android中的Window、WindowManager以及悬浮框视频播放的实现","slug":"FloatWindow","date":"2018-01-02T13:27:15.000Z","updated":"2018-01-06T04:15:32.416Z","comments":true,"path":"2018/01/02/FloatWindow/","link":"","permalink":"http://zengfanyu.top/2018/01/02/FloatWindow/","excerpt":"摘要:近日看公司直播项目,其中有一个功能就是退出某房间之后,直播界面会以悬浮窗的形式出现,并且可以拖动悬浮窗到界面中任意位置,点击悬浮框之后,又可以回到房间中继续观看直播。现在这个功能在主流的直播或者视频类软件中都可以看到，比如：某鱼、某猫、某珠、某牙、某tube。当然了，某tobe当中的悬浮窗效果更佳炫酷，可以炫酷地从悬浮框中将视频主界面慢慢拖动出来，具体效果下载某tube就能看到。这篇文章就记录一下传统悬浮窗播放视频的原理，以及悬浮框涉及到的 Window 和 WindowManager 的相关知识。","text":"摘要:近日看公司直播项目,其中有一个功能就是退出某房间之后,直播界面会以悬浮窗的形式出现,并且可以拖动悬浮窗到界面中任意位置,点击悬浮框之后,又可以回到房间中继续观看直播。现在这个功能在主流的直播或者视频类软件中都可以看到，比如：某鱼、某猫、某珠、某牙、某tube。当然了，某tobe当中的悬浮窗效果更佳炫酷，可以炫酷地从悬浮框中将视频主界面慢慢拖动出来，具体效果下载某tube就能看到。这篇文章就记录一下传统悬浮窗播放视频的原理，以及悬浮框涉及到的 Window 和 WindowManager 的相关知识。 Window 和 WindowManager 概述Window 表示一个窗口的概念，在日常开发中直接接触到 Window 的机会并不多，但是在某些特殊的时候，我们需要在桌面上显示一个类似悬浮框的东西（360的小火箭、360手机助手最新版当中桌面上显示的枫叶），那么这种效果就需要用 Window 来实现。Window 是一个抽象类，它的具体实现类是 PhoneWindow，创建一个 Window 跟简单，只需通过 WindowManager 即可完成。WindowManager 是完结访问 Window 的入口，Window 的具体实现位于 WindowManagerService 中，WindowManager 和 Window 打交道是一个 IPC 过程。Android 中的所有视图都是通过 Window 来呈现的，不管是 Activity 、 Dialog 还是 Toast，他们的实际视图都是附加在 Window 上的，因此，Window 实际是 View 的直接管理者。比如说，在事件分发的过程中，点击事件首先是由 Window 传递给 DecorView，然后再由 DecorView 往子 View 分发，最终分发到能够消耗这个点击事件的 View 当中；并且 Activity 生命周期方法 onCreate 中经常调用的 setContentView 方法底层也是通过 Window 来完成的。 创建一个 Window上面概述中提到，要想创建一个 Window ，只需通过 WindowManager 即可实现。 12345678910111213public void addWindow()&#123; Button button = new Button(getApplicationContext()); button.setText(\"动态添加\"); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; layoutParams.gravity = Gravity.LEFT | Gravity.TOP; layoutParams.x= 600; layoutParams.y= 600; getWindowManager().addView(button, layoutParams); &#125; 上面的代码就将一个 Button 添加到屏幕上 （600,600） 的位置，对 WindowMnager.Layoutparams 常用参数做说明： 12public LayoutParams(int w, int h, int xpos, int ypos, int _type,int _flags, int _format) &#123; w ,h 表示 Window 的宽高，可以通过构造方法传入，也可以在创建好 WindowManager.Layoutparams 之后，直接给其 width ，height 成员变量赋值。 xpos，ypos 表示 Window 在手机屏幕上的绝对位置，与 w，h 一样，这两个值也可以在实例化 WindowManager.Layoutparams 之后给 x，y 成员变量属性赋值，要向更改悬浮窗的位置，就是改变的这两个参数 _type 表示的是 Window 的类型，Window 有三种类型： 应用 Window ，这个 Window 对应着一个 Activity，层级范围（1~99） 子 Window ， 不能单独存在，它需要附属在一个特定的父 Window 中，比如说 Dialog ，层级范围（1000~1999） 系统 Window ，这是需要申明权限才能够创建的 Window， 比如说常用的 Toast ,层级范围（2000~2999）。 TYPE_SYSTEM_OVERLAY（2006），TYPE_TOAST（2005），TYPE_PHONE（2002） Flags 参数表示 Window 的属性，它可以有很多选项，通过这些选项可以控制 Window 的显示特性，比较常用的有： 1. FLAG_NOT_FOCUSABLE 表示 Window 不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用 FLAG_NOT_TOUCH_MODE，事件会直接传递给下层的具有焦点的 Window。 2. FLAG_NOT_TOUCH_MODE 此模式下,系统会将当前 Window 区域以外的点击事件传递给底层的 Window ，当前 Window 区域以内的会自己处理，一般来说这个标记都需要开启，不然其他的 Window 接收不到单击事件。 3. FLAG_SHOW_WHEN_LOCKED 让 Window 显示在锁屏界面上。 WindowManager 常用的方法就三个：添加 View，删除 View，更新 View 。这三个方法定义在 ViewManager 中，WindowManager 继承了 ViewManager。想做悬浮窗播放视频，就需要用到这三个方法，其中悬浮框随手指拖拽而移动就是在 onTouchEvent 回调中调用 updateView 的方法。 123456789101112public interface ViewManager&#123; public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params); public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params); public void removeView(View view);&#125; 悬浮框实现要点 WindowManager 和 Window 相关，用于展示悬浮框。 要实现悬浮框，那么就会涉及到权限问题，从 Andtoid 6.0 开始，需要在运行时去获取悬浮窗的权限。 启动悬浮窗的组件（Activity 或者 Fragment or else）在启动了悬浮窗之后，自己本身肯定是要关闭的，所以这里悬浮框就很适合在 Service 中管理。 悬浮窗一般是可以与用户交互的，那么这里就会涉及到触摸反馈。 后续代码前提 播放器播放需要一个 m3u8 url,公司自研播放器代码不贴出。 当前 WatchVideoActivity 正在全屏播放，此时点击了“悬浮窗播放”按钮。 这里的悬浮窗播放指的是点播,非直播情况 清单文件中的权限12&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt; 检查权限并启动Service1234567891011121314151617181920212223//悬浮窗播放按钮 final Button button_litter_player = (Button) findViewById(R.id.button_litter_player); button_litter_player.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //此处为检查用户是否已经授权我们的应用悬浮窗权限 boolean check = ConstInfo.hasPermissionFloatWin(getApplicationContext()); if (!check) &#123; Toast.makeText(getApplication(), \"悬浮窗权限未打开，请去打开应用悬浮窗权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //FloatWindowService 就是用于管理悬浮窗的 Service Intent intent = new Intent(WatchVideoActivity.this, FloatWindowService.class); Bundle bundle = new Bundle(); //当前播放视频的m3u8地址 bundle.putString(\"m3u8Url\", getCurrentUrl()); //主要是记录当前播放的位置,这样在悬浮窗出现后,可以接着之前全屏播放的点继续播放 bundle.putInt(EXTRA_VIDEO_CURRENT_POSITION, mVideoView.getCurrentPosition()); finish(); &#125; &#125; &#125;); 其中检查权限的方法是发射调用: 1234567891011121314151617181920212223242526/** * 判断是否开启浮窗权限,api未公开，使用反射调用 * @return */public static boolean hasPermissionFloatWin(Context context) &#123; Log.d(ConstInfo.TAG, \"hasAuthorFloatWin android.os.Build.VERSION.SDK_INT=\"+android.os.Build.VERSION.SDK_INT); if (android.os.Build.VERSION.SDK_INT &lt; 19) &#123; return true; &#125; try &#123; AppOpsManager appOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); Class c = appOps.getClass(); Class[] cArg = new Class[3]; cArg[0] = int.class; cArg[1] = int.class; cArg[2] = String.class; Method lMethod = c.getDeclaredMethod(\"checkOp\", cArg); //24是浮窗权限的标记 return (AppOpsManager.MODE_ALLOWED == (Integer) lMethod.invoke(appOps, 24, Binder.getCallingUid(), context.getPackageName())); &#125;catch(Exception e)&#123; return false; &#125;&#125; FloatWindowService Service 详情戳 Android Developer # Service Guide Service 的 onCreate 方法只会在 Service 首次创建的时候调用一次,所以在这个方法中创建悬浮框的实例比较适合,因为只支持一个悬浮窗 onStartCommond 方法在每次调用 startService 方法时都会调用,所以在这个方法中适合检查悬浮窗的状态,比如:是否需要退出悬浮窗,还是直接开始在悬浮窗中继续播放等等. onDestroy 方法中就直接销毁悬浮窗实例即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class FloatWindowService extends Service &#123; private static final String TAG = \"==FloatWindowService==\"; public static final String ACTION_PLAY = \"com.xxxx.testxxxsdk.FloatWindowService.ACTION_PLAY\"; public static final String ACTION_EXIT = \"com.xxxx.testxxxsdk.FloatWindowService.ACTION_EXIT\"; public static final String PLAY_TYPE = \"com.xxxx.testxxxsdk.FloatWindowService.PLAY_TYPE\"; public static final String EXTRA_VIDEO_LIST = \"list\"; //用于标记当前悬浮窗时候已经显示 public static boolean mIsFloatWindowShown = false; //悬浮窗实例 private FloatWindow mFloatWindow; @Override public void onCreate() &#123; super.onCreate(); LogUtil.d(TAG,\"[onCreate] \" + \"FloatWindowService onCreate\"); //这里将Service本身传入悬浮窗,是为了实现点击悬浮窗重新进入WatchVideoActivity 全屏播放,且提供 Context, mFloatWindow = new FloatWindow(this); mFloatWindow.createFloatView(); mIsFloatWindowShown = true; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; LogUtil.d(TAG, \"[onStartCommand] \" + \"FloatWindowService onStart\"); //此处为特殊逻辑处理,和项目需求相关,不做解释 if (intent.hasExtra(ACTION_EXIT)) &#123; stopSelf(); &#125; else &#123; //在这里就拿到之前点击悬浮窗按钮时传递过来的数据,包括播放m3u8地址和当前播放位置等 Bundle bundle = intent.getBundleExtra(ACTION_PLAY); if (bundle != null &amp;&amp; mFloatWindow != null) &#123; LogUtil.d(TAG,\"[onStartCommand] \" + \"FloatWindowService onStart play bundle\"); //将bundle数据交给悬浮窗控件本身去处理 mFloatWindow.play(bundle); &#125; &#125; return START_STICKY; &#125; @Override public void onDestroy() &#123; super.onDestroy(); LogUtil.d(TAG,\"[onDestroy] \" +\"FloatWindowService onDestroy\" ); if (mFloatWindow != null) &#123; mFloatWindow.destroy(); &#125; mIsFloatWindowShown = false; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 上述代码可以看到,Service 在这里就是管理了悬浮窗的生命周期,以及传递数据的作用. FloatWindow这是悬浮窗的实现类,之前的代码在”悬浮播放”这一功能来说,都是铺垫. 参照文章前面对 WindowManager 的描述,这里肯定也会涉及到悬浮窗参数和悬浮窗布局,以及悬浮窗的交互. 首先是布局,这列悬浮窗比较简单 top_window_player: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout android:id=\"@+id/root_view\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@drawable/top_window_player_bg\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:padding=\"10dp\" android:src=\"@drawable/logo\" /&gt; &lt;ProgressBar android:id=\"@+id/progressbar_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:indeterminateDrawable=\"@anim/loading_anim\" android:visibility=\"gone\" /&gt; &lt;com.xxxxxx.xxxsdk.XXXVideoView android:id=\"@+id/live_player_videoview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_centerInParent=\"true\" android:visibility=\"gone\"/&gt; &lt;ImageButton android:id=\"@+id/lsq_closeButton\" android:layout_width=\"20dp\" android:layout_height=\"20dp\" android:layout_alignParentRight=\"true\" android:background=\"@drawable/close_small\" android:paddingRight=\"5dp\" android:paddingTop=\"5dp\"/&gt;&lt;/RelativeLayout&gt; ImageView 是用于展示默认状态图,ImageButton 为右上角叉叉,XXXVideoView 为自研的播放器,这里就不贴出代码了. 构造方法 这里将 Service 本身传入悬浮窗,是为了实现点击悬浮窗重新进入 WatchVideoActivity 全屏播放, 提供 Context 绑定两者生命周期,即悬浮窗销毁时,服务就要停止 123456public FloatWindow(Service hostService)&#123; mHostService = hostService; mAppContext = mHostService.getApplication();&#125; createFloatView() 真正创建 Window 的方法 这个方法中做 3 件事 : 使用 WindowManager 创建 Window 布局控件初始化 触摸反馈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 public void createFloatView() &#123; wmParams = new WindowManager.LayoutParams(); mWindowManager = (WindowManager) mAppContext.getSystemService(mAppContext.WINDOW_SERVICE); //即使应用退出,悬浮窗也可以可以再桌面当中显示 wmParams.type = WindowManager.LayoutParams.TYPE_PHONE; wmParams.format = PixelFormat.RGBA_8888; //悬浮窗需要自己处理点击事件 wmParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; //初始位置在屏幕左边的中间 wmParams.gravity = Gravity.LEFT | Gravity.CENTER_VERTICAL;// 悬浮窗的宽为手机屏幕宽度的三分之一, 4:3 高宽比 wmParams.width = TestApplication.SCREEN_WIDTH / 3; wmParams.height = (wmParams.width / 3) * 4; //Service中的Context LayoutInflater inflater = LayoutInflater.from(mAppContext); mFloatLayout = (RelativeLayout) inflater.inflate(R.layout.top_window_player, null); mWindowManager.addView(mFloatLayout, wmParams); progressbar_loading = (ProgressBar) mFloatLayout.findViewById(R.id.progressbar_loading); ImageButton closebutton = (ImageButton) mFloatLayout.findViewById(R.id.lsq_closeButton); closebutton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mHostService.stopSelf(); &#125; &#125;); // 设置悬浮窗的Touch监听 mFloatLayout.setOnTouchListener(new View.OnTouchListener() &#123; int lastX, lastY; int paramX, paramY; public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //手指按下的位置 lastX = (int) event.getRawX(); lastY = (int) event.getRawY(); //记录手指按下时,悬浮窗的位置 paramX = wmParams.x; paramY = wmParams.y; break; case MotionEvent.ACTION_MOVE: int dx = (int) event.getRawX() - lastX; int dy = (int) event.getRawY() - lastY; wmParams.x = paramX + dx; wmParams.y = paramY + dy; // 更新悬浮窗位置 mWindowManager.updateViewLayout(mFloatLayout, wmParams); break; case MotionEvent.ACTION_UP: //当手指按下的位置和手指抬起来的位置距离小于5像素时,将此次触摸归结为点击事件, if (Math.abs(event.getRawX() - lastX) &lt; 5 &amp;&amp; Math.abs(event.getRawY() - lastY) &lt; 5) mFloatLayout.callOnClick(); break; &#125; return true; &#125; &#125;); //设置悬浮窗的点击监听 mFloatLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击悬浮窗重新跳转回 WatchVideoActivity 全屏播放 Intent intent = new Intent(mHostService.getApplicationContext(), WatchVideoActivity.class); //同理播放器在WatchVideoActivity 中全屏播放也是需要播放地址和 悬浮窗已经播放到的无照顾 intent.putExtra(\"m3u8Url\", mUrl); intent.putExtra(EXTRA_VIDEO_CURRENT_POSITION, mVideoView.getCurrentPosition()); //Service 中启动 Activity intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mHostService.startActivity(intent); //销毁服务 mHostService.stopSelf(); &#125; &#125;); mVideoView = (XXXVideoView) mFloatLayout.findViewById(R.id.live_player_videoview); //初始化播放器 mVideoView.initialize(); //监听播放器 播放器相关不贴出代码 mVideoView.setListener(mVideoListener); &#125; 开始播放的方法 1234567891011121314public void play(Bundle param) &#123; mBundleParam = param; if (mBundleParam == null) return; //拿到从 WatchVideoActivity 中传递过来的 播放地址 mUrl = mBundleParam.getString(\"m3u8Url\"); //拿到从 WatchVideoActivity 中传递过来的当前播放位置,以便继续播放 mCurrPositionFromWatchVod = mBundleParam.getInt(WatchVideoActivity.EXTRA_VIDEO_CURRENT_POSITION, -1); //播放器相关,省略部分代码 stop_play(); start_play();&#125; 效果 相关知识点学习资料 Android 悬浮窗参数权限的小结,这篇文章写得时间较早,其中有点内容在我测试机 红米Note 4X 当中并没有办法验证,索性,还是需要向用户申请悬浮窗权限. Service 官方文档 运行时权限官方文档 , 鸿洋大神—— Android 6.0 运行时权限处理完全解析 Android 带你彻底理解 Window 和 WindowManager , 《Android 开发艺术探索》 08-理解Window和WindowManager抄书系列","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"}]},{"title":"Android---View的工作流程","slug":"View work process","date":"2017-11-24T16:37:15.000Z","updated":"2017-11-25T05:35:12.790Z","comments":true,"path":"2017/11/25/View work process/","link":"","permalink":"http://zengfanyu.top/2017/11/25/View work process/","excerpt":"摘要：一直关注 Hencoder 的教程，前阵子刚好出了一期 View 的工作流程系列，然后结合《Android开发艺术探索》相关章节，做一下笔记。","text":"摘要：一直关注 Hencoder 的教程，前阵子刚好出了一期 View 的工作流程系列，然后结合《Android开发艺术探索》相关章节，做一下笔记。 MeasureSpec在很大程度上，MeasureSpec 决定了一个 View 的尺寸，作所以说“很大程度上”，是因为这个过程还会受到父容器的影响，因为父容器会硬性 View 的 MeasureSpec 的创建过程。在测量过程中，系统会将 View 的 LayoutParams 根据父容器施加的规则转换成 MeasureSpec，然后再根据这个 MeasureSpec 来测量出 View 的宽高。 MeasureSpec 是一个 32 位的 int 值，高 2 位代表SpecMode，低30位代表SpecSize。 SpecMode：测量模式 SpecSize：在某一测量模式下的规格大小1234567891011121314151617181920 public static class MeasureSpec &#123; ...public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125; public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; &#125; ... MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存，为了方便操作，其提供了打包和解包的方法。 SpecMode有三类， UNSPECIFIED 父容器不对 View 有任何显示，要多大给多大，这种模式一般是用于系统内部绘制。 EXACTLY 对应于 LayoutParams 的 match_content 和具体数值两种情况。表示父容器已经检测出 View 所需要的精确大小，这个大小由 SpecSize 给出。 AT_MOST 对用于 LayoutParams 中的 wrap_content 模式。表示父容器制定了一个可用大小，即 SpecSize，View的大小不能大于这个值，具体是多少要看不同View的具体实现。 MeasureSpec 和 LayoutParams 的对应关系在View 测量的时候，系统会将 View 的 LayoutParams 参数在父容器的约束之下转换成MeasureSpec，然后根据这个 MeasureSpec 来决定 View 测量后的宽高。什么叫做父容器的约束呢？也就父容器的 MeasureSpec，所以对于普通 View 来说，其 MeasureSpec 就是由父容器的MeasureSpec 和其自身的 LayoutParams 共同决定的。 上面说的是一个总结，这个总结，体现在ViewGroup的getChildMeasureSpec()方法中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @param spec The requirements for this view * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 这个方法看上去这么长，其实总结起来就是上面那句话：View 的 LayoutParams 参数在父容器的约束之下转换成 MeasureSpec。 这个方法是在 measureChildWithMargins() 方法中会调用： 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 在第 7 行可以看到，调用了 getChildMeasureSpec 方法，这个方法传入的第一个参数是parentWidthMeasureSpec，第三个参数是lp.width，这就充分说明上面的总结：一个 View 的MeasureSpec和其本身的LayoutParams和父容器的 MeasureSpec 相关。 最后一行，是拿到 View 的 MeasureSpecHeight 和 MeasureSpecWidth 值，去调用View的measure 方法，View 的 measure 方法放在下一节。 这么说起来，还是有点模糊，总结如下（也就是 getChildMeasureSpec 方法的表格呈现形式）： 其中 parentSize 指的是父容器中当前可用的大小 按子View的LayoutParams总结如下： 当View采用固定宽高的时候，无论父容器的SpecMode是什么，View的SpecMode都是EXACTLY，SpecSize遵循LayoutParams中的大小。 当View采用match_parent时，如果父容器的SpecMode是EXACTLY，那么View的SpecMode也是EXACTLY，SpecSize是父容器的剩余空间；如果父容器的SpecMode是AT_MOST，那么View的SpecMode也是AT_MOST，并且SpecMode不会超过父容器的剩余空间。 当View采用wrap_content时，无论父容器的SpecMode是什么，View的SpecMode都是AT_MOST，SpecSize不得超过父容器的剩余空间。 View的工作流程View的工作流程主要包括measure、layout、draw三个，即测量布局和绘制，其中measure确定View的测量宽高，layout确定View的最终宽高和四个顶点的位置，而draw将View绘制到屏幕上。 measure过程measure() 方法被父 View 调用，在 measure() 中做一些准备和优化工作后，调用 onMeasure() 来进行实际的自我测量。 onMeasure() 做的事，View 和 ViewGroup 不一样： View：View 在 onMeasure() 中会计算出自己的尺寸然后保存； ViewGroup：ViewGroup 在 onMeasure() 中会调用所有子 View 的 measure() 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置（实际上 99.99% 的父 View 都会使用子 View 给出的期望尺寸来作为实际尺寸）然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存； 那么久针对 View 和 ViewGroup 这两种情况分析了。 View 的 measure 过程View 的 measure 过程是由其 measure 方法完成的，在这个方法中又会去调用 onMeasure 方法，onMeasure实现： 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 就是调用了一个 setMeasureDimension 方法，将 View 的宽高传递进去，这个方法在自定义 View 的时候经常用到，就是在确定了自定义 View 的宽高值之后，在 onMeasure 方法中最后调用的，用于确定自定义 View 的测量宽高。 这里对宽高传入的都是 getDefaultSize() 函数的返回值，那么久看看这个函数： 1234567891011121314151617public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 就是根据 specMode 的不同值，返回不同的大小，当 AT_MOST 和 EXACTLY 模式下，就是返回 specSize 的值，也就是 View 测量后的大小。 在 UNSPECIFIED 模式下，View 的大小就是 getDefaultSize 方法的第一个参数 size ，即宽高分别为 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 这两个函数的返回值。在看下这两个函数(只贴出width的代码)： 1234protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 若 View 没有指定背景，那么 View 的宽度为 mMinWidth ，这个值是由 View 的 android:minWidth 属性指定的，若没有指定这个属性，那么这个 mMinWidth 为 0。 若 View 指定了背景，那么 View 的宽度就是 mMinWidth 和 mBackground.getMinimumWidth() 两者中较大的一个。前者上面已经说了是什么，那么后者又是什么东西呢？mBackground 是一个 Drawable，那么点进 Drawable 里面去看就知道了： 12345public int getMinimumWidth() &#123; final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;&#125; getMinimumWidth 返回的就是 Drawable 的原始高度，前提是这个 Drawable 有原始高度，不然就返回0； ViewGroup 的 measure 过程ViewGroup 是一个抽象类，因此他没有重写 View 的 onMeasure 方法，它提供了一个 measureChildren 方法： 1234567891011 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 这个方法就是调用 ViewGroup 的所有子 View 的 measureChild 方法，这个 measureChild方法如下： 123456789101112protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 就是拿到子 View 的 LayoutParams ，然后通过 getChildMeasureSpec 方法生成子 View 的 MeasureSpec，接着就将生成的 MeasureSpec 直接传递给子 View 的 measure 方法进行测量。 getChildMeasureSpec 的逻辑上述已经说明。 可以发现 ViewGroup 并没有定义其本身具体的测量过程，因为 ViewGroup 是一个抽象类， onMeasure 需要各个具体的子类去实现，不想 View 一样，对 onMeasure 方法做具体实现，是因为不同的 ViewGroup 的实现类，有不同的布局特性，这导致他们的测量细节各不相同，比如 LinearLayout 和 RelativeLayout 两者的布局特性显然不同。 layout 过程 layout 方法确定 View 本身的位置 onLayout 方法确定子 View 的位置 layout 的作用是 ViewGroup 用于确定子 View 的位置，当 ViewGroup 的位置确定了之后，它会在 onLayout 中遍历所有子 View ，并且调用其 layout 方法，而在子 View 的 layout 方法中，onLayout 方法又会被调用，先看 View 的layout 方法： 123456789101112131415161718192021222324252627282930public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; ...&#125; 14 行调用了 setFrame 方法，这个方法就是用于确定 View 的四个顶点的位置，一旦四个顶点确定了，那么 View 在 ViewGroup 中的位置也就确定了。贴出 setFrame 中的一段代码，稍后用于说明问题。 123456789protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; ...&#125; 17 行，会调用 onLayout 方法，这个方法的用途是父容器确定子 View 的位置，和 onMeasure 方法类似，onLayout 的实现和具体的布局相关，所以 View 和 ViewGroup 都没有实现这个方法。看看 LinearLayout 中的 onLayout 方法： 123456789@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 这里分为竖直方向上的 layout 和水平方向上的 layout，这里看看 竖直方向上的： 123456789101112131415161718192021222324252627282930void layoutVertical(int left, int top, int right, int bottom) &#123; final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); ... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125;&#125; 首先遍历竖直方向上的所有子 View ，并且调用 setChildFrame 方法来为子 View 确定位置 注意 childTop 值会逐渐增加，这个增量包括分割线宽度、margin 值、childHeight，这样一来，在竖直方向上就符合 LinearLayout 的特性了。 接下来看看 setChildFrame 方法： 1234private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; 就是直接调用子 View 的 layout 方法，这样 LinearLayout 是父容器，父容器在 layout 中完成自己的定位之后，就通过 onLayout 去调用子 View 的 layout 方法，让子 View 完成其对自身的 layout 过程，然后在子 View 的 layout 方法中，又会通过 onLayout 方法去调用下一级子 View 的 layout 方法… 这样一层一层的传递下去之后，就会遍历完整个 View 树。 测量宽高和最终宽高的区别这个问题可以具体为：getMeasureWidth/height 和 getWidth/height 有什么区别。 前者很明显，就是 measure 过程中得到的宽高，那么重点在后者，先看看 View 中的 getWidth 方法： 1234public final int getWidth() &#123; return mRight - mLeft;&#125; 现在就是要搞清楚 mRight 和 mLeft 两个变量是在什么时候赋值的。 还是看看 LinearLayout 的竖直方向的 layout 过程，也就是上面的 layoutVertical 方法，在第 9、10 行可以看到： 123final int childWidth = child.getMeasuredWidth();final int childHeight = child.getMeasuredHeight(); 然后在 22 行的 setChildFrame 方法，将 childWidth 和 childHeight 作为参数传入， 123setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); 然后在 setChildFrame 中会去调用子 View 的 layout 方法，继续讲参数传递 12child.layout(left, top, left + width, top + height); 在 View 的 layout 方法中会调用 setFrame(l, t, r, b)，这里的 l、t、r、b 和上面的参数对应，在 setFrame 中： 123456789protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; ...&#125; 这段代码之前提到过，在这里，就将 mLeft mTop mRight mBottom 给赋值了，这个值就是在 LinearLayout 中通过 getMeasureWidth 和 getMeasureHeight 方法得到的。 现在可以知道区别了在 View 的默认实现中，View 的测量宽高和最终宽高是相等的，只是两者的赋值时机不同，测量宽高形成于View 的 measure 过程，而最终宽高形成于View 的 layout 过程，在日常开发中，就可以认为 View 的测量宽高就等于 View 的最终宽高。 一个好习惯就是：在 onLayout 方法中去拿 View 的测量宽高或者是最终宽高，因为在某些极端的情况下，系统需要经过多次的 measure 才能确定最终的宽高，这种情况下，在 onMeasure 方法中拿到的测量宽高可能是不准确的。 draw 过程一个完整的绘制过程会依次绘制以下几个内容： 背景 主体（onDraw()） 子 View（dispatchDraw()） 滑动边缘渐变和滑动条 前景 一般来说，一个 View（或 ViewGroup）的绘制不会这几项全都包含，但必然逃不出这几项，并且一定会严格遵守这个顺序。例如通常一个 LinearLayout 只有背景和子 View，那么它会先绘制背景再绘制子 View；一个 ImageView 有主体，有可能会再加上一层半透明的前景作为遮罩，那么它的前景也会在主体之后进行绘制。需要注意，前景的支持是在 Android 6.0（也就是 API 23）才加入的；之前其实也有，不过只支持 FrameLayout，而直到 6.0 才把这个支持放进了 View 类里。 绘制背景它的绘制发生在一个叫 drawBackground() 的方法里，但这个方法是 private 的，不能重写，你如果要设置背景，只能用自带的 API 去设置（xml 布局文件的 android:background 属性以及 Java 代码的 View.setBackgroundXxx() 方法），而不能自定义绘制 绘制主体这个过程是在 onDraw 方法中执行的，但是在 View 中，这个方法是没有实现的，因为具体的 View 需要如何绘制，需要 View 的子类去具体的定制。所以当我们自定义 View 的绘制的时候，就就可以直接重写 onDraw 方法。 123456789101112public class AppView extends View &#123; ... protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... // 自定义绘制代码 &#125; ...&#125; 这里注意，是将自定义绘制的代码写在 super 的下面，不过这里写在 super 的上面和下面其实都是一样的， 因为上面提到，View 的这个方法是一个空实现，所以。 下面来讨论自定义 View 的绘制方法时，自定义的代码写在 super 上下的区别。 写在 super.onDraw() 的下面把绘制代码写在 super.onDraw() 的下面，由于绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。这是最为常见的情况：为控件增加点缀性内容。比如，在 Debug 模式下绘制出 ImageView 的图像尺寸信息： 写在 super.onDraw() 的上面如果把绘制代码写在 super.onDraw() 的上面，由于绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。 这种方式可以实现马克笔的效果： 绘制子 View有部分的遮盖关系是无法通过 onDraw 方法来实现的，例如，你继承了一个 LinearLayout，重写了它的 onDraw() 方法，在 super.onDraw() 中插入了你自己的绘制代码，使它能够在内部绘制一些斑点作为点缀： 12345678910public class SpottedLinearLayout extends LinearLayout &#123; ... protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... // 绘制斑点 &#125;&#125; 没毛病。 但是当添加了子 View 之后， 12345678910&lt;SpottedLinearLayout android:orientation=\"vertical\" ... &gt; &lt;ImageView ... /&gt; &lt;TextView ... /&gt;&lt;/SpottedLinearLayout&gt; 造成这种情况的原因是 Android 的绘制顺序：在绘制过程中，每一个 ViewGroup 会先调用自己的 onDraw() 来绘制完自己的主体之后再去绘制它的子 View。对于上面这个例子来说，就是你的 LinearLayout 会在绘制完斑点后再去绘制它的子 View。那么在子 View 绘制完成之后，先前绘制的斑点就被子 View 盖住了。 具体来讲，这里说的「绘制子 View」是通过另一个绘制方法的调用来发生的，这个绘制方法叫做：dispatchDraw()。也就是说，在绘制过程中，每个 View 和 ViewGroup 都会先调用 onDraw() 方法来绘制主体，再调用 dispatchDraw() 方法来绘制子 View。 注：虽然 View 和 ViewGroup 都有 dispatchDraw() 方法，不过由于 View 是没有子 View 的，所以一般来说 dispatchDraw() 这个方法只对 ViewGroup（以及它的子类）有意义。 回到刚才的问题：怎样才能让 LinearLayout 的绘制内容盖住子 View 呢？只要让它的绘制代码在子 View 的绘制之后再执行就好了。 写在 super.dispatchDraw() 的下面只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。 1234567891011public class SpottedLinearLayout extends LinearLayout &#123; ... // 把 onDraw() 换成了 dispatchDraw() protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); ... // 绘制斑点 &#125;&#125; 写在 super.dispatchDraw() 的上面同理，把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间。而这个…… 其实和前面讲的，重写 onDraw() 并把绘制代码写在 super.onDraw() 之后的做法，效果是一样的。 onDrawForeground()滑动边缘渐变和滑动条以及前景，这两部分被合在一起放在了 onDrawForeground() 方法里，这个方法是可以重写的。 滑动边缘渐变和滑动条可以通过 xml 的 android:scrollbarXXX 系列属性或 Java 代码的 View.setXXXScrollbarXXX() 系列方法来设置；前景可以通过 xml 的 android:foreground 属性或 Java 代码的 View.setForeground() 方法来设置。而重写 onDrawForeground() 方法，并在它的 super.onDrawForeground() 方法的上面或下面插入绘制代码，则可以控制绘制内容和滑动边缘渐变、滑动条以及前景的遮盖关系。 写在 super.onDrawForeground() 的下面如果你把绘制代码写在了 super.onDrawForeground() 的下面，绘制代码会在滑动边缘渐变、滑动条和前景之后被执行，那么绘制内容将会盖住滑动边缘渐变、滑动条和前景。 123456789101112131415public class AppImageView extends ImageView &#123; ... public void onDrawForeground(Canvas canvas) &#123; super.onDrawForeground(canvas); ... // 绘制「New」标签 &#125;&#125;&lt;!-- 使用半透明的黑色作为前景，这是一种很常见的处理 --&gt; &lt;AppImageView ... android:foreground=\"#88000000\" /&gt; 左上角的标签没有被前景遮盖住，而是保持了它本身的颜色 写在 super.onDrawForeground() 的上面如果你把绘制代码写在了 super.onDrawForeground() 的上面，绘制内容就会在 dispatchDraw() 和 super.onDrawForeground() 之间执行，那么绘制内容会盖住子 View，但被滑动边缘渐变、滑动条以及前景盖住： 12345678910public class AppImageView extends ImageView &#123; ... public void onDrawForeground(Canvas canvas) &#123; ... // 绘制「New」标签 super.onDrawForeground(canvas); &#125;&#125; 由于被黑色的前景给遮住了，这里看到的标签也是这种半透明的黑色 想在滑动边缘渐变、滑动条和前景之间插入绘制代码？很简单：不行。 虽然这三部分是依次绘制的，但它们被一起写进了 onDrawForeground() 方法里，所以你要么把绘制内容插在它们之前，要么把绘制内容插在它们之后。而想往它们之间插入绘制，是做不到的。 draw() 总调度的方法除了 onDraw() dispatchDraw() 和 onDrawForeground() 之外，还有一个可以用来实现自定义绘制的方法： draw()。 draw() 是绘制过程的总调度方法。一个 View 的整个绘制过程都发生在 draw() 方法里。前面讲到的背景、主体、子 View 、滑动相关以及前景的绘制，它们其实都是在 draw() 方法里的。 12345678910111213// View.java 的 draw() 方法的简化版大致结构（是大致结构，不是源码哦）：public void draw(Canvas canvas) &#123; ... drawBackground(Canvas); // 绘制背景（不能重写） onDraw(Canvas); // 绘制主体 dispatchDraw(Canvas); // 绘制子 View onDrawForeground(Canvas); // 绘制滑动相关和前景 ...&#125; 从上面的代码可以看出，onDraw() dispatchDraw() onDrawForeground() 这三个方法在 draw() 中被依次调用，因此它们的遮盖关系也就像前面所说的——dispatchDraw() 绘制的内容盖住 onDraw() 绘制的内容；onDrawForeground() 绘制的内容盖住 dispatchDraw() 绘制的内容。而在它们的外部，则是由 draw() 这个方法作为总的调度。所以，你也可以重写 draw() 方法来做自定义的绘制。 写在 super.draw() 的下面由于 draw() 是总调度方法，所以如果把绘制代码写在 super.draw() 的下面，那么这段代码会在其他所有绘制完成之后再执行，也就是说，它的绘制内容会盖住其他的所有绘制内容。 它的效果和重写 onDrawForeground()，并把绘制代码写在 super.onDrawForeground() 下面时的效果是一样的：都会盖住其他的所有内容。 当然了，虽说它们效果一样，但如果你既重写 draw() 又重写 onDrawForeground() ，那么 draw() 里的内容还是会盖住 onDrawForeground() 里的内容的。所以严格来讲，它们的效果还是有一点点不一样的。 但这属于抬杠…… 写在 super.draw() 的上面同理，由于 draw() 是总调度方法，所以如果把绘制代码写在 super.draw() 的上面，那么这段代码会在其他所有绘制之前被执行，所以这部分绘制内容会被其他所有的内容盖住，包括背景。是的，背景也会盖住它。 是不是觉得没用？觉得怎么可能会有谁想要在背景的下面绘制内容？别这么想，有的时候它还真的有用。 例如我有一个 EditText： 它下面的那条横线，是 EditText 的背景。所以如果我想给这个 EditText 加一个绿色的底，我不能使用给它设置绿色背景色的方式，因为这就相当于是把它的背景替换掉，从而会导致下面的那条横线消失： 1234&lt;EditText ... android:background=\"#66BB6A\" /&gt; 在这种时候，你就可以重写它的 draw() 方法，然后在 super.draw() 的上方插入代码，以此来在所有内容的底部涂上一片绿色： 12345678910public AppEditText extends EditText &#123; ... public void draw(Canvas canvas) &#123; canvas.drawColor(Color.parseColor(\"#66BB6A\")); // 涂上绿色 super.draw(canvas); &#125;&#125; ###draw 过程注意 关于绘制方法，有两点需要注意一下： 出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，你可能会需要调用 View.setWillNotDraw(false) 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。 有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。 ###draw 过程总结 另外别忘了上面提到的那两个注意事项： 在 ViewGroup 的子类中重写除 dispatchDraw() 以外的绘制方法时，可能需要调用 setWillNotDraw(false)； 在重写的方法有多个选择时，优先选择 onDraw()。 总结对 View 的绘制过程都清楚了之后，就可以进行各种自定义 View 了，Hencoder 说过，自定义 View 无非就是三个：绘制、布局、触摸反馈。 其中绘制和布局这里总结了，在这两个操作过程中会大量使用到 Paint Canvas 和 Property Animation，这些后面再做总结。 参考引用[1] 《Android 开发艺术探索》 [2] HenCoder Android 开发进阶：自定义 View 1-5 绘制顺序 实践自定义流式布局，刚好是对上面总结内容的一个很好的实践。 View 工作流程的相关实践项目","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"}]},{"title":"新姿势学习之Java8---Lambda Expressions And Stream","slug":"Java8---Lambda Expressions","date":"2017-11-12T16:37:15.000Z","updated":"2018-01-06T08:33:13.392Z","comments":true,"path":"2017/11/13/Java8---Lambda Expressions/","link":"","permalink":"http://zengfanyu.top/2017/11/13/Java8---Lambda Expressions/","excerpt":"摘要: 去年逛 Github 准备秋招项目时,就发现 Android 有的项目使用的语法似乎从来没见过,类似于 (parameters)-&gt;expression 还有ObjectReference::methodName 这种类 C++ 语法形式,查找资料之后,知道这个是 Java8 的新特性:Lambda,所以就记下了 Lambda 这个词,后来忙于秋招春招实习,一直也没有取好好学习,昨天在项目当中又看到了这个熟悉的表达式,一脸懵逼,所以准备找几篇 Java8 教程,好好学习一下”新”姿势.","text":"摘要: 去年逛 Github 准备秋招项目时,就发现 Android 有的项目使用的语法似乎从来没见过,类似于 (parameters)-&gt;expression 还有ObjectReference::methodName 这种类 C++ 语法形式,查找资料之后,知道这个是 Java8 的新特性:Lambda,所以就记下了 Lambda 这个词,后来忙于秋招春招实习,一直也没有取好好学习,昨天在项目当中又看到了这个熟悉的表达式,一脸懵逼,所以准备找几篇 Java8 教程,好好学习一下”新”姿势. 分别总结 java8 中涉及到的一些名词，可能没什么条理，都是有助于理解 java8 中的新特性，特别是 Lambda 和 Stream 相关的知识，至少我是怎么认为的，哈哈~。## 为什么需要 Java8原因众多,其中最主要的原因是: 可以让多线程并行处理 Colloection 的代码变得容易编写.商业发展需要复杂的应用,更过的应用都跑在多核的 CPU 上,既然是多核,就需要保证它的并行操作,所以之前 java 中推出了 java.util.concurrent 包来解决并行的问题,但是在大数据的处理上,这些类库的层抽象级别还不够,缺乏高效的并行操作,我们需要编写复杂的集合处理算法,用于处理大数据问题,这种算法已经很难在工具层面来解决了,所以只能上升到语言层面:增加 Lambda 表达式,## Streams API标题太广泛，需要一篇文章来总结## 函数式编程标题范围太广，需要一篇文章来总结## 函数式接口简单来说，函数式接口是只包含一个方法的接口。比如 Java 标准库中的 java.lang.Runnable 和java.util.Comparator 都是典型的函数式接口。java 8 提供 @FunctionalInterface 作为注解,这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口），虚拟机会自动判断，但最好在接口上使用注解 @FunctionalInterface 进行声明，以免团队的其他人员错误地往接口中添加新的方法。这里使用一个例子来说明：12345678910111213141516171819202122232425262728293031 //定义一个函数式接口FunctionalInterfacepublic interface WorkerInterface &#123; public void doSomeWork();&#125;public class WorkerInterfaceTest &#123;public static void execute(WorkerInterface worker) &#123; worker.doSomeWork();&#125;public static void main(String [] args) &#123; //invoke doSomeWork using Annonymous class execute(new WorkerInterface() &#123; @Override public void doSomeWork() &#123; System.out.println(\"Worker invoked using Anonymous class\"); &#125; &#125;); //invoke doSomeWork using Lambda expression execute( () -&gt; System.out.println(\"Worker invoked using Lambda expression\") );&#125;&#125;## Lambda 语法 ##语法的定义比较简单:1. 一个括号内,用逗号分隔的形式参数,这些个形参是函数式接口里的方法的参数2. 一个箭头符号 -&gt; 方法体,可以是表达式或者代码块,是函数式接口里面的方法的具体实现.如果是代码块,就必须要用 {} 包裹起来,且需要一个 return 返回值.但是如果函数式接口里面的方法本身的返回类型就是 void ,那么代码块是不需要用 {} 包裹,也不需要返回值的.总结起来,就是它的形式类似于: 12(parameters) -&gt; expression or (parameters) -&gt; &#123; statements; &#125; 4.方法引用.其实是 Lambda 表达式的一个简化写法，所引用的方法其实是 Lambda 表达式的方法体实现，语法也很简单，左边是容器（可以是类名，实例名），中间是 &quot;::&quot;，右边是相应的方法名。如下所示： 12ObjectReference::methodName 如果是静态方法，则是 ClassName::methodName。如 Object ::equals 如果是实例方法，则是 Instance::methodName。如 Object obj=new Object();obj::equals; 如果是构造函数 , 则是 ClassName::new 如果是接口方法 , 则是 InterfaceName::methodName.如 List::add , List::addAll Java 中的 Lambda 无法单独出现，它需要一个函数式接口来盛放， Lambda 表达式方法体其实就是函数接口的实现. Lambda 应用场景个人觉得，学习 Lambda 最好的方法，就是通过对比的方式去学，将实现某一功能使用 Lambda 表达式和不使用 Lambda 两套代码进行对比，这样记忆更加深刻，这一小节中也涉及到部分操作符的使用总结。 用 Lambda 表达式实现 Runnable1234567891011//Before java8new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"This is before java8\"); &#125;&#125;).start();//In java8 waynew Thread(() -&gt; System.out.println(\"Java8 coming!\")).start(); 使用 Lambda 表达式进行事件处理12345678910111213//Before Java8mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; System.out.println(\"Button clicked!\"); &#125; &#125;);//In java8 way mButton.setOnClickListener((v)-&gt; &#123; System.out.println(\"Button clicked!\"); &#125;); 这种方式其实跟上面对 Runnable 的操作是一样的,都是将匿名内部类使用 Lambda 来替换,唯一不同的就是,上面 Runnable 的例子里,方法是没有参数的,但是这个例子中, onClick(View view) 回调方法是有一个参数的. 此处的 Lambda 表达式用用的是 (v) ,而不是回调函数本身的 view ,是因为在 Lambda 表达式中的参数是形参,不恰当的例子:形参随便你写什么都行. 上面例子中,方法体的 {} 是可以不用的,这里是为了和上面保证格式一致,方便对比. 用 Lambda 表达式对集合进行迭代1234567891011 List&lt;String&gt; features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");//Before java8 for (String feature : features) &#123; System.out.println(feature); &#125;//In java8 way features.forEach((String feature) -&gt; System.out.println(feature)); //or features.forEach(System.out::println); 第 10 行使用的是方法引用,但是要注意:方法引用不能修改 Lambda 表达式提供的参数. 使用 Lambda 的 filter 操作12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(args[])&#123; List languages = Arrays.asList(\"Java\", \"Scala\", \"C++\", \"Haskell\", \"Lisp\"); System.out.println(\"Languages which starts with J :\"); filter(languages, (str)-&gt;str.startsWith(\"J\")); System.out.println(\"Languages which ends with a \"); filter(languages, (str)-&gt;str.endsWith(\"a\")); System.out.println(\"Print all languages :\"); filter(languages, (str)-&gt;true); System.out.println(\"Print no language : \"); filter(languages, (str)-&gt;false); System.out.println(\"Print language whose length greater than 4:\"); filter(languages, (str)-&gt;str.length() &gt; 4);&#125;public static void filter(List&lt;String&gt; names, Predicate&lt;String&gt; condition) &#123; for(String name: names) &#123; if(condition.test(name)) &#123; System.out.println(name + \" \"); &#125; &#125; &#125;//另一种写法 public static void filter(List&lt;String&gt; names, Predicate&lt;String&gt; condition) &#123; names.stream().filter((name) -&gt; (condition.test(name))) .forEach((name) -&gt; System.out.println(name + \" \")); &#125;//另另一种写法 public static void filter(List&lt;String&gt; names, Predicate&lt;String&gt; condition) &#123; names.forEach((String str) -&gt; &#123; if (condition.test(str)) &#123; System.out.println(str + \"\"); &#125; &#125;); &#125; 关于 Predicate,笔者的一些理解: 可以看到下面的 filter 方法,它接受一个类型为 Predicate 的参数,Predicate 本身是「谓语」的意思（也有翻译做「断言」的，不过我个人觉得，「谓语」更好理解，原因如下）比如:“我打你”,那么这个”打”就是谓语,很明显这是一个谓语动词,其实这个”打”是有一个返回的「结果」的,只是在语言本身的语法当中是没有关注的,比如,打到没有?打疼没有?打死没有? true or false ? 而 Predicate的描述是这样的: Represents a predicate (boolean-valued function) of one argument. ,代表一个参数的”谓语”,这个谓语是有返回值的,返回值的类型要是 boolean 的. boolean test(T t) 方法: Evaluates this predicate on the given argument ,用于返回这个参数的谓语的结果.拿上面的例子来说,调用 test(T t) 之后,如果返回的是 false ,那么表示「我没有打到你或者我没有打疼你或者我没打死你」,返回 true 表示,「我打到你了或者我打疼你了或者我打死你了」. 对应到上面代码第 5 行, Argument 「参数」指的是 languages 集合中的元素,predicate 「谓语」指的是 (str)-&gt;str.startWith(&quot;J&quot;),很明显,这个谓语是有返回值的,true 表示 languages 中的当前遍历的元素是 J 开头的,反之则不是. 再一次感叹老外命名的巧夺天工! 在 Lambda 表达式中加入 Predicate上面的例子一次只使用了一个 Predicate ,可以通过逻辑操作符,将两个或者多个 Predicate 的逻辑运算结果作为一个 Predicate. 123456Predicate&lt;String&gt; lengthFilter = (String str) -&gt; str.length() == 4;Predicate&lt;String&gt; startFilter = (String str) -&gt; str.startsWith(\"J\");languages.stream() .filter(lengthFilter.and(startFilter)) .forEach(language -&gt; System.out.printLn(language)); 第四行,的 filter 函数接收一个 Predicate 类型的参数,这个参数是由 lengthFilter 和 startFilter 的结果两经过与操作组成的, 同理 or() 是或操作, or() 是异或操作. 使用 Lambda 的 map 操作 需求:给出税前的列表,返回税后列表,税12% 12345678910111213//Before java8 List&lt;Integer&gt; costBeforeTax = Arrays.asList(100, 200, 300, 400, 500); for (Integer beforeTax : costBeforeTax) &#123; double costAfterTax = beforeTax + 0.12 * beforeTax; System.out.println(costAfterTax); &#125; //In java8 way List&lt;Integer&gt; costBeforeTaxL= Arrays.asList(100,200,300,400,500); costBeforeTaxL.stream().map(cost -&gt; cost + cost * 0.12).forEach(System.out::println); 这里用到了 map 操作符,它的作用就是:将 Input Strean 的每一个元素转换成 Output Stream 的另一个元素,这是一个 1:1 的映射. map 的定义:&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 官方给的注解是这么说的: Returns a stream consisting of the results of applying the given function to the elements of this stream.翻译成中文 : 返回由 将给定函数 Function 应用于此流的元素的结果 组成的流,那就来看看 Function 是什么咯. @FunctionalInterface public interface Function&lt;T, R&gt;{...} ,注解是 : Represents a function that accepts one argument and produces a result. 这个接口代表一个函数,这个函数接收一个参数(Input Stream),并且会产生一个结果( Output Stream ). 在看上面的例子, map 操作返回的就是将 cost+cost*0.12( Function ) 给应用到 costBeforeTaxl (Input Stream)的每一个元素( cost )之后的结果所组成的流( Output Stream ). 真是拗口… 使用 Lambda 的 reduce 操作 需求:给出税后总和 12345678910111213141516//Before java8List&lt;Integer&gt; costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double total = 0;for (Integer cost : costBeforeTax) &#123; double price = cost + .12 * cost; total = total + price;&#125;System.out.println(\"Total : \" + total);//In java8 wayList&lt;Integer&gt; costBeforeTaxL = Arrays.asList(100, 200, 300, 400, 500);double bill = costBeforeTaxL.stream().map((cost) -&gt; cost + 0.12 * cost).reduce((sum, cost) -&gt; sum + cost).get();//或者可以用 reduce 两个参数的方法,两个参数的形式,返回的就不是 Optional&lt;T&gt; 对象了, 而直接是 T 对象double bill = costBeforeTaxL.stream().map((cost) -&gt; cost + 0.12 * cost).reduce(0d,(sum, cost) -&gt; sum + cost)System.out.println(\"Total : \" + bill); 先用 map 操作符求出税后的金额,然后在用 reduce 求和. reduce 有两个重载方法,一个有起始参数,也就种子参数,一个是没有起始参数的. 一个参数定义: Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 这个方法的主要作用是把 Stream 元素组合起来。这种方式是没有起始值的,直接依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合,返回的是 Optional. 两个参数定义: T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); 其中 T identity 表示的是起始值.上面的例子传入的值是 0d ,所以输出和一个参数形式的输出结果一样,都是 1680,假设此处传入的起始值是 100 ,那么输出的结果就是 1780.accumulator：计算的「组合器」，其方法签名为 apply(T t,U u)，在该 reduce 方法中第一个参数 t为上次函数计算的返回值，第二个参数 u 为 Stream 中的元素，这个函数把这两个值计算 apply，得到的「组合」会被赋值给下次执行这个方法的第一个参数。 也就是说，有起始值的 reduce 返回的是具体的对象，没有起始值返回的是 optianal 对象，因为它可能没有返回的对象，会产生 NOE 异常。 Optional 可以简单的理解为一个容器,可能含有某值,也可能不含,使用这个类的目的是为了尽可能的避免 NullPointerException,若含有,则调用 get() 方法之后,就返回这个值,否则抛 NoSuchElementException.在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 上面的例子，BinaryOperator 指的就是 (sum, cost) -&gt; sum + cost ，recuxe 函数返回的就是个 Optional 对象，然后我们通过 get（） 方法拿到 Optional 中含有的值。 使用 Lambda 的 Collect 操作123List&lt;Integer&gt; originalList= Arrays.asList(1,2,3,4);List&lt;Integer&gt; afterFilter = Stream.of(1,2,3,4).filter(n -&gt; n &gt; 2).collect(Collectors.toList());System.out.printf(\"Original List : %s, afterFilter list : %s %n\", originalList, afterFilter); 输出:1Original List : [1, 2, 3, 4], afterFilter list : [3, 4] collect 操作用处收集结果，当处理完一个流之后，想看一下处理后的结果，而不是将它们聚合起来，那么就可以用到 Collect 操作符。 首先是对流里面的每一个元素进行 filter 操作,谓语 x.length()&gt;2 这个表达式返回值为 true 的元素,然后对这些符合标准的元素组成的流进行 collect 操作. collect 操作也有两个重载的方法: &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner) supplier 一个能够创造目标类型实例的方法 accumulator 一个将元素添加到目标中的方法 combiner 一个将中间状态的结果整合到一起的方法注意上面三个参数都是方法. &lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector) collector 可以看到,它就是上面 supplier,accumulator,combiner 的聚合体. 将上述例子用三个参数的方法改写： 12345Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4);ArrayList&lt;Integer&gt; result = integerStream.collect(() -&gt; new ArrayList&lt;Integer&gt;(), (list, item) -&gt; list.add(item), (aList, bList) -&gt; aList.addAll(bList));//此处也可以使用方法引用//ArrayList&lt;Integer&gt; result=integerStream.collect(ArrayList::new,List::add,List::addAll);System.out.printf(\"Original List : %s, afterFilter list : %s %n\", integerStream, result); Collectors :看这个类的名字就类似于 Arrays,Executors 这两工具类，点进源码一看，这确实也是一个工具类，它里面都是静态的工厂方法，用于产生 Collector 类型的参数，toList 和 toSet 就是其中最常见的两个。而通过 Collectors 的静态工厂方法产生的 Collector 的类型由其输入类型和输出类型决定。以 toList() 为例，它的输入类型为 T ，输出类型为 List&lt;T&gt;。对应到上面的例子中，输入类型为 Integer ，所以输出的类型为 List&lt;Integer&gt; 使用 Lambda 的 distinct 操作1234567public static void main(String[] args) &#123; Stream.of(1, 2, 3, 4, 5, 6, 2, 3, 4, 2, 4, 5) .map(x -&gt; x * x) .distinct() .collect(Collectors.toList()) .forEach(n-&gt;System.out.print(n+\" \")); &#125; 输出结果为： 11 4 9 16 25 36 通过上面的例子可以看出来，distince 操作就是去重。 使用 summaryStatistics 获取几个统计值1234567891011IntSummaryStatistics intSummaryStatistics = Stream .of(1, 4, 3, 56, 7, 89, 5, 4, 6, 8, 4, 345, 76, 8) .mapToInt(value -&gt; value) .summaryStatistics(); System.out.println(\"max value is:\"+ intSummaryStatistics.getMax()); System.out.println(\"min value is:\"+ intSummaryStatistics.getMin()); System.out.println(\"the average is:\"+ intSummaryStatistics.getAverage()); System.out.println(\"the value is:\"+ intSummaryStatistics.getSum()); System.out.println(\"the count is:\"+ intSummaryStatistics.getCount()); 此方法用于返回流当中各种在摘要数据，包括最大值，最小值，平均值，和，元素个数。 summaryStatistics 方法只有 IntStream、LongStream 和 DoubleStream有。 Lambda 表达式 VS 匿名类 从上面举的例子里可以看到，Lambda 表达式用于提到匿名内部类，这两者有一个关键不同之处就是 this. 匿名类的 this 指向匿名类，而 Lambda 表达式的 this 指向包围 Lambda 表达式的类。 还有一点不同就是编译方式。Java 编译器将 Lambda 表达式是编译成类的私有方法的。 总结 Lambda 表达式仅能放入如下代码：预定义使用了 @FunctionalInterface 注释的函数式接口，自带一个抽象函数的方法，或者SAM （Single Abstract Method 单个抽象方法）类型。这些称为 Lambda 表达式的目标类型，可以用作返回类型，或 Lambda 目标代码的参数。例如，若一个方法接收 Runnable、Comparable 或者 Callable 接口，都有单个抽象方法，可以传入 Lambda 表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传 Lambda 表达式。 Lambda 表达式内可以使用方法引用，仅当该方法不修改 Lambda 表达式提供的参数。本例中的 Lambda 表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。 12list.forEach(n -&gt; System.out.println(n)); list.forEach(System.out::println); // 使用方法引用 然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地 Lambda 表达式，如下所示：1list.forEach((String s) -&gt; System.out.println(\"*\" + s + \"*\")); 事实上，可以省略这里的 Lambda 参数的类型声明，编译器可以从列表的类属性推测出来。 Lambda 内部可以使用静态、非静态和局部变量，这称为 Lambda 内的变量捕获。 Lambda 表达式在 Java 中又称为闭包或匿名函数。 Lambda 方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用 JDK 中的 javap 工具来反编译 class 文件。使用 javap -p 或 javap -c -v 命令来看一看 Lambda 表达式生成的字节码。大致应该长这样： 1private static java.lang.Object Lambda $0(java.lang.String); Lambda 表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在 Lambda 内部修改定义在域外的变量。1234List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);int factor = 2;primes.forEach(element -&gt; &#123; factor++; &#125;);Compile time error : \"local variables referenced from a `Lambda` expression must be final or effectively final\" 另外，只是访问它而不作修改是可以的，如下所示：123List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);int factor = 2;primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;); 输出：1234461014 因此，它看起来更像不可变闭包，类似于Python。 刚开始使用 Lambda 表达式的时候，会感觉特别困惑，有时不能理解这一个箭头一个参数代表的是什么，这种写法引用的是哪个接口的回调方法，这个回调方法的实现是什么，但是会出现这种情况，就是因为 Lambda 将原来需要由客户定义的一些流程给封装了，现在用户只要告诉它「应该怎么做」，具体的操作过程，不需要我们用户来实施，所以这就是最开始使用起来，感觉疑惑的原因吧，这也是函数式编程所带来的影响。 引用列表 Java 8 中的 Streams API 详解 Java8中聚合操作collect、reduce方法详解 Java 8 lambda 最佳实践 Java8 lambda表达式10个示例 关于 Lambda 表达式的一些事 函数式编程初探 Java 8新特性探究（一）通往lambda之路_语法篇","categories":[{"name":"Java","slug":"Java","permalink":"http://zengfanyu.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zengfanyu.top/tags/Java/"}]},{"title":"Android官方TODO-MVP项目分析（上）---View 层 Presenter 层以及 Contract 分析","slug":"google-TODO-MVP-sample","date":"2017-11-12T16:37:15.000Z","updated":"2017-11-12T16:19:45.743Z","comments":true,"path":"2017/11/13/google-TODO-MVP-sample/","link":"","permalink":"http://zengfanyu.top/2017/11/13/google-TODO-MVP-sample/","excerpt":"摘要:最近看了一下 google 官方的 sample ,做的是一个 TODO 应用，使用的是 MVP 模式，之前笔者也学习了一段时间的 MVP，前面写了几篇文章记录学习过程，也有一些思考，最后呈现出来的问题就是 Presenter 层臃肿问题，以及 View 层接口难以管理的问题。比方说 View 层，它是负责 UI 的更新工作，我们希望它里面都是 showXXXZZZ（@Nullable Param p） 这样的更新 UI 状态的方法。在这个 sample 里， google 提供了一种解决接口混乱的方法，用「契约」接口，统一管理 View 层和 Presenter 层的接口，下面就分析下我对这个项目的理解。","text":"摘要:最近看了一下 google 官方的 sample ,做的是一个 TODO 应用，使用的是 MVP 模式，之前笔者也学习了一段时间的 MVP，前面写了几篇文章记录学习过程，也有一些思考，最后呈现出来的问题就是 Presenter 层臃肿问题，以及 View 层接口难以管理的问题。比方说 View 层，它是负责 UI 的更新工作，我们希望它里面都是 showXXXZZZ（@Nullable Param p） 这样的更新 UI 状态的方法。在这个 sample 里， google 提供了一种解决接口混乱的方法，用「契约」接口，统一管理 View 层和 Presenter 层的接口，下面就分析下我对这个项目的理解。 项目整体结构分析 因为项目整体使用的是 MVP 模式，所以下面从 MVP 分层的角度来分析；在上面的结构图中，除了 data 包是 Model 层的内容，剩余的四个包里，都是一个包对应一个界面（Activity/Fragment），然后每一个包里有四个类文件,形式分别如下： XxxxActivity：这是 Fragment 的宿主 Acitivity， 同是也是 View 层，但是并没有实现 View 层的接口，主要的 UI 状态更新工作是由 Fragment 来进行的。 YyyyFragment：这是 MVP 模式中的 View 层，它实现了 View 层的接口，都是 showXxxYyy() 形式的更新 UI 的回调方法。 ZzzzPresenter：这是 MVP 模式中的 Presenter 层，它负责处理 UI 的事件，并且和 Model 层打交道，通过 Model 层拿到数据。 PpppContract: 这个类不属于传统 MVP 模式当中的任何一层，它是用于管理 View 层和 Presenter 层的接口的，这个类同一个界面对应的 View 和 Presenter 都要实现， 这样就统一的管理了接口，当我们需要知道 这个 View 层，做了哪些操作的时候，只需要看这个 Contract 类即可，并且对代码模块的移植也有帮助。 整个 data 包下，都是 MVP 模式的 Model 层，用于从数据源取数据，在这个 Sample 里涉及到三种类型的数据，服务器端数据，本地数据库数据和内存缓存中的数据，当然了，这里的服务器端数据时模拟耗时过程的，并没有真正涉及到网络连接的操作。 下面拿 task 包下的类来做说明。(其中 ScrollChildSwipeRefreshLayout 和 TaskFilterType 是业务需求相关的辅助类， 这里暂不做分析。) tasks 包结构分析先看看这个包对应的界面长什么样子： 左边还有一个 DrawerLayout ： 点击 ToolBar 上最右边的 icon： 点击 ToolBar 上次右边的 icon： 当列表中存在任务时： 点击任务，跳转到详情页面，（这个页面不属于这个包下） TasksActivity这是 TasksFragment 的宿主 Activity，它做的工作就是一些控件的初始化操作，然后实例化 TasksFragment 。 初始化 ToolBar 1234567// Set up the toolbar.Toolbar toolbar = (Toolbar) find`View`ById(R.id.toolbar);setSupportActionBar(toolbar);ActionBar ab = getSupportActionBar();ab.setHomeAsUpIndicator(R.drawable.ic_menu);ab.setDisplayHomeAsUpEnabled(true); 初始化 Navigation Drawer 12345678// Set up the navigation drawer.mDrawerLayout = (DrawerLayout) find`View`ById(R.id.drawer_layout);mDrawerLayout.setStatusBarBackground(R.color.colorPrimaryDark);Navigation`View` navigation`View` = (Navigation`View`) find`View`ById(R.id.nav_`View`);if (navigation`View` != null) &#123; setupDrawerContent(navigation`View`);&#125; 初始化对应的 Fragment 123456789TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);if (tasksFragment == null) &#123; // Create the fragment tasksFragment = TasksFragment.newInstance(); ActivityUtils.addFragmentToActivity( getSupportFragmentManager(), tasksFragment, R.id.contentFrame);&#125; Presenter 注入 View 1234// Create the presenter 注入到TaskFragment中mTasksPresenter = new TasksPresenter( Injection.provideTasksRepository(getApplicationContext()), tasksFragment); 这里同时将 Model 层的对象给注入到了 Presenter 中，这个 TasksRepository 就是属于 Model 层的，后面分析。 状态恢复(onCreate 中，也可以直接在 onRestoreInstanceState 方法中操作) 1234567// Load previously saved state, if available.if (savedInstanceState != null) &#123; TasksFilterType currentFiltering = (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY); mTasksPresenter.setFiltering(currentFiltering);&#125; 保存当前显示的 Task 的类别的方法 123456789@Overridepublic void onSaveInstanceState(Bundle outState) &#123; //此处需要保存的信息是当前 Task 列表展示界面展示的 Filter Type 信息, // 目的是为了下一次重其他的页面跳回到此页面时,能够正确的显示 对应 Filter Type 的 Task outState.putSerializable(CURRENT_FILTERING_KEY, mTasksPresenter.getFiltering()); super.onSaveInstanceState(outState);&#125; 从一个 Activity 跳到另外一个 Activity 的时候会调用，用于存储当前 Activity 正在显示的 Task 的类别，类别有三种，分别是 COMPLETED_TASK , ACTIVT_TASK , ALL_TASK; 很好理解，就是用于辨别当前界面是显示已经完成的 Task 还是显示暂未完成的，还是都显示，用于下一次从另外页面回到当前页面的时候，显示的是用户上一次的操作。 剩下的就是 Mene 的初始化 和点击时间的处理了。这里就不贴出代码了。 TasksContract 中 View 层接口分析之前说过， TasksContract 适用于管理 View 层和 Presenter 层的接口的契约接口，我们希望 View 层的方法都是类似于 showXxxZzz() 形式的方法，用于改变 UI 的状态，那么根据上面的截面图，我们分析一下这里的 View 层需要改变哪些状态。 此处涉及到具体的业务逻辑，项目需求，包括每一个控件的点击事件，每一种状态的显示页面 。具体的思路就是，将每一个改变 UI 状态的操作都抽象成接口方法。 当我们从 Model 层取数据的时候，需要展示一个友好交互的页面，提示用户正在加载数据。这里对应接口： 1234567/** * 展示正在加载中的指示器 * * @param active true 展示 false 不展示 */void setLoadingIndicator(boolean active); 当从数据源重拿到数据之后，需要将数据展示到列表上。这里对应接口 1234567/** * 展示列表中的Task * * @param tasks tasks */void showTasks(List&lt;Task&gt; tasks); 当从数据源重拿到数据之后产生错误时回调 12345/** * 加载错误回调 */void showLoadingTasksError(); 点击右下角的 FloatingActionButton，会调到创建任务的界面。 12345/** * 展示添加任务界面,用于跳转至AddEditTaskActivity */void showAddTask(); 点击列表中已经存在的任务，会调转至任务详情页面（图 2.7所示界面），这个操作由点击列表 Item 触发。 123456/** * 展示Task的详细信息,跳转至 TaskDetailActivity * @param taskId taskId */void showTaskDetails`UI`(String taskId); 当任务被标记为 COMPLETED 时更新 UI 状态（图2.6所示），这个操作是 checkBox 被点击触发的。 12345/** * FilterType 被置为 completed 状态时回调 */void showTaskMarkedComplete(); 当任务被标记为 ACTIVE 时更新 UI 状态 （图2.7所示），这个操作是 checkBox 被点击触发的。 12345/** * FilterType 被置为 Active 状态时的回调 */void showTaskMarkedActive(); 当被标记为 COMPLETED 状态的任务被删除时 UI 状态的更新，这个操作是图 2.3 当中所示 Menu 中 Clear Completed 被点击时触发。 12345/** * 清除FilterType为Completed状态的Task */void showCompletedTasksCleared(); 展示所有状态为 ACTIVE 的任务，这个操作是图 2.4 当中所示 Menu 中 Active 被点击时触发 12345/** * 展示所有 FilterType 为 Active 的 Task 的回调 */void showActiveFilterLabel(); 没有状态为 ACTIVE 的任务，更新 UI 界面 12345/** * 展示没有 FilterType为 Active 时的界面 回调 */void showNoActiveTasks(); 展示所有状态为 COMPLETED 的任务，这个操作是图 2.4 当中所示 Menu 中 COMPLETED 被点击时触发 12345/** * 展示所有 FilterType 为 Completed 的Task的回调 */void showCompletedFilterLabel(); 没有状态为 COMPLETED 的任务，更新界面 12345/** * 展示没有 FilterType为 Completed 时的界面 回调 */void showNoCompletedTasks(); 展示所有的任务，这个操作是图 2.4 当中所示 Menu 中 All 被点击时触发 12345/** * 展示所有 FilterType的回调 */void showAllFilterLabel(); 当前还没有任务展示时，更新 UI 的状态 12345/** * 没有Task 时的回调 */void showNoTasks(); 当成功添加了一条任务之后，需要更新 UI 的状态， 12345/** * 展示add一条Task成功后的 回调 */void showSuccessfullySavedMessage(); 因为这里的 View 层是用 Fragment 对象实现的，所以这里用于判断当前 Fragment 视图是否还存在 1234567/** * 当前视图的活跃状态 * * @return true active&lt;p&gt;&lt;/p&gt;false destroy */boolean isActive(); 如图 2.4 所示，这里的显示的效果是使用 PopMenu 做的，所以当我们点击 ToolBar 上次右边的图标时，回调此方法 12345/** * 展示 Toolbar上面的Menu的 选择 展示 FilterType 的popmenu */void showFilteringPopUpMenu(); 可以发现 View 层接口大体分为四类： 涉及到数据更新或者数据获取的改变 UI 状态，第 6，7，8，9 ，11 ，13，15。 页面跳转，第 4 ，5 两个用于启动其他 Activity 的。 不涉及到数据更新和数据获取的改变 UI 状态，1，2，3，10，12 ，14。其中第 2 条只是展示已经获取到的数据，没有涉及到数据的获取和改变。 辅助方法 16，17 Contract 中 Presenter 层接口分析在 TasksContract 当中，不仅仅定义了 View 层的接口，并且还定义了 Presenter 层的接口。这一层的接口肯定是服务于 View 层的，应为 Presenter 层需要响应 View 层的事件，然后和 Model 层交互，然后再根据和 Model 层交互的接口，通知 View 层更新对应的 UI 状态。所以 Presenter 层接口的设置肯定与上面 View 层的 UI 状态改变接口有关，下面来分析一下： 针对 View 层的第 9， 11， 13 ，条需求，分别需要展示 ACTIVE COMPLETED 和所有状态的数据， 那么这个数据从哪儿来呢？就需要 Presenter 层来提供，所以这里需要有一个接口： 1234567/** * 从 `Model` 层获取数据的回调 * * @param forceUpdate 是否刷新 */void loadTasks(boolean forceUpdate); 并且 Presenter 层还需要记录下当前页面的展示哪种类型的数据 1234567/** * 设置当前列表显示的 Task 的 type * * @param requestType &#123;@link TasksFilterType&#125; */void setFiltering(TasksFilterType requestType); 还并且，记下当前页面展示的数据类型，是要在之前 TasksActivity 中的 onSaveInstanceState 方法中获取，然后保存的，所以这里需要提供一个 Getter 方法。 1234567/** * 拿到当前列表显示的 Task 的 type * * @return &#123;@link TasksFilterType&#125; */TasksFilterType getFiltering(); 针对 View 层的第 4 条需求，需要点击 FloatingActionButton 跳转至编辑界面，那么针对这个需求，Presenter 层提供一个接口方法给他调用： 12345/** * 添加新的 Task 的回调 */void addNewTask(); 其实这个方法在最终实现的时候，就是调用 View 第 4 个需求的接口：void showAddTask(); 然后在这个接口的实现方法就是实例化 Intent 然后 startActivityForResult。其实完全可以直接在 FloatingActionButton 的 onClick 回调方法里就调用其本身的 showAddTask 方法跳转至编辑页面，但是人家没有这样做，而是调用 presenter 的 addNewTask 方法，通过 Presenter 层的这个方法在去调用 View 层的 showAddTask 方法，为什么做么做？仔细看项目代码可以发现，View 层「不涉及到数据更新和数据获取的改变 UI 状态」类别的接口方法都是被 Presenter 层调用的，而 Presenter 层所有的接口方法都是被 View 层调用的，因为各自的接口方法是需要对方的事件来驱动。 所以为了保证这一特性的统一表现，这里就采取了这样迂回的方式，来跳转至编辑界面。 针对 View 层的第 5 条需求，点击列表 Item 的时候，会跳转至详情界面，这个过程和上面点击 FloatingActionButton 一样，不做分析。 1234567/** * 查看Task详情的回调 * * @param requestedTask special task */void openTaskDetails(@NonNull Task requestedTask); 针对 View 层第 6 条需求，需要将某一条任务标记为 COMPLETED 状态，那么不仅仅是在 UI 上要做改变，还要将数据源中的本条数据给标记为 COMPLETED 状态，所以 Presenter 层要提供这个需求的数据支撑： 1234567/** * 列表Item的checkBox 从false到true时的回调 * * @param completedTask special task */void completeTask(@NonNull Task completedTask); 针对 View 层的第 7 条需求，和上一条一样，不做分析。 1234567/** * 列表Item的checkBox 从true到false时的回调 * * @param activeTask special task */void activateTask(@NonNull Task activeTask); 针对 View 层的第 8 条需求，删除标记为 COMPLETED 的任务，不仅仅要在 UI 上做改变，在数据源中也是需要将它删除的，所以在 Presenter 层提供这个需求的数据支撑。 12345/** * 清除FilterType为Completed状态的Task */void clearCompletedTasks(); 针对 View 层的第 15 条需求，showSuccessfullySavedMessage 这个方法是成功添加了一条数据返回此界面之后调用，那么就本应该是在此界面的的 onActivityResult 方法中调用，但是由于和 Presenter 层第 4 个方法一样的原因，这里也是采取了迂回的方式，先通知 Presenter 层，再由 Presenter 层来回调。 12345678/** * 当一个Task成功添加进来时,返回到TasksFragment时的回调 * * @param requestCode requestCode * @param resultCode resultCode */void result(int requestCode, int resultCode); View 层接口的基类根据 MVP 模式的原理，View 层是一定持有一个 Presenter 层对象的引用的，所以这里创建一个所有 View 层接口的基类，里面就一个接口方法，用于设置 View 对应的 Presenter。 123456789public interface Base`View`&lt;T&gt; &#123; /** * `View`必须要实现的方法,保持对Presenter的引用 * @param presenter */ void setPresenter(T presenter);&#125; Presenter 层接口的基类由于每一次回到 View 层界面的时候，我们都需要展示当前需要被展示的数据（需要被展示的数据是根据当前的 FilterType 来决定的），由于 View 层不涉及数据的缓存，那么我们就需要有一个方法在每一次回到一个 View 层界面的时候都通知 Presenter 层去取数据。 123456789public interface BasePresenter &#123; /** * Presenter必须实现的方法,用于开始获取数据并且刷新界面, * 在Fragment的onResume方法中调用 */ void start();&#125; 对于 Fragment 来说，每一次回到一个 Fragment 的时候，onResume 都会调用，就放在这里调用适合。 TasksContract 接口分析这么多，最终这个接口长这个样子： 1234567891011public interface TasksContract &#123; interface `View` extends Base`View`&lt;Presenter&gt; &#123; //2.2小结中分析的所有接口 &#125; interface Presenter extends BasePresenter &#123; //2.3小结中分析的所有接口 &#125;&#125; 这个接口 View 层和 Presenter 层各自实现其中的子接口。 tasks 包下 View 层和 Presenter 层实现类接口都定义好了，接下来就是用 TasksFragment 和 TaskPresenter 分别去实现 TasksContract 中的接口了，这部分涉及到具体的业务逻辑，所以不做分析，这里只分析项目结构方面。下面笔者从 google 库中 fork 过来的，添加了部分注释： TasksContract.java TasksActivity.java TasksFragment .java TasksPresenter.java 小结 View 层和 Presenter 层接口方法 到这里，View 层和 Presenter 层的接口都都分析完了，回过头来再看看，可以发现一个很有意思的地方，在分析完 View 层接口之后，笔者将 View 层接口归纳为了四类，那么在结合 Presenter 层的接口方法看看就会发现，Presenter 层接口方法是针对上面总结的 「涉及到数据更新或者数据获取的改变 UI 状态」，「页面跳转」，这两类接口方法的辅助，去除掉「页面跳转」，这个不在 MVP 范畴之内，那么剩下的就是，「涉及到数据更新或者数据获取的改变 UI 状态」 这个类别下的接口方法了。 「涉及到数据更新或者数据获取的改变 UI 状态」 这个类别下的接口方法是需要数据作为支撑的，而 View 层本身只负责 UI 的状态改变，不涉及到数据的获取操作，所以这些数据就需要从 Presenter 层中获取。 获取到了之后，再到 Presenter 层的接口方法中去回调 View 层的 「不涉及到数据更新或者数据获取的改变 UI 状态」的接口方法。 这么一来，View 层和 Presenter 层通过 TasksContract 契约类，完美的契合在一起，这两层的实现类代码中，互相之间都是接口依赖，大大增加了代码的可扩展性。 View 层接口方法的设置完全是从业务逻辑出发的，也就是从需求的角度出发。 Presenter 层是服务于 Presenter 层，所以它的接口的设置是为了支撑 View 层的逻辑。。举个例子：比如说用户点击这个按钮，需要有什么样的一个效果，那么我就针对这个操作，在 View 层接口里写一个接口方法；获取数据成功之后，我们需要展示出来，针对这个操作在 View 层接口里写一个接口方法；没有获取到任何数据，需要给用户显示一个友好的界面，针对这个操作，又在 View 层接口里写一个接口方法。但是这些操作是需要有支撑的，因为 View 层本身是不具备它将要更新的 UI 所需要的的数据的，所以这时候就是靠 Presenter 层来支撑 。 这种方式，也让我联想到，如果是团队开发的话，当产品给出原型图了之后，针对每一张原型图当中每一个控件的操作，需要展示的状态，先定好接口，写好 Contract 契约接口，然后团队成员在到各自的分支上并行开发，是否可以大大提高工作效率？这个还有待商榷。 看完这个 Sample 之后的一些感受 如果不看人家 google 工程师的源码，只给我看 app 最后的效果，我也能百分百复制出来一个一模一样的，但是我的代码在复用性，鲁棒性，可扩展性方面肯定没有人家的棒，看这个项目的代码真的很舒服，行云流水般的感觉，在编码习惯方面有几点真的十分赞： 分包很明确，每一包下只有和这个包功能相关的代码，不用到处去找相关类，关看包结构就能得到项目大致结构。 包、类、变量、方法、接口等的命名十分规范，命名都是有意义的，更不存在什么 MyXXXX 这种命名方式，观看名字就能知道这个东西是干嘛的。 注释十分详细，虽然我在阅读的过程中，添加了中文注释，但是人家本身的英文注释就有很多，每一个文件都有注释用于说明这个文件的用途；用途不是那么显而易见的方法也都有注释，真的是大大减少了我们的阅读难度。这一点很多第三方的框架也做的特别棒，前阵子看 Universal-Image-Loader 的源码，注释也十分详细，并且使用 javadoc。 代码在多处做了容错性处理，变量只要在使用的时候，就会去 checkNullOrEmpty，这个项目里用的是 Guava 中的 Preconditions 工具类，很方便。 发现自己基础方面不够扎实，整个项目涉及到很多 Android 的基础知识，比如说 Activity 和 Fragment 的生命周期，重要生命周期方法的作用，调用时机；Activity 和 Fragment 之间的通信；关于 ToolBar 的使用；关于 Menu 菜单的使用；关于 android.support.v4.app.NavUtils 这个工具类的使用等等，不一一列举了。总之体现了一个问题，我真的还很菜。 contract 接口和 Model 层的设计，确实很棒，让传统 MVP 模式如虎添翼。 希望自己以后再工作当中，从编码习惯方面入手，增强代码的规范性，同时也不能忘了基础的巩固，要学的真的有很多。 好像是 Linux 的爸爸说过 Read the fuck code !阅读源码，真的可以学习很多姿势，也能暴露出自己身上存在的很多问题，当然了，前提是这个源码十分优秀，这个是谷歌官方的 Sample 库，我感觉维护这个库的人就是官方文档 API 示例编写的那一群老哥，因为很多代码的风格和使用的方式，和官方文档上一模一样，比如说在 Model 层使用 SQLite 的代码，就和官网上的文档一模一样，所以这个源码，必须是很优秀的！ TODO上面相当于只分析了 View 层和 Presenter 层的结构和实现思路，还有 Model 层没有分析，Model 层是这个 Sample 在传统 MVP 模式当中，除了 Contract 之外，最优雅的设计方式，由于篇幅的原因，Model 层相关的留到下一篇文章分析。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（七）终篇---关于对MVP模式中代码臃肿问题的思考","slug":"MVP7","date":"2017-11-05T13:27:15.000Z","updated":"2017-11-05T13:27:20.461Z","comments":true,"path":"2017/11/05/MVP7/","link":"","permalink":"http://zengfanyu.top/2017/11/05/MVP7/","excerpt":"摘要：在学习 MVP 模式的过程当中，见到很多文章都提到一句话：「使用 MVP 模式引入了 Presenter 层，这样可以将 View 层和 Model 层解耦，但是项目的代码量会大大增加，不过这个牺牲是值得的。」但是这个如果不做处理的话，随着项目体量的扩大，项目当中会充斥着很多相同逻辑的代码，是在是不能忍，通过前面几章的封装可以缓解这个情况，但是还剩下一个问题是目前解决不了的，那就是 Presenter 的管理问题和 View 层无关代码问题，这一篇就针对这两个问题记录一下思路。","text":"摘要：在学习 MVP 模式的过程当中，见到很多文章都提到一句话：「使用 MVP 模式引入了 Presenter 层，这样可以将 View 层和 Model 层解耦，但是项目的代码量会大大增加，不过这个牺牲是值得的。」但是这个如果不做处理的话，随着项目体量的扩大，项目当中会充斥着很多相同逻辑的代码，是在是不能忍，通过前面几章的封装可以缓解这个情况，但是还剩下一个问题是目前解决不了的，那就是 Presenter 的管理问题和 View 层无关代码问题，这一篇就针对这两个问题记录一下思路。 学习 MVP 模式的过程中引发的一些思考最近一个月都在学习 MVP 模式，自己也动手做了几个小 Demo，由于 Demo 规模不大，所以代码臃肿的问题没有很好的反映出来，不过却是反应出来了其他的问题。比如当我需要实现另外一个需求的时候，我需要去重新创建 M V P 三层的代码，而这三层的代码很多逻辑都是相似的，比如说 Model 层就是去访问服务器端请求数据，然后将数据回调到 Presenter 层，只是访问的服务器端 URL 地址不同，返回的数据不同，这个差异性通过对网络请求工具做封装，并且封装 Model 层相同逻辑代码，可以很好的解决；再比如说 View 层会涉及到很多 UI 界面的刷新问题，常用的 ProgressBar，Toast ，显示错误信息状态码等基本功能，也可以通过封装 BaseMvpActivity 和 IBaseView 来解决，所以这就是前面六篇文章的由来。至于代码臃肿所体现出的问题，我总结为如下两个： View 层中充斥这各种事件的分发和事件的注册，我们希望 View 层是这样的：只有 onXxxxZzzz() 形式的回调方法用于改变UI，比如： onLoadMessage(List&lt;Message&gt;) 回调在加载完 Message 之后来进行UI的更新，那么事件的注册和分发就需要到其他地方去处理。 View 层和 Prensenter 层接口的管理问题，比如当我们需要移植一个模块的时候，由于 View 层和 Presenter 是紧密相连的，所以这两层需要一同移植，不过可能由于项目体量的原因，Presenter 和 View 的接口比较多，没办法一次性的移植，需要不断的测试。 英国计算机学家说过一句话：All problems in computer science can be solved by another level of indirection.翻译成中文就是：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。比如十分复杂的Internet国际互联网络中数据传输的问题，也是通过分层来决绝的，这可以体现在 TCP/IP 四层模型和 OSI 七层模型当中。 这么复杂的问题都可以引入中间层来解决，那么 MVP 中的问题就更不在话下了。 关于解决上述两个问题的思路View 层臃肿问题解决思路第一个问题，天天_byconan，大神的博客中有很好的解决思路，下图也是摘抄自他的博客。 先上两张图： 引入 PresenterProxy 层 通过使用一个 Presenter 层代理的方式，在 PresenterProxy 中处理各种时间机制，View 中维护一个对 PresenterProxy 的引用，PresenterProxy 也实现了真实 Presenter 层的接口，这样就可以在 View 中通过代理调用真实的 Presenter 层对象。 引入 Controller 层 为 MVP 模式增加一层专门用于处理各种时间派发的 Controller 层，Controller 层的作用仅仅是用于处理事件，并根据事件通过维护的 Presenter 层对象派发到对应的业务当中去，也就是说 View 层只有一个 Controller 对象， View 层不会主动的去调用 Presenter 层对象，但是 Controller 层和 Presenter 层都可能回调到 View 层来刷新UI。 这两张图就为我们提供了很好的解决思路，虽然我还没有动手实践过，但是从思路上来说，是没有问题的。 Presenter 和 View 层接口管理问题解决思路在笔者查看了大量的文章资料之后，发现这个问题 Google 已经给出了一个十分好的的解决思路，这个答案就在 官方的TODO-MVP Sample里，这个 Demo 通过用 MVP 模式实现了一个TODO应用，先贴一下这个应用在 Android Studio 中的代码分包情况： 整个 APP 等架构十分的清晰，不愧是出自 Google 大牛之手！！！ 管理接口的核心类是每一个模块当中的 XXXXContract 接口 并且这个项目当中的 Model 层是它最大亮点， 上图中 data 包下就是它的 Model 层， TasksRepository 维护了两个数据源，一个是本地（SQLite 数据库），一个是远程（网络服务器），并且将不同的数据源抽象成为 TaskDataSource 接口，这种面向接口编程的思想，让我们很容易的修改数据源，或者是扩展数据源，这也是依赖倒置原则的体现。 放一下项目整体架构图： 出自：https://github.com/googlesamples/android-architecture/tree/todo-mvp/ 接下来准备好好研究一下这个项目的架构和实现，并且这个 Google 的开源库是用不同的架构去实现相同的 APP，提供了很多架构的基本应用：clean dagger rxjava databinding 等，有空一定好好研究。 又立 Flag MVP 模式也算是入门了吧，后面准备结合上面的 TODO-MVP 项目，在练练手，然后把上面提到的几个思路好好梳理一下，关于 TODO-MVP 项目也准备写一篇文章总结记录一下。 关于 Retrofit 的使用我也看了好几篇文章，基本的使用应该是没问题的了，不过在这个过程中，感觉自己缺乏服务器端知识，什么 RESTful API ，什么 URL 的构成什么的，没有系统的了解过(对，就是写 Retrofit 的网络请求接口的时候，有点迷失了~)，后面这一块要恶补一下。 下一个就是 Dagger2 了， 关于 Dagger2 也看了几篇文章，感觉它的概念性的东西确实挺多的，上手不是太容易，不过也没关系，慢慢来。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Dagger2基础内容归纳","slug":"Dagger","date":"2017-11-04T06:37:15.000Z","updated":"2017-11-04T10:08:19.466Z","comments":true,"path":"2017/11/04/Dagger/","link":"","permalink":"http://zengfanyu.top/2017/11/04/Dagger/","excerpt":"摘要：最近看了很多讲 Dagger2 的文章，发现Dagger中很多基础的概念问题真的挺缥缈，很难理解透彻，其中有几篇确实写得不错，这里将他们总结一下，底部给上参考文章链接。","text":"摘要：最近看了很多讲 Dagger2 的文章，发现Dagger中很多基础的概念问题真的挺缥缈，很难理解透彻，其中有几篇确实写得不错，这里将他们总结一下，底部给上参考文章链接。 @Inject@Inject 注解只是 JSR-330 中定义的注解,这个注解本身是没有意义的,它需要依赖于注入框架才有意义,用于标记需要被注入框架注入的方法,属性,构造方法,也就是说呗 @Inject 标记的就是用于提供依赖的. @Inject 定义123public @interface Inject &#123;&#125; @Inject 的使用 构造方法注入 @inject 注解在在构造器注入上又有两层意思 告诉 Dragger2 可以使用这个构造方法构建对象用于提供依赖 注入构造方法所需要的参数的依赖 属性注入 用于标注在属性上,被标注的属性不能用 private 修饰,否则无法注入 方法注入 标注在 public 方法上,Dagger2 会在构造方法执行结束之后,立刻调用被 @inject 标注的方法. 方法注入和属性注入没有本质的区别，那么什么时候用该使用方法注入，什么时候应该使用属性注入呢，比如依赖需要使用 this 对象的时候，就适合使用方法注入，因为方法注入是在构造方法执行结束之后就调用的，所以它可以提供安全的 this 对象。 Inject 的 弊端 假设我们现在依赖了第三方的框架,这个第三方的框架我们是不能修改的,所以我们无法注入. 如果某个用于提供依赖的类具有多个构造方法,我们只能标注一个,无法标注多个 当我们使用依赖倒置原则的时候，因为需要注入的对象是抽象的，因此也如法注入 @ComponentComponent 负责将 被依赖对象 给注入到 需要依赖对象 当中,类似于一个中间层. Component 定义Dagger2 是使用 @Component 来完成依赖注入的, 定义如下: 12345public @interface Component &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; Class&lt;?&gt;[] dependencies() default &#123;&#125;;&#125; 需要注意几点: Component 需要用接口来定义, 接口命名方式推荐为: *TargetClassName*Component 在编译之后,Dagger2 会生成 Dagger*TargetClassName*Component ,这是 *TargetClassName*Component 接口的实现 在 TargetClass 中使用 DaggerTargetClassNameComponent 就可以实现依赖注入 @Component 中定义方法的方式1. void inject(TargetClassName calss) Dagger2 会从 TargetClass 开始查找 @Inject 注解,自动生成依赖注入的代码,调用 inject 即可完成依赖的注入 2. TargetClass getTargetClass() Dagger2 会到 TargetClass 中寻找被@Inject 注解的构造方法,自动生成提供 TargetClass 依赖的代码,这种方式一般用于为其他的 Component 提供依赖,即一个 Component 作为另外一个 Component 的依赖 3. 使用 @SubComponent 的方式 123456789@Componentinterface AComponpent &#123; XxxComponent plus(Module... modules)&#125;@Subcomponent(modules = xxxxx)interface XxxComponent &#123;&#125; xxxComponent 是该 AComponpent 的依赖，被 @Subcomponent 标注。 modules 参数则是 xxxComponent 指定的 Module。 在重新编译后，Dagger2 生成的代码中，Subcomponent 标记的类是 Componpent 的内部类。 总结一下 目前为止(后面还有Module注解) Component 的作用: Dagger2 以 Component 中定义的方法作为入口,到 TargetClass 中去寻找被 @Inject 标注的属性,查找到这个属性之后,就会去接着查找该属性对应的 用 @Inject 标注的构造函数,剩下的工作就是初始化该属性的实例,并且将实例赋值给属性.这是通过生成一系列提供依赖的 Factory 类和注入依赖的 Injector 类,来实现的. Component 和 Inject 的关系小结 用 @Inject 标注目标类中的其他类 用 @Inject 标注其他类中的构造方法 若其他类中还依赖于别的类，那么重复上述两个步骤 调用 Component 的 injectXXX 方法，Component 会把目标类依赖的实例给注入到目标类当中，用于初始化目标类当中的依赖。 @ModuleModule 定义1234public @interface Module &#123; Class&lt;?&gt;[] includes() default &#123;&#125;;&#125; @Module 引入原因如果我们项目当中使用了第三方的框架，那么可能某个 TargetClass 就持有对框架中某个类 C 实例的引用，那么按照上面两个注解的方式，我们就需要到框架当中 C 类的构造方法上面去标注一个 @Inject，况且不说构造方法多样性的问题（比如 Universal-Image-Loader 的 ImageLoader 类构造方法二三十个），框架当中的源码我们是不可以修改的啊。这个时候 @Inject 就失效了，我们就需要一个新的工具去注解，这时就引入了 @Module 了。 12345678@Modulepublic class ModuleClass&#123; //A是第三方类库中的一个类 A provideA()&#123; return A(); &#125;&#125; Module 是一个简单工厂模式，Module 里面的方法基本上都是创建类实例的方法，那么此时如何让 Component 和 Module 产生联系呢？ Component 的新职责Component 是注入器，它一端连接 TargetClass，另一端连接 TargetClass 依赖的实例，它把 TargetClass 依赖实例注入到 TargetClass 中。上文中的 Module 是一个提供类实例的类，所以 Module 应该是属于 Component 的实例端的（连接各种目标类依赖实例的端），Component 的新职责就是管理好 Module，Component 中的 modules 属性可以把 Module 加入 Component，modules 可以加入多个 Module。 那么接下来的问题就是，如何将 Module 中各种提供实例的方法同 TargetClass 中 Inject 标注的类属性给链接起来，这个时候 Provides 就可以出来了。 ##@Provides## ###Provides 定义### 123public @interface Provides &#123;&#125; Module 中创建实例的方法是用 Provides 标注的，之前说过，Component 搜索到 TargetClass 中用 @Inject 标注的属性之后，他就会去这个属性的类中寻找标注了 @Inject 的构造方法 ，其实在这个步骤之前，它优先去 @Module 标注的类中查找 @Provides 标注的用于创建实例的方法，如果没有找到，那么才会去查找标注了 @Inject 的构造方法。 这么一来，第三方类库的依赖注入问题就解决了。 上述注解小结1.Inject 是用于标注 TargetClass 中的依赖和依赖类中的构造函数的。 2.Component 是一个注入器（Injector） ，同时也起着桥梁的作用， 一端是类创建实例端(即负责创建生产类的实例),另外一端是 TargetClass 端（即需要进行依赖初始化的类），同时也负责管理 Module。 3.Module 和 Provides 是为觉得第三方库注入问题而引出的，Module 是一个简单工厂模式，Module 包含创建实例的方法，这个方法用 Provides 来标注。 4.创建依赖类有两个途径：通过 @Inject 标注的构造方法来创建； 通过 @Provides 标注的创建实例的方法来创建； 但是后者的优先级要大于前者，也就是说，Component 如果找到了后者，他就不会再接着去找前者。 5.@Module 要和 @Provides 配套使用，并且 @Component 也指定了该 Module 的时候，才能正常使用，@Module 告诉 @Component ，你可以从我这儿标注了 @Privides 的方法中获取实例。 6.Component 和 Module 是匹配关系 ， Component 依赖哪一个 Module 就需要在注解中用 muduls 属性标明。 @Inject @Component @Module @Provides 就是 Dagger2 框架中最核心的部分，奠定了整个框架的基础，下面的标签就是针对细节问题的处理。 @Qualifier问题的引出现在有种情况，用上述注解无法解决： 根据依赖倒置原则，我们应该面向接口编程，或者是面向抽象编程，在 Java 中多态的性质很好的支持了这一原则，所以我们经常会在类中申明的是某一属性的接口，或者是抽象类，这样操作在程序编译的时刻，是不能确定这个属性的具体实例是哪一个子类，只能在运行时才能确定下来，那么这个时候 Component 怎么知道应该将哪一个子类给注入到 TargetClass 的属性当中 ？ 基于上面两个问题，就提出了 @Qualifier 注解，它就是用于解决上述问题的。 这个时候就需要给各个 抽象类或者接口 的子类的构造方法标注 @Qualifier，类似于给他们一个 ID ，通过这个 ID 就可以区分不同的子类。 Qualifier 的定义123public @interface Qualifier &#123;&#125; 这个注解跟 @Inject 一样，不是 Dagger 定义的， 而是 JSR-330 中定义的。 Qualifier 是用于定义注解的。 Qualifier 使用方法 使用 @Qualifier 根据子类的不同，分别定义新的注解，注解要有含义 分别使用新的注解去标注生成不同子类实例的地方，然后要使用哪一个子类的实例，是到抽象属性上标注子类对应的新的注解。 @Scope 和 @SingleScole 的定义123public @interface Scope &#123;&#125; 也是 JSR-330 定义的，不是 Dagger 中定义的 用于自定义注解 @Single 是 @Scope 的默认实现，如下： 12345@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; Scope 的作用 它的作用只是保证依赖在 @Component 中是唯一的，可以理解为“局部单例”。 @Scope 是需要成对存在的，在 Module 的 Provide 方法中使用了 @Scope，那么对应的 Component 中也必须使用 @Scope 注解，当两边的 @Scope 名字一样时（比如同为 @Singleton）, 那么该 Provide 方法提供的依赖将会在 Component 中保持“局部单例”。 而在 Component 中标注 @Scope，provide 方法没有标注，那么这个 Scope 就不会起作用，而 Component 上的 Scope 的作用也只是为了能顺利通过编译。 这么说 @Single 是没有创建单例的能力，因为他只是保证在 Component 中的唯一的，那怎么实现真正的单例呢？ 单例的实现 依赖在 Component 中是单例的（供该依赖的 provide 方法和对应的 Component 类使用同一个 Scope 注解。） 对应的 Component 在 App 中只初始化一次，每次注入依赖都使用这个 Component 对象。（在 Application 中创建该 Component） Lazy这个比较简单，延迟加载模式，用 Lazy&lt;T&gt; 装饰需要被 @Inject 标注的属性 T ，这样，在 Inject 的时候并不会初始化它，而是在使用 T 的时候，通过 T.gey() 来得到他的实例，然后再使用。 Component 组织方式这是重中之重，前面的概念都是做铺垫，这里从一个 APP 的角度将他们融合起来。 一个app中应该根据什么来划分Component假如一个 app （app 指的是 Android app）中只有一个 Component，那这个 Component 是很难维护、并且变化率是很高，很庞大的，就是因为 Component 的职责太多了导致的。所以就有必要把这个庞大的 Component 进行划分，划分为粒度小的 Component。那划分的规则这样的： 要有一个全局的 Component (可以叫 ApplicationComponent ),负责管理整个 app 的全局类实例（全局类实例整个 app 都要用到的类的实例，这些类基本都是单例的） 每个页面对应一个 Component，比如一个 Activity 页面定义一个 Component，一个 Fragment 定义一个 Component。当然这不是必须的，有些页面之间的依赖的类是一样的，可以公用一个 Component。 第一个规则应该很好理解，具体说下第二个规则，为什么以页面为粒度来划分 Component？ 一个 app 是由很多个页面组成的，从组成 app 的角度来看一个页面就是一个完整的最小粒度了。 一个页面的实现其实是要依赖各种类的，可以理解成一个页面把各种依赖的类组织起来共同实现一个大的功能，每个页面都组织着自己的需要依赖的类，一个页面就是一堆类的组织者。 划分粒度不能太小了。假如使用 mvp 架构搭建 app，划分粒度是基于每个页面的m 、v 、p 各自定义 Component 的，那 Component 的粒度就太小了，定义这么多的 Component，管理、维护就很非常困难。 所以以页面划分 Component 在管理、维护上面相对来说更合理。 组织Component我们已经把一个 app 按照上面的规则划分为不同的 Component 了，全局类实例也创建了单例模式。问题来了：其他的 Component 想要把全局的类实例注入到目标类中该怎么办呢？这就涉及到类实例共享的问题了，因为 Component 有管理创建类实例的能力。因此只要能很好的组织 Component 之间的关系，问题就好办了。具体的组织方式分为以下2种： 依赖方式一个 Component 是依赖于一个或多个 Component，Component 中的 dependencies 属性就是依赖方式的具体实现 包含方式一个 Component 是包含一个或多个 Component 的，被包含的 Component 还可以继续包含其他的 Component。这种方式特别像 Activity 与 Fragment 的关系。SubComponent 就是包含方式的具体实现。 Dagger 注入一次的流程步骤1：查找 Module 中是否存在创建该类的方法。 步骤2：若存在创建类方法，查看该方法是否存在参数 步骤2.1：若存在参数，则按从**步骤1**开始依次初始化每个参数 步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 步骤3：若不存在创建类方法，则查找 Inject 注解的构造函数，看构造函数是否存在参数 步骤3.1：若存在参数，则从**步骤1**开始依次初始化每个参数 步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 总结对象 Android：dagger2让你爱不释手-基础依赖注入框架篇 Android：dagger2让你爱不释手-重点概念讲解、融合篇 Android：dagger2让你爱不释手-终结篇","categories":[{"name":"Dagger","slug":"Dagger","permalink":"http://zengfanyu.top/categories/Dagger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"Dagger","slug":"Dagger","permalink":"http://zengfanyu.top/tags/Dagger/"}]},{"title":"Android当中的MVP模式（六）View 层 Activity 的基类--- BaseMvpActivity 的封装","slug":"MVP6","date":"2017-11-03T12:37:15.000Z","updated":"2017-11-04T09:49:07.998Z","comments":true,"path":"2017/11/03/MVP6/","link":"","permalink":"http://zengfanyu.top/2017/11/03/MVP6/","excerpt":"摘要：使用封装之后的 MVP 模式实现一个新的界面，也就是 Vie 层，那么就需要去实现 IBaseView 接口，可能还需要针对当前要实现的界面情况，在 IBaseView 的基础之上派生出一个新的接口 IXxxView,之前的 SohuAlbumInfoActivity 用于展示搜狐电视剧主要信息的 View 就是这种情况,由 IBaseView 派生了一个 ISohuSerials ,再由 SohuAlbumInfoActivity 去实现,那么随着需要展示的界面越来越多,它们坐着大量重复的工作,我们就要像个方法来简化这个过程了。","text":"摘要：使用封装之后的 MVP 模式实现一个新的界面，也就是 Vie 层，那么就需要去实现 IBaseView 接口，可能还需要针对当前要实现的界面情况，在 IBaseView 的基础之上派生出一个新的接口 IXxxView,之前的 SohuAlbumInfoActivity 用于展示搜狐电视剧主要信息的 View 就是这种情况,由 IBaseView 派生了一个 ISohuSerials ,再由 SohuAlbumInfoActivity 去实现,那么随着需要展示的界面越来越多,它们坐着大量重复的工作,我们就要像个方法来简化这个过程了。 回顾前几篇中 View 层的写法根据MVP系列第二篇当中的分析， View 层的职责如下： Loading 状态的展示隐藏 接收 Presenter 层处理后的数据 接收 Presenter 层处理后的错误信息 接收 Presenter 层处理后的服务器拒绝信息 所以当就将着一些职责抽象成方法，放在 IBaseView 接口中，看看之前的的 IBaseView： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by fanyuzeng on 2017/10/20. * @author : ZengFanyu */public interface IBaseView &#123; /** * 进行耗时操作时的用户友好交互接口，比如显示ProgressBar * * @param isShow * @author zfy * @created at 2017/10/21/021 14:12 */ void showProgress(boolean isShow); /** * 显示网络请求错的的接口 * * @param errorCode * @param errorDesc * @param errorUrl * @author zfy * @created at 2017/10/21/021 14:14 */ void showOkHttpError(int errorCode, String errorDesc, String errorUrl); /** * 现实服务器端请求错误的接口 * * @param errorCode * @param errorDesc * @author zfy * @created at 2017/10/21/021 14:14 */ void showServerError(int errorCode, String errorDesc); /** * 请求成功或者失败之后，对应UI做出改变的接口 * * @param isSuccess * @author zfy * @created at 2017/10/21/021 14:15 */ void showSuccess(boolean isSuccess); View 层每需要添加一个类， View 层的对象都需要在它的基础上去实现，比如说，在 MVP系列第三篇中，需要对搜狐视频电视剧频道的主要信息做分页展示，当时是在 IBaseView 的基础上派生出了一个 ISohuSerials ： 1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 然后再使用 SohuAlbumInfoActivity 去实现这个接口，对 IBaseView 和 ISohuSerials 中的方法又做了一遍实现，但是这次的实现过程，跟MVP系列第二篇中的 LatestNewsTitleActivity 实现的功能几乎一致，并且这个时候，我就意识到 IBaseView 接口设计的缺陷，我们在 IBaseView 的基础上派生出 ISohuSerials 接口 ILatestNewsView 接口，无非就是要展示不同类型的数据，那这个功能完全可以整合进 IBaseView 接口中，至于不同页面的数据类型不同，我们完全可以使用泛型来解决。 下面就来解决这两个问题： 将展示 Presenter 层实例好的数据的方法，由派生接口整合至基类接口中，使用泛型解决数据类型不同的问题。 封装 BaseMvpActivity，实现共有逻辑，子类不重复处理 View 层基类接口（IBaseView）中的方法。 IBaseView 的重构再回顾一下，之前要展示知乎日报的最新消息的标题内容，我写了一个 ILatestNewsView 接口，它长这样： 12345public inerface ILatestNewsView extends IBaseView &#123; void showLatestNewsTitle(List&lt;String&gt; titles)&#125; 后来又需要展示搜狐电视剧主要信息，于是写了一个 ISohuSerials ，： 12345public interface ISohuSerials extends IBaseView &#123; void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 当时怎么想的，要整个这接口出来 - - ！ 现在把他们都整合进 IBaseView： 12345678910public interface IBaseView&lt;Data&gt; &#123; //省略代码/** * 显示presenter层处理好之后的数据 * @param data data */ void showDataFromPresenter(Data data); 此处添加了一个泛型 Data ，它就可以用于指代上面两个接口中的 List&lt;String&gt; titles 和 List&lt;VideoInfo&gt; videoList ，或者是其他的数据了类型，然后在实现接口的类中去指明参数的类型就可以动态的更改它的类型了。 BaseMvpActivity 的封装上述是对之前遗留问题的一个解决，从这儿开始才正式对基类 BaseMvpActivity 进行封装。 ToolBar 的统一处理首先， Demo 是在 API 25 ，所以对 ToolBar 也要有良好的支持，所以首先是对 ToolBar 的封装，将 ToolBar 写到一个单独的 Layout 文件之中，方便其他文件引用。top_action_bar： 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt;&lt;!-- android:popupTheme 用于自定义弹出的菜单的样式--&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_tool_bar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" android:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:titleTextColor=\"#ffffff\" &gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 在 BaseMvpActivity 中的统一处理如下： 1234567891011121314151617protected void setSupportActionBar() &#123; if (mToolbar != null) &#123; setSupportActionBar(mToolbar); &#125;&#125;protected void setActionBarIcon(int resId) &#123; if (mToolbar != null) &#123; mToolbar.setNavigationIcon(resId); &#125;&#125;protected void setSupportArrowActionBar(boolean isSupport) &#123; getSupportActionBar().setDisplayHomeAsUpEnabled(isSupport);&#125; 这样处理了之后，在子类当中，就可以直接调用上述方法，就可以使用 ToolBar了， 当然，对 ToolBar 的自定义需要另外去处理。 BaseMvpActivity 的布局文件的处理由于 BaseMvpActivity 是要作为 MVP 模式下，所有 View 层的基类，所以它自己需要有布局文件，将 IBaseView 中的接口实现， activity_base_mvp： 123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/top_action_bar\"/&gt; &lt;TextView android:id=\"@+id/id_tip_content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_horizontal\" android:textSize=\"16sp\" android:text=\"tip\"/&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:id=\"@+id/id_content_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;ProgressBar android:id=\"@+id/id_progress_bar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:visibility=\"gone\"/&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 第 7 行的 include 文件，就是对上面 top_action_bar 的引用。 第 10 行的 TextView 这里用来实现 IBaseView 中 showOkHttpError 和 showServerError接口的。 第 22 行的 FrameLayout 很重要，看 id 就知道了，它是用于展示子类页面的方法的，直接将子类的布局文件给 add 进来。类似于： 1234View contentView = LayoutInflater.from(this).inflate(R.layout.activity_album_view, null);FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);mContentContainer.addView(contentView, lp); 第 27 行的 ProgressBar 就是用于实现 IBaseView 中 showProgress 的。 BaseMvpActivity 对 IBaseView 的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * @author:fanyuzeng * @date: 2017/10/30 13:50 * @desc: */public abstract class BaseMvpActivity&lt;Data&gt; extends AppCompatActivity implements IBaseView&lt;Data&gt; &#123; private static final String TAG = \"BaseMvpActivity\"; protected Toolbar mToolbar; protected ProgressBar mProgressBar; protected TextView mTipView; protected FrameLayout mContentContainer; protected Handler mHandler = new Handler(Looper.getMainLooper()); protected Context mContext; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_base_mvp); mContext = this; mToolbar = bindViewId(R.id.id_tool_bar); mProgressBar = bindViewId(R.id.id_progress_bar); mTipView = bindViewId(R.id.id_tip_content); mContentContainer = bindViewId(R.id.id_content_container); beforeInitViews(); initViews(); afterInitViews(); &#125; protected &lt;T extends View&gt; T bindViewId(int resId) &#123; return (T) findViewById(resId); &#125; //统一处理ToolBar @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTipView.setText(\"errorCode:\" + errorCode + \",errorDesc:\" + errorDesc + \",errorUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTipView.setText(\"errorCode:\" + errorCode + \",errorDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContentContainer.setBackgroundResource(android.R.color.white); &#125; else &#123; mContentContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: finish(); break; default: break; &#125; return super.onOptionsItemSelected(item); &#125; /** * 子类实现,用于初始化控件 */ protected abstract void initViews(); /** * 子类实现 在初始化控件之后进行的操作 */ protected abstract void afterInitViews(); /** * 子类实现, 在初始化控件之前的操作 */ protected abstract void beforeInitViews();&#125; 做了几点事情 实现了 IBaseView 中的接口 对 ToolBar 做统一处理 findViewById方法处理 Menu Item 中返回按键的处理 还有一个问题，似乎少了一个方法？就是在上一小节中，整合进 IBaseView 接口中的 void showDataFromPresenter(Data data) ,还没有实现。由于这里的 BaseMvpView 是 abstract 的，所以它可以不实现，也实现不了，因为实现这方法需要知道泛型参数 Data 的具体类型，所以这个函数是留给子类去实现的。上面三个抽象方法也很好理解，就是用于子类初始化操作的，并且都在基类初始化之后才执行，这一点很重要，因为子类中是需要将布局文件给 add 到基类布局当中的，所以基类的组件也必须提前初始化好。下面就看看子类中是如何处理的。 SohuAlbumInfoActivity 的重构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @author：ZengFanyu * Function: */public class SohuAlbumInfoActivity extends BaseMvpActivity&lt;List&lt;VideoInfo&gt;&gt; &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam = new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; private boolean mIsFromRefresh = false;// private View mContentView; @Override protected void beforeInitViews() &#123; mRecyclerView = new PullLoadRecyclerView(this); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); mContentContainer.addView(mRecyclerView, lp); // View contentView = LayoutInflater.from(this).inflate(R.layout.activity_album_view, null);// FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);// mContentContainer.addView(contentView, lp); &#125; @Override protected void initViews() &#123; setSupportActionBar(); //表示当前页面支持ActionBar setTitle(TAG); setSupportArrowActionBar(true); mAlbumPresenter = new AlbumPresenter(this, Album.class); mTipView.setText(TAG);// mRecyclerView = (PullLoadRecyclerView)mContentView.findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); &#125; &#125;); &#125; @Override protected void afterInitViews() &#123; &#125; @Override public void showDataFromPresenter(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); mTipView.setText(TAG); &#125; &#125;); &#125; &#125;&#125; 15 行的 beforeInitViews 方法，就是用于初始化子类的布局的，由于这个子类布局比较简单， 就是一个 RecyclerView ，所以可以直接用代码实现，然后给 add 进父类的 mContentContainer，或者用下面注释掉的，常规尝试来实现。 第 5 行，泛型参数为 List&lt;VideoInfo&gt; ,这个参数就是用于上面提到的，未实现的方法当中的，指定了泛型参数的类型。 第 26 行的 initViews 方法就用户初始化子类的 View showDataFromPresenter 的写法和未封装之前是一样的。 LatestNewsTitleActivity 的重构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author ZengFanyu */public class LatestNewsTitleActivity extends BaseMvpActivity&lt;List&lt;String&gt;&gt; &#123; private ListView mListView; private LatestNewsPresenter mBasePresenter; LatestNewsAdapter mAdapter; private View mContentView; @Override protected void beforeInitViews() &#123; mContentView = LayoutInflater.from(this).inflate(R.layout.activity_latest_news, null); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); mContentContainer.addView(mContentView, lp); &#125; @Override protected void initViews() &#123; mBasePresenter = new LatestNewsPresenter(this, LatestNews.class); mTipView.setText(LatestNews.class.getSimpleName()); mListView = (ListView) mContentView.findViewById(R.id.id_list_view); Button btnLatestNews = (Button) mContentView.findViewById(R.id.id_btn_latest_news); btnLatestNews.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mBasePresenter.requestServer(null); &#125; &#125;); &#125; @Override protected void afterInitViews() &#123; &#125; @Override public void showDataFromPresenter(List&lt;String&gt; titles) &#123; if (mAdapter != null) &#123; mAdapter.clear(); mAdapter = null; &#125; mAdapter = new LatestNewsAdapter(titles, mContext); mListView.setAdapter(mAdapter); mAdapter.notifyDataSetChanged(); mTipView.setText(LatestNews.class.getSimpleName()); &#125;&#125; 写法和上面一样，但是比起之前的代码量来说，已经少了很多了，并且对比这两个子类，都没有重复的实现方法，只专注于自己需要实现的逻辑。 还有其他的 View 层类和上述的实现过程类似，此处不再赘述。 下一篇这个系列的最后一篇准备些关于 MVP 模式在开发中使用，随着项目的复杂程度的提高， Presenter 会越来越臃肿的问题的解决思路。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（五）封装之后的OkHttp工具在Model层的使用","slug":"MVP5","date":"2017-11-02T12:37:15.000Z","updated":"2017-11-04T09:39:14.077Z","comments":true,"path":"2017/11/02/MVP5/","link":"","permalink":"http://zengfanyu.top/2017/11/02/MVP5/","excerpt":"摘要:在上一篇中对 OkHttp 进行了简单的封装,但是没有使用到这个系列当中的 Demo 里面,这一章就使用上一篇封装的 OkHttp 工具,替换掉之前 Demo 里面的 Model 层的网络请求.并且之前的部分接口方法都没有使用,比如说 IBasePresenter 接口中的 HashMap getParams() 方法, IBasePaginationPresenter 中的 boolean hasMoreData() 方法，算是对上一篇的补充。","text":"摘要:在上一篇中对 OkHttp 进行了简单的封装,但是没有使用到这个系列当中的 Demo 里面,这一章就使用上一篇封装的 OkHttp 工具,替换掉之前 Demo 里面的 Model 层的网络请求.并且之前的部分接口方法都没有使用,比如说 IBasePresenter 接口中的 HashMap getParams() 方法, IBasePaginationPresenter 中的 boolean hasMoreData() 方法，算是对上一篇的补充。 Model 层原来的写法拿分页数据获取的 Model 层举例,当时在 SohuAlbumModel 中是这样获取数据的: 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void sendRequestToServer(Param param) &#123; String validUrl = null; Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"has more data ?\" + mPaginationPresenter.hasMoreData()); if (param != null &amp;&amp; !TextUtils.isEmpty(url) &amp;&amp; mPaginationPresenter.hasMoreData()) &#123; validUrl = getValidUrl(url, param); Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl); &#125; if (!TextUtils.isEmpty(validUrl)) &#123; HttpUtils.executeByGet(validUrl, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \"); e.printStackTrace(); mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\"); mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url); &#125; String responseJson = response.body().string(); Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson); mPaginationPresenter.accessSuccess(responseJson); &#125; &#125;); &#125; else &#123; Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\"); &#125;&#125;private String getValidUrl(String url, Param param) &#123; return String.format(url, param.getPageIndex(), param.getPageSize());&#125; url 当中的参数是直接在 sendRequestToServer 方法中传递进来的,这么一来会让 Model 层的职责变得不那么单一,因为 Model 层只应该负责数据相关的工作,此处的 params 传递进来,还需要进行一个 url 的拼接工作,所以在这里是可以优化的地方。 在看看上一篇中的 OkHttpManager 类中请求服务器数据的核心方法： 123456789101112131415161718192021/** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 使用 OkHttpManager 来请求服务器获得数据，第二个参数 HashMap&lt;String, String&gt; paramsMap 就是已经在 Presenter 层中处理好的键值对参数，然后在 CommonRequest.createGetRequest(baseUrl, requestParams); 或者是 CommonRequest.createPostRequest(baseUrl, requestParams) 中就已经把完整的 url 拼接出来了。具体如何拼接，如何构造 Request 对象，Model 层完全不用关心，它只需要在请求成功或者是请求失败的回调接口中将数据回调到 Presenter 层去即可。 那么现在就开始重构 Model 层的方法。 Model 层现在的写法12345678910111213141516171819202122@Overridepublic void sendRequestToServer() &#123; if (mPaginationPresenter.hasMoreData()) &#123; OkHttpManager.getInstance().requestServerData(method, baseUrl, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; @Override public void onSuccess(Object responseObj) &#123; String responseJson = (String) responseObj; Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); mPaginationPresenter.accessSuccess(responseJson); &#125; @Override public void onFailure(OkHttpException exception) &#123; Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode()); mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url); &#125; &#125;, null)); &#125;else &#123; Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"No more data!\"); &#125;&#125; 是不是简单了很多！和之前的方法相比较，有三处不同的地方： 第 2 行的 sendRequestToServer() 方法中已经没有了 param 参数了。（那么参数从哪儿来呢？） 第 3 行多了一个 hasMoreData() 的方法，用于判断服务器端还有没有更多的数据。若没有，那就没有必要去请求了。它是在哪儿初始化的？ 第 4 行的多了 mPaginationPresenter.getParams() ，它是在什么地方初始化的? 第 4 行的 baseurl 不是之前 Model 层的 url 下面就解释为什么可以这么操作。 BasePaginationPresenter 的修改观察之前 Model 层的写法就知道，这个地方的参数，主要是从其中取出 pageIndex 和 pageSize ，用于拼接新的 url ，然后再请求数据，这儿不需要这个参数了， 那肯定就是有地方已经提供了这个参数了咯。 对，就是 mPaginationPresenter.getParams() 这个之前没有用过的方法，先回顾一下这个方法在哪儿定义的： 1234567891011public interface IBasePresenter&lt;Param&gt; &#123; //省略部分代码 /** * 在Model层中调用，此方法用于获取Presenter层处理好的参数 * @author zfy * @return 请求参数 * @Created at 2017/10/21/021 15:05 */ HashMap&lt;String, String&gt; getParams();&#125; 在第二篇中，针对每一层封装的时候，这个接口就已经定义好了，只是一直没有使用上，在这儿就用上了。而 BasePaginationPresenter 类是实现这个街口的，并且这个 Presenter 是分页请求数据中 Presenter 层的基类，在第三篇也提到过。下面看看 BasePaginationPresenter ： 1234567891011121314151617181920212223242526272829303132333435/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePaginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; //省略部分代码 /** * 子类实现，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); /** * 子类实现,用于返回请求服务器的url当中的参数 * * @return HashMap&lt;String,String&gt; url 中的 kay value 对 */ public abstract HashMap&lt;String, String&gt; getHttpRequestParams(); //省略部分代码 @Override public HashMap&lt;String, String&gt; getParams() &#123; return getHttpRequestParams(); &#125; @Override public boolean hasMoreData() &#123; return serverHaveMoreData(); &#125;&#125; 只贴出和之前不同的部分， 多了一个 serverHaveMoreData() 抽象方法，子类去实现的，用于判断服务器还有没有更多的数据。 多了以个 getHttpRequestParams() 抽象方法，子类去实现，用于将参数填充到 HashMap 中，供 Model 层使用。 接下里看看子类 AlbumPresenter 的实现： AlbumPresenter 的修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private int mTotalCount=-1; public AlbumPresenter(BaseMvpActivity baseListView, Class&lt;Album&gt; aClass) &#123; super(baseListView, aClass); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL_BASE); &#125; //省略代码 @Override public void serverResponse(Album album) &#123; //省略代码 mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际适用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); //第一次需要返回true 才能进到 serverResponse 方法中去初始化 mTotalCount 值 return mTotalCount == -1 || (pageIndex * pageSize) &lt;= mTotalCount; &#125; @Override public HashMap&lt;String, String&gt; getHttpRequestParams() &#123; HashMap&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); paramsMap.put(\"cid\", \"2\"); paramsMap.put(\"o\", \"1\"); paramsMap.put(\"plat\", \"6\"); paramsMap.put(\"poid\", \"1\"); paramsMap.put(\"api_key\", \"9854b2afa779e1a6bff1962447a09dbd\"); paramsMap.put(\"sver\", \"6.2.0\"); paramsMap.put(\"sysver\", \"4.4.2\"); paramsMap.put(\"partner\", \"47\"); paramsMap.put(\"page\", String.valueOf(mParam.getPageIndex())); paramsMap.put(\"page_size\", String.valueOf(mParam.getPageSize())); return paramsMap; &#125;&#125; 与之前实现不同地方在于： 构造方法当中设置的 url ，现在是 baseUrl ，后面的参数由 getHttpRequestParams方法生成，在CommonRequest 中生成完整 url。 serverResponse() 方法中，对 mTotalCount 进行了初始化， 这个值就是记录服务器端一共有多少条数据的。 serverHaveMoreData()拿当前已经加载的数据条数和 mTotalCount 进行对比，判断是否还有数据。 getHttpRequestParams() 构造参数的 HashMap 。 小结从这一章的从重构部分代码，很明显可以看到，各层之间的依赖关系： 主要是替换网络请求的工具，那么就是只涉及到 Model 层的改动。 这里 Presenter 层改动了，其实是不需要改动的， 这里改动了的原因是，我把之前没有实现的功能补上了，并且将sendRequestToServer() 的参数去掉了导致的。 可以发现， View 层代码没有进行一点修改，也就是 Activity 并没有动。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（四）插曲-封装OkHttp","slug":"MVP4","date":"2017-10-27T14:37:15.000Z","updated":"2017-10-29T12:38:18.194Z","comments":true,"path":"2017/10/27/MVP4/","link":"","permalink":"http://zengfanyu.top/2017/10/27/MVP4/","excerpt":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，并且可用性也不高，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。","text":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，并且可用性也不高，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。 官方给的例子 同步方法 1234567891011OkHttpClient client = new OkHttpClient();String run(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string();&#125; 异步方法 1234567891011121314151617OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125; 封装思路结合上面异步方法，稍作分析，涉及到如下几个对象 OkHttpClient , Request , Call,Response ,其他的都一些方法的调用，而 Response 是返回结果的对象，所以我们的封装应该重点针对剩余三个对象来进行。 RequestRequest 在 Okhttp 当中是抽象出来的一个请求对象，它封装了请求报文信息：请求的 Url 地址，请求的方法（Get Post等），各种请求头（Content-Type Cookie）以及可以选择的请求体，一般通过内部的 Builder 类来构建对象，建筑者设计模式。 那么我们这里就针对 Post Get 两种请求方式做封装，但是这里又涉及到一个问题，就是我们还需要参数，用于拼接请求 Url 的参数，举个栗子： 这是搜狐电视剧频道的 API 接口： 12http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22?cid=2&amp;o=1&amp;plat=6&amp;poid=1&amp;api_key=9854b2afa779e1a6bff1962447a09dbd&amp;%22%20+%20%22sver=6.2.0&amp;sysver=4.4.2&amp;partner=47&amp;page=1&amp;page_size=10 这么看可能特别的麻烦，我们把它拆分一下： 12String baseUrl=http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22 然后剩下的都是参数了，以键值对的形式存在： 这些参数拼接在 baseUrl 后面的顺序是没有要求的，不一定要按照上面的顺序来，只要每个参数都按照固定的格式出现就可以。 看上面的完整 Url 可以发现规律，在 baseUrl 后面有一个 ？， 然后就就是 key1=value1&amp;key2=value2&amp;key3=value3 这种形式的 其实遵循 RESTful API 设计的接口，都会是这种形式，所以这里也利于我们进行封装了。而 key-value 这种形式，就特别适合使用 Map 结构来封装。 说这么多，上代码，首先是对参数进行封装： RequestParam 12345678910111213141516171819202122232425262728293031323334353637/** * @author:fanyuzeng * @date: 2017/10/27 13:55 * @desc: 封装url中的参数 */public class RequestParams &#123; /** * 使用&#123;@link ConcurrentHashMap&#125;是为了保证线程安全 */ private ConcurrentHashMap&lt;String, String&gt; urlParams = new ConcurrentHashMap&lt;&gt;(); public RequestParams() &#123; &#125; public RequestParams(Map&lt;String, String&gt; source) &#123; for (Map.Entry&lt;String, String&gt; entry : source.entrySet()) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; public RequestParams(String key, String value) &#123; put(key, value); &#125; private void put(String key, String value) &#123; if (!TextUtils.isEmpty(key) &amp;&amp; !TextUtils.isEmpty(value)) &#123; urlParams.put(key, value); &#125; &#125; public ConcurrentHashMap&lt;String, String&gt; getUrlParams() &#123; return urlParams; &#125;&#125; 这地方使用 ConcurrentHashMap 就是为了保证线程安全的，这个类使用的是锁分段技术，不同于一般的同步方法或者是同步代码块，它只会锁住其中一个 segment，其他的 segment 仍然是可以访问的，所以他的效率会比 synchronized 高。 有了 RequestParam 之后，就可以使用它来拼接 url，有了 url 之后，就可以使用它来构建 Request对象了。 CommonRequest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1 /** 2 * @author: fanyuzeng 3 * @date: 2017/10/27 14:08 4 * @desc: response for build various kind of &#123;@link okhttp3.Request&#125; include Get Post upload etc. 5 */ 6 public class CommonRequest &#123; 7 private static final String TAG = \"CommonRequest\"; 8 /** 9 * create a Get request10 *11 * @param baseUrl base url12 * @param params see &#123;@link RequestParams&#125;13 * @return &#123;@link Request&#125;14 * @created at 2017/10/27 14:3915 */16 public static Request createGetRequest(@NonNull String baseUrl, @Nullable RequestParams params) &#123;17 StringBuilder urlBuilder = new StringBuilder(baseUrl).append(\"?\");18 if (params != null) &#123;19 //将请求参数合并进url中20 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;21 urlBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&amp;\");22 &#125;23 24 Log.d(TAG,\"&gt;&gt; createGetRequest &gt;&gt; \" + urlBuilder.toString());25 &#125;26 return new Request.Builder().get().url(urlBuilder.substring(0, urlBuilder.length() - 1)).build();27 &#125;28 29 /**30 * create a post request31 *32 * @param baseUrl base url33 * @param params see &#123;@link RequestParams&#125;34 * @return &#123;@link Request&#125;35 * @created at 2017/10/27 14:3936 */37 public static Request createPostRequest(@NonNull String baseUrl, @NonNull RequestParams params) &#123;38 FormBody.Builder mFormBodyBuilder = new FormBody.Builder();39 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;40 mFormBodyBuilder.add(entry.getKey(), entry.getValue());41 &#125;42 FormBody formBody = mFormBodyBuilder.build();43 return new Request.Builder().post(formBody).url(baseUrl).build();44 &#125;45 46 &#125; 第 16 行的 createGetRequest 方法是用于创建一个 Get 请求，主要就是使用 StringBuilder 进行 Url 的拼接，第 37 行的 createPostRequest 方法是用于创建一个 Post 请求的。 Post 请求是先创建 FormBody ，然后和 baseUrl 一个构造 Request 。 封装到这里， Request 就算是封装完了， 当然这里只封装了 Post Get ，也可以继续封装文件上传和文件下载的Request。 CallCall 代表的是一个实际的 HTTP 请求，它是链接 Request 和 Response 的桥梁，通过 Request 对象的 newCall 方法可以得到一个 Call 对象，既支持同步获取数据，也支持异步，在上面官方例子里，也可以看出来，在异步回调中，当获取到数据，会将 Response 对象传入 Callback 的 onSuccess 方法中，如果请求没有成功，就会调用 onFailure 方法（Response 下面说）。那么看看 Callback 是什么。 先看看官方的 Callback 是什么 ： 1234567public interface Callback &#123; void onFailure(Call call, IOException e); void onResponse(Call call, Response response) throws IOException;&#125; 对，把注释删除了之后，其实就是两个接口，简单的理解成，一个是请求成功时的回调，一个是请求失败时的回调。 那么对这一层的封装思路是这样子的： 一般来说，在上层，我们是需要去处理上面两个回调的，在 onFailure 中，请求失败，应该做什么操作，在 onResponse 中，HTTP 返回的状态码在 [200,300）之间应该有什么操作，在其他区间又应该有什么操作。那么在这里，我们就创建一个类，去实现这个接口，将基本的处理都在这个类里写好，出错误了，就拿到 erroeCode errorMsg 回调给上层，正确的返回信息，就直接回调给上一层。 那么这里就涉及到我们自定义的一个 Exception 和 Listener 以及实现了 Callback 接口的 CommonCallback 类。 OkHttpException 1234567891011121314151617181920212223/** * @author:fanyuzeng * @date: 2017/10/27 13:44 * @desc: */public class OkHttpException extends Exception &#123; private int mErrorCode; private String mErrorMsg; public OkHttpException(int errorCode, String errorMsg) &#123; this.mErrorCode = errorCode; this.mErrorMsg = errorMsg; &#125; public int getErrorCode() &#123; return mErrorCode; &#125; public String getErrorMsg() &#123; return mErrorMsg; &#125;&#125; DisposeDataListener 123456789101112131415161718192021/** * @author:fanyuzeng * @date: 2017/10/27 13:49 * @desc: */public interface DisposeDataListener &#123; /** * 请求服务器数据成功时回调的方法 * * @param responseObj 需要回调到上层的请求结果 */ void onSuccess(Object responseObj); /** * 请求服务器失败时候的回调方法 * * @param exception 需要回调到上层的错误反馈 */ void onFailure(OkHttpException exception);&#125; 再将这个 Listener 用代理设计模式再封装一层 DisposeDataHandler12345678910111213141516171819202122232425262728293031/** * @author:fanyuzeng * @date: 2017/10/27 13:52 * @desc: 代理模式,使用DisposeDataHandler 代理 DisposeDataListener的操作 */public class DisposeDataHandler &#123; public DisposeDataListener mListener; public Class&lt;?&gt; mClass; public DisposeDataHandler(DisposeDataListener listener) &#123; mListener = listener; &#125; public DisposeDataHandler(DisposeDataListener listener, Class&lt;?&gt; aClass) &#123; mListener = listener; mClass = aClass; &#125; public void onSuccess(Object responseObj) &#123; mListener.onSuccess(responseObj); &#125; public void onFailure(OkHttpException exception) &#123; mListener.onFailure(exception); &#125; public Class&lt;?&gt; getClassType() &#123; return mClass; &#125;&#125;此处用代理模式，主要是为了优雅（装X）的处理 Class&lt;?&gt; 这个对象，这是用于映射的类型，在调用 Listener 的回到方法之后做判断这个对象是否存在，是，则再映射在返回，否，直接返回。然后将三面三个类聚合到一起CommonJsonCallback 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @author:fanyuzeng * @date: 2017/10/27 14:41 * @desc: */public class CommonJsonCallback implements Callback &#123; private static final String TAG = \"CommonJsonCallback\"; private static final String MSG_RESULT_EMPTY = \"request could not be ececuted\"; private static final String MSG_JSON_EMPTY = \"json is empty or null\"; private static final String MSG_RETURN_CODE = \"http return code is not [200,300)\"; private static final int NETWORK_ERROR = -1; private static final int JSON_ERROR = -2; private Handler mDeliveryHandler = new Handler(Looper.getMainLooper()); private Gson mGson = new Gson(); private DisposeDataHandler mDisposeDataHandler; public CommonJsonCallback(DisposeDataHandler dataHandler) &#123; mDisposeDataHandler = dataHandler; &#125; @Override public void onFailure(@NonNull Call call, @NonNull final IOException e) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RESULT_EMPTY + e.getMessage())); &#125; &#125;); &#125; @Override public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RETURN_CODE + response.message())); &#125; &#125;); &#125; final String resultJson = response.body().string(); mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; handleResponse(resultJson); &#125; &#125;); &#125; private void handleResponse(String resultJson) &#123; if (TextUtils.isEmpty(resultJson)) &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_JSON_EMPTY)); return; &#125; if (mDisposeDataHandler.getClassType() == null) &#123; mDisposeDataHandler.onSuccess(resultJson); &#125; else &#123; Object mappedDataType = mGson.fromJson(resultJson, mDisposeDataHandler.getClassType()); if (mappedDataType == null) &#123; mDisposeDataHandler.onFailure(new OkHttpException(JSON_ERROR, MSG_JSON_EMPTY)); &#125; else &#123; mDisposeDataHandler.onSuccess(mappedDataType); &#125; &#125; &#125;&#125; 自我感觉用代理之后，处理对象都是 DisposeHandler ，不会在看到 Listener Class&lt;?&gt; ,适应起来方便些了。 要注意一点是，在 onResponse 方法中，还是在子线程中的，要及时切换线程。 到这里，就对 Call 这个对象封装完成了。 ResponseResponse 类封装了响应报文信息：状态吗（200、404 等）、响应头（Content-Type、Server 等）以及可选的响应体。可以通过 Call 对象的 execute() 方法获得 Response 对象，异步回调执行 Callback 对象的 onResponse 方法时也可以获取 Response 对象。 这东西人家已经给我们封装好了， 需要什么直接去拿就行， 也不需要在封装。 OkHttpClient官方文档有这么一句话： OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools. 翻译一下：当你使用一个全局的 OkHttpClient ，并且重用它发起 HTTP 请求的时候，OkHttp 的能够发挥最 NB 的性能，因为每一个客户端都持有它的连接池和线程池，如果这俩东西可以重用的话，那么就能减少潜在的因素，并且节省内存，相反的，如果为每一个客户端的每一个请求都创建一个 OkHttpClient ，那么就会浪费空闲的连接池和线程池中的资源。 叽叽歪歪这么多，就是说用 OkHttpClient 的时候要用单例模式。 刚开始我是这么设计的： CommonokHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author:fanyuzeng * @date: 2017/10/27 15:21 * @desc: */@Deprecatedpublic class CommonOkHttpClient &#123; private static final int TIME_OUT = 30; private static OkHttpClient sOkHttpClient; static &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https sOkHttpClient = builder.build(); &#125; /** * 请求服务器数据的方法 * * @param request Use &#123;@link com.project.fanyuzeng.mvpdemo.utils.okhttp.request.CommonRequest&#125; to build * @param handler see &#123;@link DisposeDataHandler&#125; proxy class */ public static void requestServerData(Request request, DisposeDataHandler handler) &#123; sOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 恩，静态代码块中初始化实例化 OkHttpClient，我认为饿汉模式没有本质的区别， 但是这种方式比饿汗模式的初始化时间更早。 好吧 ，我承认我懒，不想在整个单例类出来。。 这样写，也没什么问题，但是外界在使用的使用，比较麻烦 创建RequestParams，涉及到 HashMap 的好多 put 操作 用 RequestParam 去初始化 CommonRequest 在上层根据请求方式去创建对应的 Request 再实例化一个DisposeHandler 所以只好接着封装吧，分析上面 4 个步骤，其中步骤 1 那是不能再简化了的，因为具体的请求参数肯定是要从外界传进来的，这里涉及到的 HashMap 以及它的 put 操作是不可避免的。步骤 2 和步骤 3 完全是可以封装一下的，步骤 4 也是需要从外外界回调的方法，类似于点击监听的 onClick 方法回调。 所以把 CommonOkHttpClient 给 Deprecated 掉，重新来一个 OkHttpManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author:fanyuzeng * @date: 2017/10/27 17:57 * @desc: */public class OkHttpManager &#123; private static volatile OkHttpManager sManager; private OkHttpClient mOkHttpClient; private OkHttpManager() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https mOkHttpClient = builder.build(); &#125; public static OkHttpManager getInstance() &#123; if (sManager == null) &#123; synchronized (OkHttpManager.class) &#123; if (sManager == null) &#123; sManager = new OkHttpManager(); &#125; &#125; &#125; return sManager; &#125; /** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */ public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125; &#125;&#125; 好吧，还是用双重锁模式的单例比较放心 。 到此就封装完了，下面简单的使用一下。 使用姿势12345678910111213 1 OkHttpManager.getInstance().requestServerData(method, url, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; 2 @Override 3 public void onSuccess(Object responseObj) &#123; 4 String responseJson = (String) responseObj; 5 Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); 6 mPaginationPresenter.accessSuccess(responseJson); 7 &#125; 8 @Override 9 public void onFailure(OkHttpException exception) &#123;10 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode());11 mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url);12 &#125;13 &#125;,null)); 没有将 Json 数据映射成实体类， 所以在 13 行构造 DisposeDataHandler 的时候，第二个 类参数传的是 null。 这个例子是结合上一篇请求分页数据来用的，所以这里直接将 Json 数据抛给 Presenter 层，让它去处理。 第 1 行的 mPaginationPresenter.getParams() 就是拿 url 中的参数。 由于篇幅的限制，这一篇先到这里，下一篇再把这个封装的 OkHttp 工具用于 MVP 模式的 Demo 当中 最后，贴个 AS 中封装之后工具的结构图。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（三）基于分页列表的封装","slug":"MVP3","date":"2017-10-25T12:37:15.000Z","updated":"2017-10-28T10:30:28.153Z","comments":true,"path":"2017/10/25/MVP3/","link":"","permalink":"http://zengfanyu.top/2017/10/25/MVP3/","excerpt":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。","text":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。 presenter 层作为 MVP 模式的桥梁， 那就先从这一层开始说起吧。 Presenter上一篇中对 Presenter 层的公共方法进行了抽取并且封装成了一个接口 IBasePresenter ，那么现在我们需要实现分页加载还有刷新的功能，那么在 IBasePresenter 接口的基础之上，在对其封装一个接口 IBasePeginationPresenter：123456789101112131415161718192021222324252627/** * Created by fanyuzeng on 2017/10/23. * Function:在IBasePresenter的基础上扩展的接口，适用于分页加载的情况 */public interface IBasePaginationPresenter&lt;Param&gt; extends IBasePresenter&lt;Param&gt; &#123;/** * 刷新数据的接口 * * @param param 访问服务器的参数 * @created at 2017/10/23 20:07 */void refresh(Param param);/** * 加载更多的接口 * * @created at 2017/10/23 20:07 */void loadingNext();/** * 用于判断服务器端是否还有更多的数据 * @return true -还有更多数据 - false 没有更多的数据 */boolean hasMoreData();&#125; 也是一个泛型的接口，增加的三个方法 ： refresh(Param param) 在 View 层调用，用于通知 Model 层刷新数据 loadingNext() 在 View 层调用，用于通知 Model 层加载下一页数据 hasMoreData() 在 Model 层请求网络数据前调用做判断，是否还有下一页数据 有了针对分页刷新的接口之后，还需要有一个实现它的基类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePeginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; private static final String TAG = \"BasePaginationPresenter\"; private IBaseModel mBaseModel; private IBaseView mBaseListView; private Param mParam; private Class&lt;Data&gt; mClazz; private Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mHasMoreData=true; /** * 子类中调用，用于传递服务器返回的，处理好的结果 * * @param data View层需要的数据类型 * @created at 2017/10/23 20:10 */ public abstract void serverResponse(Data data); /** * 子类中调用，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); public BasePaginationPresenter(IBaseView baseListView, Class&lt;Data&gt; Clazz) &#123; this.mBaseListView = baseListView; mClazz = Clazz; mBaseModel = new SohuAlbumModel(this); &#125; @Override public void refresh(Param param) &#123; requestServer(param); &#125; @Override public void loadingNext() &#123; if (mParam != null) &#123; int pageIndex = mParam.getPageIndex(); mParam.setPageIndex(pageIndex + 1); requestServer(mParam); &#125; &#125; @Override public void requestServer(@Nullable Param param) &#123; mBaseListView.showProgress(true); mParam = param; Log.d(TAG, \"&gt;&gt; requestServer &gt;&gt; \"); getModel().sendRequestToServer(param); &#125; @Override public void accessSuccess(String responseJson) &#123; mBaseListView.showProgress(false); Gson gson = new Gson(); serverResponse(gson.fromJson(responseJson, mClazz)); mBaseListView.showSuccess(true); &#125; @Override public void cancelRequest() &#123; mBaseModel.cancelRequest(); &#125; @Override public void okHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showOkHttpError(errorCode, errorDesc, errorUrl); mBaseListView.showProgress(false); mBaseListView.showSuccess(false); &#125; &#125;); &#125; @Override public IBaseModel getModel() &#123; return mBaseModel; &#125; @Override public HashMap&lt;String, String&gt; getParams() &#123; return null; &#125; @Override public boolean hasMoreData() &#123; return ServerHaveMoreData(); &#125;&#125; 在类申明时，可以看到 Param extends BasePeginationParam ，这里的 BasePeginationParam主要是封装了摘要中提到的 PageIndex 和 PageSize 两个参数，以及他们的 Getter Seeter 方法。 重点看 IBasePeginationPresenter 中新增加的三个方法，refresh(Param param) 会重新调用一次 requestServer(Param param) （此方法在上一篇也提过了，就是通知 Model 层获取数据）； loadingNext() ，加载下一页数据的方法，就是将参数中的 PageIndex + 1 之后，重新调用 requestServer(Param param) 方法。此处只改变了页码，如果需要改变请求数据的条数，也是相应的在 loadingNext() 中修改 PageSize 的值。 hasMoreData() ,这里返回抽象方法 serverhaveMoreData() ，这个方法是在子类中实现的，子类解析了数据之后，判断服务器是否还有数据返回。 然后有需要实现分页功能的 Presenter 就可以直接继承 BasePaginationPresenter 。 Model 层由于 Model 层的职责比较单一，就是向数据源请求数据，并且返回给 Presenter 层，所以此处不需要额外封装接口或者是基类，只需要重新实现上一篇中提到的 IBaseModel 接口即可。 View 层此处和请求一次数据相比较， View 层就是需要在两个事件触发的时候，重新设置参数通知 Presenter 去请求数据，然后再展示出来。这两个事件分别是：上拉到底时加载更多、下拉时刷新数据（当然可以别的）。 针对上一小节中封装类的具体实现View 层的具体实现主要是展示电视剧的主要信息，那么需要提供一个接口方法，给 Presenter 层调用，展示处理好的 JavaBean：1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 此处的 VideoInfo 是一个JavaBean，对应的就是电视剧信息的实体类。1234567891011121314public class VideoInfo &#123; @SerializedName(\"main_actor\") private String mMainActor; @SerializedName(\"total_video_count\") private int mTotalVideoCount; @SerializedName(\"album_name\") private String mAlbumName; @SerializedName(\"director\") private String mDirector; @SerializedName(\"publish_time\") private String mPublishTime; //Getter and setter methods&#125; 之前映射数据需要保证字段名和 Json 数据的字段名一致，其实本来把这个类的字段名改得一致就行啦，但是服务器端返回的数据字段，很多都是以“_”进行连接，而不是使用驼峰命名法则，这个时候 Gson 的 @SerializedName 注解就派上用场了，注解中用服务器端返回值字段，成员变量仍然使用驼峰命名法。但是上个周末安装了最近 Alibaba 10 月 14 日 推出的 Coding Guidelines 插件，发现代码中很多不规范的地方，并且人家规定了成员变量就必须要使用驼峰命名！所以我决定要按照这个插件的规范来写代码了，虽然现在进不了大厂，但是先熟悉大厂的代码规范也是好事，哈哈~ 咳咳，按照大厂的代码规范，成员变量的命名必须使用驼峰命名法！这个插件是真心好用，比如对类名要 javadoc 注释 参数、返回值、异常说明、此方法做什么事情、实现什么功能（领域模型相关命名除外，比如：DO、BO、DAO），并且是全中文的！直接在 AS 的 Inspection Results 窗口中显示，这 IDE 内置功能啥时候讲过中文反馈结果的？ 《阿里巴巴Java开发规约》插件全球首发！ 广告时间结束，言归正传！ 这个 Activity 实现了 ISohuSerials 接口，布局文件和上一篇一样，只是把 ListView 换成了自定义的 PullLoadRecyclerView 了，这个RecycyclerView 支持上拉加载更多和下拉刷新， 这里不展开说了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author：ZengFanyu */public class SohuAlbumInfoActivity extends AppCompatActivity implements ISohuSerials &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private Context mContext; private ProgressBar mProgressBar; private TextView mTip; private RelativeLayout mContainer; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam= new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mIsFromRefresh = false; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_album_view); mContext = this; mAlbumPresenter = new AlbumPresenter(this, Album.class); mContainer = (RelativeLayout) findViewById(R.id.id_success_content); mTip = (TextView) findViewById(R.id.id_tip); mProgressBar = (ProgressBar) findViewById(R.id.id_progress_bar); mRecyclerView = (PullLoadRecyclerView) findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); //通知Presenter层刷新数据 mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); //通知Presenter层加载下一页数据 &#125; &#125;); &#125; @Override public void showAlbumMainInfo(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;); &#125; &#125; @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"http err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc + \",errUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"server err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContainer.setBackgroundResource(android.R.color.white); mTip.setText(\"Sohu Serials album\"); &#125; else &#123; mContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125;&#125; 在上面代码中可以看到: 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onRefresh() 回调方法中，核心代码就是这一行 mAlbumPresenter.refresh(mParam); ，通知 Presenter 层去刷新数据， 至于 Presenter 层如何刷新。。 关我 View 层 X 事~ 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onLoadMore() 回调方法中,也是直接调用 mAlbumPresenter.loadingNext()。 下面说说 Presenter 层的代码 Presenter 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private ISohuSerials mBaseListView; private Handler mHandler = new Handler(Looper.getMainLooper()); private int mTotalCount; public AlbumPresenter(ISohuSerials baseListView, Class&lt;Album&gt; CLazz) &#123; super(baseListView, CLazz); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL); &#125; @Override public void serverResponse(Album album) &#123; mBaseListView.showAlbumMainInfo(album.getData().getVideos()); mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showProgress(false); &#125; &#125;); mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际使用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); return (pageIndex * pageSize) &lt;= mTotalCount; &#125;&#125; 首先是要继承之前编写的 BasePaginationPresenter类，泛型参数 BasePaginationParam 可以根据实际需求进行拓展，基本使用在前面已经介绍过，此处不做赘述。 Album 是搜狐视频电视剧频道返回数据的实体类，上面提到的 VideoInfo 包含在 Album 里面，因为现在只需要展示 VideoInfo 里的信息， 所以在 serverRespomse 方法里，有一个转换 mBaseListView.showAlbumMainInfo(album.getData().getVideos()); 实现父类 BasePaginationPresenter 中的抽象方法 serverHaveMoreData() ,思路就是 当前页面数 * 每一页的数据量，然后和 数据总量 比较大小。 Model 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 1 /** 2 * @author：ZengFanyu 3 */ 4 public class SohuAlbumModel&lt;Param extends BasePaginationParam&gt; implements IBaseModel&lt;Param&gt; &#123; 5 private static final String TAG = \"SohuAlbumModel\"; 6 private String url; 7 private int method; 8 private IBasePaginationPresenter mPaginationPresenter; 9 10 public SohuAlbumModel(IBasePaginationPresenter paginationPresenter) &#123;11 mPaginationPresenter = paginationPresenter;12 &#125;13 14 @Override15 public void sendRequestToServer(Param param) &#123;16 String validUrl = null;17 if (param != null &amp;&amp; !TextUtils.isEmpty(url)&amp;&amp;mPaginationPresenter.hasMoreData()) &#123;18 validUrl = getValidUrl(url, param);19 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl);20 &#125;21 Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"check param,url and server have data or not!\")22 if (!TextUtils.isEmpty(validUrl)) &#123;23 HttpUtils.executeByGet(validUrl, new Callback() &#123;24 @Override25 public void onFailure(Call call, IOException e) &#123;26 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \");27 e.printStackTrace();28 mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url);29 &#125;30 31 @Override32 public void onResponse(Call call, Response response) throws IOException &#123;33 if (!response.isSuccessful()) &#123;34 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\");35 mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url);36 &#125;37 38 String responseJson = response.body().string();39 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson);40 mPaginationPresenter.accessSuccess(responseJson);41 42 &#125;43 &#125;);44 &#125; else &#123;45 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\");46 &#125;47 &#125;48 49 private String getValidUrl(String url, Param param) &#123;50 return String.format(url, param.getPageIndex(), param.getPageSize());51 &#125;52 53 54 @Override55 public void setRequestUrl(String url) &#123;56 this.url = url;57 &#125;58 59 @Override60 public void setRequestMethod(int method) &#123;61 this.method = method;62 &#125;63 64 @Override65 public void cancelRequest() &#123;66 HttpUtils.cancelCall();67 &#125;68 &#125; Model 层的实现还是跟之前的一样，直接实现 IBaseModel 接口即可。 在 17 行可以看到，mPaginationPresenter.hasMoreData() ，这个就是对服务器点是否还有数据可以返回的判断，如果这里返回 false 那么就不回去进行网络请求,然后在 22 行打印个 Log 提醒。 在看看 49 行的 getVaildUrl 方法，这个方法主要就是把传进来的 param 参数拼接进 url 中，形成有效的，可以请求到数据的 Url。 效果图 Item 就展示了一下电视剧的 主演、名字、导演、集数、更新时间的信息。 小结通过上面的封装和例子，起码证明了这一套封装能够跑的通了，以后如果还有关于分页请求的需求，可以直接继承上面的基类来实现，无非就是修改param 和 Data 两个泛型的参数。 前者是请求 url 的参数，根据具体的业务需求，封装 BasePaginationParam 的子类即可。 后者是服务器端返回数据的实体类，也是根据数据的结构来封装的，在 Android Studio 中有 Gson Formatter 这个插件，封装 JavaBean 插件也轻松很多，在结合上面提到的 Gson 注解，全套了。 下一篇准备封装一下 OkHttp ,然后将封装之后的 OkHttp 整合到当前框架中,当然了,还是以分页接在为例","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android 当中的 MVP 模式（二）封装","slug":"MVP2","date":"2017-10-22T14:00:15.000Z","updated":"2017-10-28T10:38:12.190Z","comments":true,"path":"2017/10/22/MVP2/","link":"","permalink":"http://zengfanyu.top/2017/10/22/MVP2/","excerpt":"摘要：在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。","text":"摘要：在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。 一个简单的网络请求 一个简单的需求：通过 url 获取数据，然后用 Gson 解析成 JavaBean，然后展示到 ListView上。这里使用知乎日报的获取最新消息的 API 接口 https://news-at.zhihu.com/api/4/news/latest 那么按照普通 MVP 的思路，首先 view 层： 为了突出重点，当前View层只做一件事情：就是展示获取的数据 ILatestVIew 此接口需要一个 String 类型的列表数据，主要是用于给 Adapter 展示用。 LatestViewActivity 很简答，就是实现接口。 IRequestLatestModel 请求服务器端数据的接口 RequestLatestNewsModel 使用 okhttp 请求数据，然后将返回的json类型数据传递给 Presenter 层。 ILatestNewsPresenter 一个接口用于处理 Json 数据，一个接口用于通知 model 层向服务器发起请求 。 LatestNewsPresenter 实现接口定义的方法 其中 HttpUtils 方法如下： 此处 OKhttp 也可以进行封装， 后面再写一篇文章， 专门记录，先暂时简单的使用。 运行之后，点击 button， 即可发起网络请求，运行效果如下： 弊端： 假设我们现在又有另外的一个需求， 请求知乎日报过往的消息， 对应的 API 接口为URL: https://news-at.zhihu.com/api/4/news/before/20131119,那么我就需要按照上述的方式，又写一套MVP的代码，最少又得留个类，如此一来，随着需求的增多，代码量会极具增大，但是多余增加的每层代码所做的事情又大多数相同，只是具体细节不一样，那么我们可不可以把每一层要做的事情给抽取出来，封装成基类，然后让子类去继承，去实现，这样就可以大量减少代码量？ 抱着这个问题，我就来分析一下 MVP 每一层所做的事情。 以简单网络请求为例，分析 MVP 各层的职责以上面请求知乎日报的最新消息为例，分析每一层的职责。 Model 层Model 角色主要是提供数据的存取功，并且将数据或者是错误信息回调给 Presenter 层。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。所以它主要的功能是： 1. 向数据源发起请求 2. 取消发起的请求 3. 通知 Presenter 处理结果 Presenter 层一般是通知 Model 向服务器发起请求，然后接收 Model 层的请求结果，包括成功的数据和错误的信息，同时也负责将处理之后的数据或者是错误信息通知 View 层，由 View 层作展示。所以他的主要功能是： 1. 通知 Model 层向服务器发起数据请求 2. 通知 Model 层取消这次请求 3. 接收 Model 层返回的数据 4. 接收 Model 层返回的错误信息 5. 通知 View 层接收处理之后的结果或者是错误信息 View 层此处 View 层的作用就比较专一化，只用于处理 UI 相关的事情，不再负责业务逻辑。主要职责如下： 1. Loading 状态的展示隐藏 2. 接收 Presenter 层处理后的数据 3. 接收 Presenter 层处理后的错误信息 4. 接收 Presenter 层处理后的服务器拒绝信息 嗯，差不多就是这么多吧 既然将每一层的主要职责总结了出来， 很明显就可以将这些职责「在代码中就是对应的方法」抽象成方法，然后让子类去个性化的实现。 抽取共性封装网络请求Model 层IBaseModel 其中 setMethod 和 setRequestUrl 方法直接在 Presenter 的构造方法中调用，设置好请求的方式和请求的 Url 地址，这样方便 model 层在请求服务器数据时，使用对应的参数，使用对应的请求方式。 此处没有用到 method 是因为知乎日报的最新新闻 API 接口是 Get 方式，不需要参数，所以此处没有根据请求方式来调用不同的请求方法 Presenter 层IBasePresenter Presenter 层是逻辑控制层，是 Model 层和 View 层的桥梁，对这一层抽取共性进行封装的时候，不能像 Model 层一样，把全部的功能装好好，原因如下： 1.如果将其全部封装起来，是没办法复用同一个功能模块的，并且会导致部分业务逻辑需要在 view 层中做处理，这样和 MVP 的思想相悖。 2.Presenter 层需要处理和 View 层的交互逻辑以及 Model 层返回的数据。 但是 Model 层是可以的，我是认为，Model 层就是从数据源中拿数据，并且将数据传递给 Presenter 层，所有的 Model 层做的都是这个操作，只是访问数据源的参数不同，数据源类型不同，访问数据源的方法不同而已，所以很明显可以全部抽取出来放基类中，然后各个子类去各自实现。 1. requestServer 在View层调用的接口，用于通知Model层想服务器发起请求，参数可为空，比如，有些Get方式的请求就不需要参数 2. requestSuccess 在Model层调用，通过此方法将服务器返回的数据传递给给Presenter层处理 3. cancelRequest 在View层调用，用于通知Model层取消请求 4. okHttpError 在Model层调用，当网络请求产生错误的时候 5. getModel 在子类中调用，用于拿到Model对象 6. getParams 在Model层中调用，此方法用于获取Presenter层处理好的参数 BasePresenter public abstract class BasePresenter&lt;Params, Data&gt; implements IBasePresenter&lt;Params&gt;这是一个泛型的抽象类，其中泛型Params是用于model层向服务器发起请求的请求参数，Data是服务器返回的Json类对应的JavaBean类。 BasePresenter处理了View层和model层中大多数的逻辑，我们要做的就是在子类中实现public abstract void serverResponse(Data data);这个抽象方法就好了。 public abstract void serverResponse(Data data);这个方法是在用于处理model层返回的结果，然后进行处理之后回调给view层。 可以看到46、47、50、51、52行的代码给注释掉了，其实一般情况下这里是不需要注释的，这里是用于判断返回数据的errorNum errorType errorDesc信息的，这么操作，是为了实现如下功能：若返回的信息有误，则BasePresenter直接回调给View层，如果正确，才会传递给子类。 上述最后一条，需要对泛型Data在进行一次封装，并且使用上 Gson 的@SerializedName(value = &quot;...&quot;,alternate = {&quot;...&quot;,&quot;...&quot;,&quot;...&quot;})这个注解，并且这里涉及到泛型擦除的问题，这一块我还没有很好的解决办法，所以此处没有进行封装。 View 层还是按照上面分析的 View 层职责来写： IBaseView 到此为止，对 MVP 模式的每一层都写出了对应的基类，有了这件基类作为基础之后，在进行同样的网络请求。 使用上述封装好的类进行相同的网络请求LatestNewsModel LatestNewsPresenter 其中Param泛型参数填的是nullable是因为这个请求是get方式，没有涉及到参数。LatestNews作为Data的泛型，主要是用于BasePresenter解析并映射。 ILatestNewsView IlatestNewsVIew接口是继承IBaseView接口的，是因为它需要在IBaseView接口所定义的功能之上，还需要实现将数据展示到列表中这么一个操作，所以添加上了一个showLatestViewTitle方法。 LatestNewsTitleActivity 这个类写起来就简单了，跟着接口来， 把之前每一个接口提到的功能给实现以下就可以了。 顺便贴个 XML 文件： 搞定，实现的效果和上面是一样的。 回过头一看，MMP，这代码量似乎也没有少很多啊，-。- ，没事没事，需求多了就少了~ 小结先看看上一篇中提到的一张图此处将MVP模式封装后，MVP的流程图如下： 后面的文章将使用上面封装的框架，通过扩展 BasePresenter 来增加新的模块。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（一）基本概念","slug":"MVP1","date":"2017-10-20T12:37:15.000Z","updated":"2017-10-28T10:45:23.740Z","comments":true,"path":"2017/10/20/MVP1/","link":"","permalink":"http://zengfanyu.top/2017/10/20/MVP1/","excerpt":"摘要：Github上看到很多项目，都是 MVP+RxJava+Retrofit+Dragger2 这种架构，再加上一个 OkHttp， 虽说这几个东西，我都或多或少听过，用过，但是从来没有认真的研究过，没有把他们整合起来开发一个应用。从 MVP 开始，认真学习这几个框架，然后整合起来，做一个应用。先立一个 FLAG！","text":"摘要：Github上看到很多项目，都是 MVP+RxJava+Retrofit+Dragger2 这种架构，再加上一个 OkHttp， 虽说这几个东西，我都或多或少听过，用过，但是从来没有认真的研究过，没有把他们整合起来开发一个应用。从 MVP 开始，认真学习这几个框架，然后整合起来，做一个应用。先立一个 FLAG！ 为什么要使用MVP在传统的Android开发中，我们一般是使用MVC模式进行开发的。 传统MVC模式介绍： View: 视图层，对应xml文件 Controller: 控制层，对应Activity和Fragment层，进行数据处理 Model：实体层，负责获取实体数据 采用MVC模式的一个最大的弊端就是xml作为View层视图能力实在太弱，所以一般情况下我们都是通过Controller层来辅助处理一些视图的。这样的结果就导致Controller既作为控制层的同时又承担了View层的大部分功能，采用MVC模式往往会导致Activity和Fragment中的代码非常复杂。我们将Android中采用的MVC模式称为MV模式更加恰当。 MVP模式介绍： View: 视图层，对应xml文件与Activity/Fragment Presenter: 逻辑控制层，同时持有View和Model对象 Model: 实体层，负责获取实体数据 MVP模式的流程图如下： 采用MVP模式的优势是： 把业务逻辑抽离到Presenter层中，View层专注于UI的处理。 分离视图逻辑与业务逻辑，达到解耦的目的。 提高代码的阅读性。 Presenter被抽象成接口，可以根据Presenter的实现方式进行单元测试。可拓展性强。 采用MVP模式的缺点： 项目结构会对后期的开发和维护有一定的影响。具体视APP的体量而定。 代码量会增多，如何避免编写过多功能相似的重复代码是使用MVP开发的一个重点要处理的问题。 有一定的学习成本。综上所述，在Android上采用MVP模式的优势是：大大优化代码的维护性与拓展性的同时对代码进行深度解耦，使各个层级的分工更加明晰。 一个简单的应用模拟Android中登陆的功能 界面 项目结构 从上图中可以看到，一个简单的基于 MVP 的项目，最少也需要创建 6 个文件夹，分别是 M、V、P 的接口和它们各自的实现类，其中 LoginActivity 就是 View 层的具体实现，它只需要负责处理 UI 的逻辑，而业务相关的逻辑都抽象到 LoginPresenter 中，这样就避免了传统开发中 Activity 、Fragment 既处理 UI 又负责业务逻辑的情况。 代码实现ILoginView： view层只负责和 UI 相关的操作，那么在这个小 Demo 中，和 UI 相关的操作有如下几点： 1. 从EditText中拿到用户输入的userName 2. 从EditText中拿到用户输入的password 3. 在登录过程中需要展示一个progressbar，登录过程结束之后隐藏这个progressbar 4. 展示登录成功后的view 5. 展示登录失败后的view 综上五个操作，所以有了ILoginView中的五个接口 LoginActivity： 当点击登录按钮时，会将请求服务器合适账号密码这个过程交给presenter层去处理，所以在LoginActivity里，会有preserent的引用。 ILoginPersenter： presenter层处理业务逻辑，有如下几点: 1. 负责接收model的返回结果并且处理 2. 将处理的结果以特定的形式，传递给view层，让view层去展示 3. 通知model层去向数据源请求数据 LoginPresenter： 因为presenter层相当于一个中间交互人，所以它必须要持有对 view 、model 层对象的引用。 ILoginModel： model负责数据的存取： 在这个Demo中，数据的存取使用一个线程和简单的字符串判断来模拟。 LoginModel： 因为model层需要将获取的数据传递给presenter层去做处理，所以此处也需要持有对presenter层的引用。 这样一来就成功的将简单的登录案例，由MVP模式来实现了, 在 LoginActivity 中处理的都是和 UI 相关的， 在 LoginPresenter 中处理的是业务的逻辑， 在 LoginModel 中处理的是网络数据获取。 小结 Presenter—交互中间人 主要作为沟通 View 和 Model 的桥梁，它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务从 View 角色上抽离出来。 View—用户界面 View 通常是指Activity、Fragment或者某个 View 控件，它含有一个 Presenter 成员变量。通常 View 需要实现一个逻辑接口，将 View 上的操作转换给 Presenter 进行实现，最后，Presenter 调用 View 逻辑接口将结果返回给 View 元素。 Model—数据的存取 对于一个结构化的 APP 来说，Model角色主要是提供数据的存取功能。Presenter 需要通过 Model 层存储、获取数据，Model就想一个数据仓库。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。 MVP 并不是一个标准化的模式，它有很多种实现方式，也可以根据自己的需求去修正MVP的实现方式，可以随着 Presenter 的复杂程度而变化，只要保证是通过 Presenter 将 View 和 Model 解耦，降低类型复杂度，各个模块单元可以独立测试、独立变化，这就是正确的方向。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-14T15:40:28.953Z","updated":"2017-10-21T16:06:55.127Z","comments":true,"path":"2017/10/14/hello-world/","link":"","permalink":"http://zengfanyu.top/2017/10/14/hello-world/","excerpt":"","text":"To be a better man1Hello , 个人博客搭好了，老规矩，先来个 Hello World！，然后，撸起袖子就是干！","categories":[],"tags":[]}]}