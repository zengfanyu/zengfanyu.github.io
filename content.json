{"meta":{"title":"THIS IS BIGZ","subtitle":"Every little makes a mickel","description":null,"author":"BigZ","url":"http://zengfanyu.top"},"pages":[{"title":"分类","date":"2017-10-25T14:59:18.000Z","updated":"2017-10-25T15:05:10.156Z","comments":false,"path":"categories/index.html","permalink":"http://zengfanyu.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:58:45.000Z","updated":"2017-10-25T15:05:14.395Z","comments":false,"path":"tags/index.html","permalink":"http://zengfanyu.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android当中的MVP模式（三）基于分页列表的封装","slug":"MVP3","date":"2017-10-25T12:37:15.000Z","updated":"2017-10-28T07:15:26.281Z","comments":true,"path":"2017/10/25/MVP3/","link":"","permalink":"http://zengfanyu.top/2017/10/25/MVP3/","excerpt":"","text":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。 presenter 层作为 MVP 模式的桥梁， 那就先从这一层开始说起吧。 Presenter上一篇中对 Presenter 层的公共方法进行了抽取并且封装成了一个接口 IBasePresenter ，那么现在我们需要实现分页加载还有刷新的功能，那么在 IBasePresenter 接口的基础之上，在对其封装一个接口 IBasePeginationPresenter：123456789101112131415161718192021222324252627/** * Created by fanyuzeng on 2017/10/23. * Function:在IBasePresenter的基础上扩展的接口，适用于分页加载的情况 */public interface IBasePaginationPresenter&lt;Param&gt; extends IBasePresenter&lt;Param&gt; &#123;/** * 刷新数据的接口 * * @param param 访问服务器的参数 * @created at 2017/10/23 20:07 */void refresh(Param param);/** * 加载更多的接口 * * @created at 2017/10/23 20:07 */void loadingNext();/** * 用于判断服务器端是否还有更多的数据 * @return true -还有更多数据 - false 没有更多的数据 */boolean hasMoreData();&#125; 也是一个泛型的接口，增加的三个方法 ： refresh(Param param) 在 View 层调用，用于通知 Model 层刷新数据 loadingNext() 在 View 层调用，用于通知 Model 层加载下一页数据 hasMoreData() 在 Model 层请求网络数据前调用做判断，是否还有下一页数据 有了针对分页刷新的接口之后，还需要有一个实现它的基类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePeginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; private static final String TAG = \"BasePaginationPresenter\"; private IBaseModel mBaseModel; private IBaseView mBaseListView; private Param mParam; private Class&lt;Data&gt; mClazz; private Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mHasMoreData=true; /** * 子类中调用，用于传递服务器返回的，处理好的结果 * * @param data View层需要的数据类型 * @created at 2017/10/23 20:10 */ public abstract void serverResponse(Data data); /** * 子类中调用，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); public BasePaginationPresenter(IBaseView baseListView, Class&lt;Data&gt; Clazz) &#123; this.mBaseListView = baseListView; mClazz = Clazz; mBaseModel = new SohuAlbumModel(this); &#125; @Override public void refresh(Param param) &#123; requestServer(param); &#125; @Override public void loadingNext() &#123; if (mParam != null) &#123; int pageIndex = mParam.getPageIndex(); mParam.setPageIndex(pageIndex + 1); requestServer(mParam); &#125; &#125; @Override public void requestServer(@Nullable Param param) &#123; mBaseListView.showProgress(true); mParam = param; Log.d(TAG, \"&gt;&gt; requestServer &gt;&gt; \"); getModel().sendRequestToServer(param); &#125; @Override public void accessSuccess(String responseJson) &#123; mBaseListView.showProgress(false); Gson gson = new Gson(); serverResponse(gson.fromJson(responseJson, mClazz)); mBaseListView.showSuccess(true); &#125; @Override public void cancelRequest() &#123; mBaseModel.cancelRequest(); &#125; @Override public void okHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showOkHttpError(errorCode, errorDesc, errorUrl); mBaseListView.showProgress(false); mBaseListView.showSuccess(false); &#125; &#125;); &#125; @Override public IBaseModel getModel() &#123; return mBaseModel; &#125; @Override public HashMap&lt;String, String&gt; getParams() &#123; return null; &#125; @Override public boolean hasMoreData() &#123; return ServerHaveMoreData(); &#125;&#125; 在类申明时，可以看到 Param extends BasePeginationParam ，这里的 BasePeginationParam主要是封装了摘要中提到的 PageIndex 和 PageSize 两个参数，以及他们的 Getter Seeter 方法。 重点看 IBasePeginationPresenter 中新增加的三个方法，refresh(Param param) 会重新调用一次 requestServer(Param param) （此方法在上一篇也提过了，就是通知 Model 层获取数据）； loadingNext() ，加载下一页数据的方法，就是将参数中的 PageIndex + 1 之后，重新调用 requestServer(Param param) 方法。此处只改变了页码，如果需要改变请求数据的条数，也是相应的在 loadingNext() 中修改 PageSize 的值。 hasMoreData() ,这里返回抽象方法 serverhaveMoreData() ，这个方法是在子类中实现的，子类解析了数据之后，判断服务器是否还有数据返回。 然后有需要实现分页功能的 Presenter 就可以直接继承 BasePaginationPresenter 。 Model 层由于 Model 层的职责比较单一，就是向数据源请求数据，并且返回给 Presenter 层，所以此处不需要额外封装接口或者是基类，只需要重新实现上一篇中提到的 IBaseModel 接口即可。 View 层此处和请求一次数据相比较， View 层就是需要在两个事件触发的时候，重新设置参数通知 Presenter 去请求数据，然后再展示出来。这两个事件分别是：上拉到底时加载更多、下拉时刷新数据（当然可以别的）。 针对上一小节中封装类的具体实现View 层的具体实现主要是展示电视剧的主要信息，那么需要提供一个接口方法，给 Presenter 层调用，展示处理好的 JavaBean：1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 此处的 VideoInfo 是一个JavaBean，对应的就是电视剧信息的实体类。1234567891011121314public class VideoInfo &#123; @SerializedName(\"main_actor\") private String mMainActor; @SerializedName(\"total_video_count\") private int mTotalVideoCount; @SerializedName(\"album_name\") private String mAlbumName; @SerializedName(\"director\") private String mDirector; @SerializedName(\"publish_time\") private String mPublishTime; //Getter and setter methods&#125; 之前映射数据需要保证字段名和 Json 数据的字段名一致，其实本来把这个类的字段名改得一致就行啦，但是服务器端返回的数据字段，很多都是以“_”进行连接，而不是使用驼峰命名法则，这个时候 Gson 的 @SerializedName 注解就派上用场了，注解中用服务器端返回值字段，成员变量仍然使用驼峰命名法。但是上个周末安装了最近 Alibaba 10 月 14 日 推出的 Coding Guidelines 插件，发现代码中很多不规范的地方，并且人家规定了成员变量就必须要使用驼峰命名！所以我决定要按照这个插件的规范来写代码了，虽然现在进不了大厂，但是先熟悉大厂的代码规范也是好事，哈哈~ 咳咳，按照大厂的代码规范，成员变量的命名必须使用驼峰命名法！这个插件是真心好用，比如对类名要 javadoc 注释 参数、返回值、异常说明、此方法做什么事情、实现什么功能（领域模型相关命名除外，比如：DO、BO、DAO），并且是全中文的！直接在 AS 的 Inspection Results 窗口中显示，这 IDE 内置功能啥时候讲过中文反馈结果的？ 《阿里巴巴Java开发规约》插件全球首发！ 广告时间结束，言归正传！ 这个 Activity 实现了 ISohuSerials 接口，布局文件和上一篇一样，只是把 ListView 换成了自定义的 PullLoadRecyclerView 了，这个RecycyclerView 支持上拉加载更多和下拉刷新， 这里不展开说了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author：ZengFanyu */public class SohuAlbumInfoActivity extends AppCompatActivity implements ISohuSerials &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private Context mContext; private ProgressBar mProgressBar; private TextView mTip; private RelativeLayout mContainer; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam= new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mIsFromRefresh = false; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_album_view); mContext = this; mAlbumPresenter = new AlbumPresenter(this, Album.class); mContainer = (RelativeLayout) findViewById(R.id.id_success_content); mTip = (TextView) findViewById(R.id.id_tip); mProgressBar = (ProgressBar) findViewById(R.id.id_progress_bar); mRecyclerView = (PullLoadRecyclerView) findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); //通知Presenter层刷新数据 mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); //通知Presenter层加载下一页数据 &#125; &#125;); &#125; @Override public void showAlbumMainInfo(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;); &#125; &#125; @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"http err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc + \",errUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"server err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContainer.setBackgroundResource(android.R.color.white); mTip.setText(\"Sohu Serials album\"); &#125; else &#123; mContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125;&#125; 在上面代码中可以看到: 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onRefresh() 回调方法中，核心代码就是这一行 mAlbumPresenter.refresh(mParam); ，通知 Presenter 层去刷新数据， 至于 Presenter 层如何刷新。。 关我 View 层 X 事~ 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onLoadMore() 回调方法中,也是直接调用 mAlbumPresenter.loadingNext()。 下面说说 Presenter 层的代码 Presenter 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private ISohuSerials mBaseListView; private Handler mHandler = new Handler(Looper.getMainLooper()); private int mTotalCount; public AlbumPresenter(ISohuSerials baseListView, Class&lt;Album&gt; CLazz) &#123; super(baseListView, CLazz); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL); &#125; @Override public void serverResponse(Album album) &#123; mBaseListView.showAlbumMainInfo(album.getData().getVideos()); mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showProgress(false); &#125; &#125;); mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际使用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); return (pageIndex * pageSize) &lt;= mTotalCount; &#125;&#125; 首先是要继承之前编写的 BasePaginationPresenter类，泛型参数 BasePaginationParam 可以根据实际需求进行拓展，基本使用在前面已经介绍过，此处不做赘述。 Album 是搜狐视频电视剧频道返回数据的实体类，上面提到的 VideoInfo 包含在 Album 里面，因为现在只需要展示 VideoInfo 里的信息， 所以在 serverRespomse 方法里，有一个转换 mBaseListView.showAlbumMainInfo(album.getData().getVideos()); 实现父类 BasePaginationPresenter 中的抽象方法 serverHaveMoreData() ,思路就是 当前页面数 * 每一页的数据量，然后和 数据总量 比较大小。 Model 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 1 /** 2 * @author：ZengFanyu 3 */ 4 public class SohuAlbumModel&lt;Param extends BasePaginationParam&gt; implements IBaseModel&lt;Param&gt; &#123; 5 private static final String TAG = \"SohuAlbumModel\"; 6 private String url; 7 private int method; 8 private IBasePaginationPresenter mPaginationPresenter; 9 10 public SohuAlbumModel(IBasePaginationPresenter paginationPresenter) &#123;11 mPaginationPresenter = paginationPresenter;12 &#125;13 14 @Override15 public void sendRequestToServer(Param param) &#123;16 String validUrl = null;17 if (param != null &amp;&amp; !TextUtils.isEmpty(url)&amp;&amp;mPaginationPresenter.hasMoreData()) &#123;18 validUrl = getValidUrl(url, param);19 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl);20 &#125;21 Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"check param,url and server have data or not!\")22 if (!TextUtils.isEmpty(validUrl)) &#123;23 HttpUtils.executeByGet(validUrl, new Callback() &#123;24 @Override25 public void onFailure(Call call, IOException e) &#123;26 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \");27 e.printStackTrace();28 mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url);29 &#125;30 31 @Override32 public void onResponse(Call call, Response response) throws IOException &#123;33 if (!response.isSuccessful()) &#123;34 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\");35 mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url);36 &#125;37 38 String responseJson = response.body().string();39 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson);40 mPaginationPresenter.accessSuccess(responseJson);41 42 &#125;43 &#125;);44 &#125; else &#123;45 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\");46 &#125;47 &#125;48 49 private String getValidUrl(String url, Param param) &#123;50 return String.format(url, param.getPageIndex(), param.getPageSize());51 &#125;52 53 54 @Override55 public void setRequestUrl(String url) &#123;56 this.url = url;57 &#125;58 59 @Override60 public void setRequestMethod(int method) &#123;61 this.method = method;62 &#125;63 64 @Override65 public void cancelRequest() &#123;66 HttpUtils.cancelCall();67 &#125;68 &#125; Model 层的实现还是跟之前的一样，直接实现 IBaseModel 接口即可。 在 17 行可以看到，mPaginationPresenter.hasMoreData() ，这个就是对服务器点是否还有数据可以返回的判断，如果这里返回 false 那么就不回去进行网络请求,然后在 22 行打印个 Log 提醒。 在看看 49 行的 getVaildUrl 方法，这个方法主要就是把传进来的 param 参数拼接进 url 中，形成有效的，可以请求到数据的 Url。 效果图 Item 就展示了一下电视剧的 主演、名字、导演、集数、更新时间的信息。 小结通过上面的封装和例子，起码证明了这一套封装能够跑的通了，以后如果还有关于分页请求的需求，可以直接继承上面的基类来实现，无非就是修改param 和 Data 两个泛型的参数。 前者是请求 url 的参数，根据具体的业务需求，封装 BasePaginationParam 的子类即可。 后者是服务器端返回数据的实体类，也是根据数据的结构来封装的，在 Android Studio 中有 Gson Formatter 这个插件，封装 JavaBean 插件也轻松很多，在结合上面提到的 Gson 注解，全套了。 下一篇准备封装一下 OkHttp ,然后将封装之后的 OkHttp 整合到当前框架中,当然了,还是以分页接在为例","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android 当中的 MVP 模式（二）封装","slug":"MVP2","date":"2017-10-22T14:00:15.000Z","updated":"2017-10-23T15:04:26.414Z","comments":true,"path":"2017/10/22/MVP2/","link":"","permalink":"http://zengfanyu.top/2017/10/22/MVP2/","excerpt":"","text":"在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。 一个简单的网络请求 一个简单的需求：通过 url 获取数据，然后用 Gson 解析成 JavaBean，然后展示到 ListView上。这里使用知乎日报的获取最新消息的 API 接口 https://news-at.zhihu.com/api/4/news/latest 那么按照普通 MVP 的思路，首先 view 层： 为了突出重点，当前View层只做一件事情：就是展示获取的数据 ILatestVIew 此接口需要一个 String 类型的列表数据，主要是用于给 Adapter 展示用。 LatestViewActivity 很简答，就是实现接口。 IRequestLatestModel 请求服务器端数据的接口 RequestLatestNewsModel 使用 okhttp 请求数据，然后将返回的json类型数据传递给 Presenter 层。 ILatestNewsPresenter 一个接口用于处理 Json 数据，一个接口用于通知 model 层向服务器发起请求 。 LatestNewsPresenter 实现接口定义的方法 其中 HttpUtils 方法如下： 此处 OKhttp 也可以进行封装， 后面再写一篇文章， 专门记录，先暂时简单的使用。 运行之后，点击 button， 即可发起网络请求，运行效果如下： 弊端： 假设我们现在又有另外的一个需求， 请求知乎日报过往的消息， 对应的 API 接口为URL: https://news-at.zhihu.com/api/4/news/before/20131119,那么我就需要按照上述的方式，又写一套MVP的代码，最少又得留个类，如此一来，随着需求的增多，代码量会极具增大，但是多余增加的每层代码所做的事情又大多数相同，只是具体细节不一样，那么我们可不可以把每一层要做的事情给抽取出来，封装成基类，然后让子类去继承，去实现，这样就可以大量减少代码量？ 抱着这个问题，我就来分析一下 MVP 每一层所做的事情。 以简单网络请求为例，分析 MVP 各层的职责以上面请求知乎日报的最新消息为例，分析每一层的职责。 Model 层Model 角色主要是提供数据的存取功，并且将数据或者是错误信息回调给 Presenter 层。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。所以它主要的功能是： 1. 向数据源发起请求 2. 取消发起的请求 3. 通知 Presenter 处理结果 Presenter 层一般是通知 Model 向服务器发起请求，然后接收 Model 层的请求结果，包括成功的数据和错误的信息，同时也负责将处理之后的数据或者是错误信息通知 View 层，由 View 层作展示。所以他的主要功能是： 1. 通知 Model 层向服务器发起数据请求 2. 通知 Model 层取消这次请求 3. 接收 Model 层返回的数据 4. 接收 Model 层返回的错误信息 5. 通知 View 层接收处理之后的结果或者是错误信息 View 层此处 View 层的作用就比较专一化，只用于处理 UI 相关的事情，不再负责业务逻辑。主要职责如下： 1. Loading 状态的展示隐藏 2. 接收 Presenter 层处理后的数据 3. 接收 Presenter 层处理后的错误信息 4. 接收 Presenter 层处理后的服务器拒绝信息 嗯，差不多就是这么多吧 既然将每一层的主要职责总结了出来， 很明显就可以将这些职责「在代码中就是对应的方法」抽象成方法，然后让子类去个性化的实现。 抽取共性封装网络请求Model 层IBaseModel 其中 setMethod 和 setRequestUrl 方法直接在 Presenter 的构造方法中调用，设置好请求的方式和请求的 Url 地址，这样方便 model 层在请求服务器数据时，使用对应的参数，使用对应的请求方式。 此处没有用到 method 是因为知乎日报的最新新闻 API 接口是 Get 方式，不需要参数，所以此处没有根据请求方式来调用不同的请求方法 Presenter 层IBasePresenter Presenter 层是逻辑控制层，是 Model 层和 View 层的桥梁，对这一层抽取共性进行封装的时候，不能像 Model 层一样，把全部的功能装好好，原因如下： 1.如果将其全部封装起来，是没办法复用同一个功能模块的，并且会导致部分业务逻辑需要在 view 层中做处理，这样和 MVP 的思想相悖。 2.Presenter 层需要处理和 View 层的交互逻辑以及 Model 层返回的数据。 但是 Model 层是可以的，我是认为，Model 层就是从数据源中拿数据，并且将数据传递给 Presenter 层，所有的 Model 层做的都是这个操作，只是访问数据源的参数不同，数据源类型不同，访问数据源的方法不同而已，所以很明显可以全部抽取出来放基类中，然后各个子类去各自实现。 1. requestServer 在View层调用的接口，用于通知Model层想服务器发起请求，参数可为空，比如，有些Get方式的请求就不需要参数 2. requestSuccess 在Model层调用，通过此方法将服务器返回的数据传递给给Presenter层处理 3. cancelRequest 在View层调用，用于通知Model层取消请求 4. okHttpError 在Model层调用，当网络请求产生错误的时候 5. getModel 在子类中调用，用于拿到Model对象 6. getParams 在Model层中调用，此方法用于获取Presenter层处理好的参数 BasePresenter public abstract class BasePresenter&lt;Params, Data&gt; implements IBasePresenter&lt;Params&gt;这是一个泛型的抽象类，其中泛型Params是用于model层向服务器发起请求的请求参数，Data是服务器返回的Json类对应的JavaBean类。 BasePresenter处理了View层和model层中大多数的逻辑，我们要做的就是在子类中实现public abstract void serverResponse(Data data);这个抽象方法就好了。 public abstract void serverResponse(Data data);这个方法是在用于处理model层返回的结果，然后进行处理之后回调给view层。 可以看到46、47、50、51、52行的代码给注释掉了，其实一般情况下这里是不需要注释的，这里是用于判断返回数据的errorNum errorType errorDesc信息的，这么操作，是为了实现如下功能：若返回的信息有误，则BasePresenter直接回调给View层，如果正确，才会传递给子类。 上述最后一条，需要对泛型Data在进行一次封装，并且使用上 Gson 的@SerializedName(value = &quot;...&quot;,alternate = {&quot;...&quot;,&quot;...&quot;,&quot;...&quot;})这个注解，并且这里涉及到泛型擦除的问题，这一块我还没有很好的解决办法，所以此处没有进行封装。 View 层还是按照上面分析的 View 层职责来写： IBaseView 到此为止，对 MVP 模式的每一层都写出了对应的基类，有了这件基类作为基础之后，在进行同样的网络请求。 使用上述封装好的类进行相同的网络请求LatestNewsModel LatestNewsPresenter 其中Param泛型参数填的是nullable是因为这个请求是get方式，没有涉及到参数。LatestNews作为Data的泛型，主要是用于BasePresenter解析并映射。 ILatestNewsView IlatestNewsVIew接口是继承IBaseView接口的，是因为它需要在IBaseView接口所定义的功能之上，还需要实现将数据展示到列表中这么一个操作，所以添加上了一个showLatestViewTitle方法。 LatestNewsTitleActivity 这个类写起来就简单了，跟着接口来， 把之前每一个接口提到的功能给实现以下就可以了。 顺便贴个 XML 文件： 搞定，实现的效果和上面是一样的。 回过头一看，MMP，这代码量似乎也没有少很多啊，-。- ，没事没事，需求多了就少了~ 小结先看看上一篇中提到的一张图此处将MVP模式封装后，MVP的流程图如下： 后面的文章将使用上面封装的框架，通过扩展 BasePresenter 来增加新的模块。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（一）基本概念","slug":"MVP1","date":"2017-10-20T12:37:15.000Z","updated":"2017-10-23T15:04:38.919Z","comments":true,"path":"2017/10/20/MVP1/","link":"","permalink":"http://zengfanyu.top/2017/10/20/MVP1/","excerpt":"","text":"为什么要使用MVP在传统的Android开发中，我们一般是使用MVC模式进行开发的。 传统MVC模式介绍： View: 视图层，对应xml文件 Controller: 控制层，对应Activity和Fragment层，进行数据处理 Model：实体层，负责获取实体数据 采用MVC模式的一个最大的弊端就是xml作为View层视图能力实在太弱，所以一般情况下我们都是通过Controller层来辅助处理一些视图的。这样的结果就导致Controller既作为控制层的同时又承担了View层的大部分功能，采用MVC模式往往会导致Activity和Fragment中的代码非常复杂。我们将Android中采用的MVC模式称为MV模式更加恰当。 MVP模式介绍： View: 视图层，对应xml文件与Activity/Fragment Presenter: 逻辑控制层，同时持有View和Model对象 Model: 实体层，负责获取实体数据 MVP模式的流程图如下： 采用MVP模式的优势是： 把业务逻辑抽离到Presenter层中，View层专注于UI的处理。 分离视图逻辑与业务逻辑，达到解耦的目的。 提高代码的阅读性。 Presenter被抽象成接口，可以根据Presenter的实现方式进行单元测试。可拓展性强。 采用MVP模式的缺点： 项目结构会对后期的开发和维护有一定的影响。具体视APP的体量而定。 代码量会增多，如何避免编写过多功能相似的重复代码是使用MVP开发的一个重点要处理的问题。 有一定的学习成本。综上所述，在Android上采用MVP模式的优势是：大大优化代码的维护性与拓展性的同时对代码进行深度解耦，使各个层级的分工更加明晰。 一个简单的应用模拟Android中登陆的功能 界面 项目结构 从上图中可以看到，一个简单的基于 MVP 的项目，最少也需要创建 6 个文件夹，分别是 M、V、P 的接口和它们各自的实现类，其中 LoginActivity 就是 View 层的具体实现，它只需要负责处理 UI 的逻辑，而业务相关的逻辑都抽象到 LoginPresenter 中，这样就避免了传统开发中 Activity 、Fragment 既处理 UI 又负责业务逻辑的情况。 代码实现ILoginView： view层只负责和 UI 相关的操作，那么在这个小 Demo 中，和 UI 相关的操作有如下几点： 1. 从EditText中拿到用户输入的userName 2. 从EditText中拿到用户输入的password 3. 在登录过程中需要展示一个progressbar，登录过程结束之后隐藏这个progressbar 4. 展示登录成功后的view 5. 展示登录失败后的view 综上五个操作，所以有了ILoginView中的五个接口 LoginActivity： 当点击登录按钮时，会将请求服务器合适账号密码这个过程交给presenter层去处理，所以在LoginActivity里，会有preserent的引用。 ILoginPersenter： presenter层处理业务逻辑，有如下几点: 1. 负责接收model的返回结果并且处理 2. 将处理的结果以特定的形式，传递给view层，让view层去展示 3. 通知model层去向数据源请求数据 LoginPresenter： 因为presenter层相当于一个中间交互人，所以它必须要持有对 view 、model 层对象的引用。 ILoginModel： model负责数据的存取： 在这个Demo中，数据的存取使用一个线程和简单的字符串判断来模拟。 LoginModel： 因为model层需要将获取的数据传递给presenter层去做处理，所以此处也需要持有对presenter层的引用。 这样一来就成功的将简单的登录案例，由MVP模式来实现了, 在 LoginActivity 中处理的都是和 UI 相关的， 在 LoginPresenter 中处理的是业务的逻辑， 在 LoginModel 中处理的是网络数据获取。 小结 Presenter—交互中间人 主要作为沟通 View 和 Model 的桥梁，它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务从 View 角色上抽离出来。 View—用户界面 View 通常是指Activity、Fragment或者某个 View 控件，它含有一个 Presenter 成员变量。通常 View 需要实现一个逻辑接口，将 View 上的操作转换给 Presenter 进行实现，最后，Presenter 调用 View 逻辑接口将结果返回给 View 元素。 Model—数据的存取 对于一个结构化的 APP 来说，Model角色主要是提供数据的存取功能。Presenter 需要通过 Model 层存储、获取数据，Model就想一个数据仓库。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。 MVP 并不是一个标准化的模式，它有很多种实现方式，也可以根据自己的需求去修正MVP的实现方式，可以随着 Presenter 的复杂程度而变化，只要保证是通过 Presenter 将 View 和 Model 解耦，降低类型复杂度，各个模块单元可以独立测试、独立变化，这就是正确的方向。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-14T15:40:28.953Z","updated":"2017-10-21T16:06:55.127Z","comments":true,"path":"2017/10/14/hello-world/","link":"","permalink":"http://zengfanyu.top/2017/10/14/hello-world/","excerpt":"","text":"To be a better man1Hello , 个人博客搭好了，老规矩，先来个 Hello World！，然后，撸起袖子就是干！","categories":[],"tags":[]}]}