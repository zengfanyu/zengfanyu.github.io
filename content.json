{"meta":{"title":"CODE FRAMER BIGZ","subtitle":"Every little makes a mickel","description":null,"author":"BIGZ","url":"http://zengfanyu.top"},"pages":[{"title":"分类","date":"2017-10-25T14:59:18.000Z","updated":"2017-10-25T15:05:10.156Z","comments":false,"path":"categories/index.html","permalink":"http://zengfanyu.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:58:45.000Z","updated":"2017-10-25T15:05:14.395Z","comments":false,"path":"tags/index.html","permalink":"http://zengfanyu.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dagger2基础内容归纳","slug":"Dagger","date":"2017-11-04T06:37:15.000Z","updated":"2017-11-04T09:40:19.784Z","comments":true,"path":"2017/11/04/Dagger/","link":"","permalink":"http://zengfanyu.top/2017/11/04/Dagger/","excerpt":"摘要：最近看了很多讲 Dagger2 的文章，发现Dagger中很多基础的概念问题真的挺缥缈，很难理解透彻，其中有几篇确实写得不错，这里将他们总结一下，底部给上参考文章链接。","text":"摘要：最近看了很多讲 Dagger2 的文章，发现Dagger中很多基础的概念问题真的挺缥缈，很难理解透彻，其中有几篇确实写得不错，这里将他们总结一下，底部给上参考文章链接。 &gt;## @Inject ##@Inject 注解只是 JSR-330 中定义的注解,这个注解本身是没有意义的,它需要依赖于注入框架才有意义,用于标记需要被注入框架注入的方法,属性,构造方法,也就是说呗 @Inject 标记的就是用于提供依赖的.### @Inject 定义 ###123public @interface Inject &#123;&#125;### @Inject 的使用 ###1. 构造方法注入@inject 注解在在构造器注入上又有两层意思- 告诉 Dragger2 可以使用这个构造方法构建对象用于提供依赖- 注入构造方法所需要的参数的依赖2. 属性注入用于标注在属性上,被标注的属性不能用 private 修饰,否则无法注入3. 方法注入标注在 public 方法上,Dagger2 会在构造方法执行结束之后,立刻调用被 @inject 标注的方法.&gt;方法注入和属性注入没有本质的区别，那么什么时候用该使用方法注入，什么时候应该使用属性注入呢，比如依赖需要使用 this 对象的时候，就适合使用方法注入，因为方法注入是在构造方法执行结束之后就调用的，所以它可以提供安全的 this 对象。### Inject 的弊端 ###1. 假设我们现在依赖了第三方的框架,这个第三方的框架我们是不能修改的,所以我们无法注入.2. 如果某个用于提供依赖的类具有多个构造方法,我们只能标注一个,无法标注多个3. 当我们使用依赖倒置原则的时候，因为需要注入的对象是抽象的，因此也如法注入## @Component ##Component 负责将 被依赖对象 给注入到 需要依赖对象 当中,类似于一个中间层.### Component 定义 ###Dagger2 是使用 @Component 来完成依赖注入的, 定义如下: public @interface Component { Class&lt;?&gt;[] modules() default {}; Class&lt;?&gt;[] dependencies() default {}; }需要注意几点:1. Component 需要用接口来定义,2. 接口命名方式推荐为: *TargetClassName*Component3. 在编译之后,Dagger2 会生成 Dagger*TargetClassName*Component ,这是 *TargetClassName*Component 接口的实现4. 在 TargetClass 中使用 DaggerTargetClassNameComponent 就可以实现依赖注入###@Component 中定义方法的方式 ###1. void inject(TargetClassName calss)Dagger2 会从 TargetClass 开始查找 @Inject 注解,自动生成依赖注入的代码,调用 inject 即可完成依赖的注入2. TargetClass getTargetClass()Dagger2 会到 TargetClass 中寻找被@Inject 注解的构造方法,自动生成提供 TargetClass 依赖的代码,这种方式一般用于为其他的 Component 提供依赖,即一个 Component 作为另外一个 Component 的依赖3. 使用 @SubComponent 的方式123456789@Componentinterface AComponpent &#123; XxxComponent plus(Module... modules)&#125;@Subcomponent(modules = xxxxx)interface XxxComponent &#123;&#125;- xxxComponent 是该 AComponpent 的依赖，被 @Subcomponent 标注。- modules 参数则是 xxxComponent 指定的 Module。- 在重新编译后，Dagger2 生成的代码中，Subcomponent 标记的类是 Componpent 的内部类。总结一下 目前为止(后面还有Module注解) Component 的作用:Dagger2 以 Component 中定义的方法作为入口,到 TargetClass 中去寻找被 @Inject 标注的属性,查找到这个属性之后,就会去接着查找该属性对应的 用 @Inject 标注的构造函数,剩下的工作就是初始化该属性的实例,并且将实例赋值给属性.这是通过生成一系列提供依赖的 Factory 类和注入依赖的 Injector 类,来实现的.## Component 和 Inject 的关系小结 ##1. 用 @Inject 标注目标类中的其他类2. 用 @Inject 标注其他类中的构造方法3. 若其他类中还依赖于别的类，那么重复上述两个步骤4. 调用 Component 的 injectXXX 方法，Component 会把目标类依赖的实例给注入到目标类当中，用于初始化目标类当中的依赖。## @Module ##### Module 定义 ###1234public @interface Module &#123; Class&lt;?&gt;[] includes() default &#123;&#125;;&#125;### @Module 引入原因 ###如果我们项目当中使用了第三方的框架，那么可能某个 TargetClass 就持有对框架中某个类 C 实例的引用，那么按照上面两个注解的方式，我们就需要到框架当中 C 类的构造方法上面去标注一个 @Inject，况且不说构造方法多样性的问题（比如 Universal-Image-Loader 的 ImageLoader 类构造方法二三十个），框架当中的源码我们是不可以修改的啊。这个时候 @Inject 就失效了，我们就需要一个新的工具去注解，这时就引入了 @Module 了。12345678@Modulepublic class ModuleClass&#123; //A是第三方类库中的一个类 A provideA()&#123; return A(); &#125;&#125;Module 是一个简单工厂模式，Module 里面的方法基本上都是创建类实例的方法，那么此时如何让 Component 和 Module 产生联系呢？### Component 的新职责 ###Component 是注入器，它一端连接 TargetClass，另一端连接 TargetClass 依赖的实例，它把 TargetClass 依赖实例注入到 TargetClass 中。上文中的 Module 是一个提供类实例的类，所以 Module 应该是属于 Component 的实例端的（连接各种目标类依赖实例的端），Component 的新职责就是管理好 Module，Component 中的 modules 属性可以把 Module 加入 Component，modules 可以加入多个 Module。那么接下来的问题就是，如何将 Module 中各种提供实例的方法同 TargetClass 中 Inject 标注的类属性给链接起来，这个时候 Provides 就可以出来了。## @Provides ##### Provides 定义 ###123public @interface Provides &#123;&#125;Module 中创建实例的方法是用 Provides 标注的，之前说过，Component 搜索到 TargetClass 中用 @Inject 标注的属性之后，他就会去这个属性的类中寻找标注了 @Inject 的构造方法 ，其实在这个步骤之前，它优先去 @Module 标注的类中查找 @Provides 标注的用于创建实例的方法，如果没有找到，那么才会去查找标注了 @Inject 的构造方法。 这么一来，第三方类库的依赖注入问题就解决了。 上述注解小结1.Inject 是用于标注 TargetClass 中的依赖和依赖类中的构造函数的。 2.Component 是一个注入器（Injector） ，同时也起着桥梁的作用， 一端是类创建实例端(即负责创建生产类的实例),另外一端是 TargetClass 端（即需要进行依赖初始化的类），同时也负责管理 Module。 3.Module 和 Provides 是为觉得第三方库注入问题而引出的，Module 是一个简单工厂模式，Module 包含创建实例的方法，这个方法用 Provides 来标注。 4.创建依赖类有两个途径：通过 @Inject 标注的构造方法来创建； 通过 @Provides 标注的创建实例的方法来创建； 但是后者的优先级要大于前者，也就是说，Component 如果找到了后者，他就不会再接着去找前者。 5.@Module 要和 @Provides 配套使用，并且 @Component 也指定了该 Module 的时候，才能正常使用，@Module 告诉 @Component ，你可以从我这儿标注了 @Privides 的方法中获取实例。 6.Component 和 Module 是匹配关系 ， Component 依赖哪一个 Module 就需要在注解中用 muduls 属性标明。 @Inject @Component @Module @Provides 就是 Dagger2 框架中最核心的部分，奠定了整个框架的基础，下面的标签就是针对细节问题的处理。 @Qualifier问题的引出现在有种情况，用上述注解无法解决： 根据依赖倒置原则，我们应该面向接口编程，或者是面向抽象编程，在 Java 中多态的性质很好的支持了这一原则，所以我们经常会在类中申明的是某一属性的接口，或者是抽象类，这样操作在程序编译的时刻，是不能确定这个属性的具体实例是哪一个子类，只能在运行时才能确定下来，那么这个时候 Component 怎么知道应该将哪一个子类给注入到 TargetClass 的属性当中 ？ 基于上面两个问题，就提出了 @Qualifier 注解，它就是用于解决上述问题的。 这个时候就需要给各个 抽象类或者接口 的子类的构造方法标注 @Qualifier，类似于给他们一个 ID ，通过这个 ID 就可以区分不同的子类。 Qualifier 的定义123public @interface Qualifier &#123;&#125; 这个注解跟 @Inject 一样，不是 Dagger 定义的， 而是 JSR-330 中定义的。 Qualifier 是用于定义注解的。 Qualifier 使用方法 使用 @Qualifier 根据子类的不同，分别定义新的注解，注解要有含义 分别使用新的注解去标注生成不同子类实例的地方，然后要使用哪一个子类的实例，是到抽象属性上标注子类对应的新的注解。 @Scope 和 @SingleScole 的定义123public @interface Scope &#123;&#125; 也是 JSR-330 定义的，不是 Dagger 中定义的 用于自定义注解 @Single 是 @Scope 的默认实现，如下： 12345@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; Scope 的作用 它的作用只是保证依赖在 @Component 中是唯一的，可以理解为“局部单例”。 @Scope 是需要成对存在的，在 Module 的 Provide 方法中使用了 @Scope，那么对应的 Component 中也必须使用 @Scope 注解，当两边的 @Scope 名字一样时（比如同为 @Singleton）, 那么该 Provide 方法提供的依赖将会在 Component 中保持“局部单例”。 而在 Component 中标注 @Scope，provide 方法没有标注，那么这个 Scope 就不会起作用，而 Component 上的 Scope 的作用也只是为了能顺利通过编译。 这么说 @Single 是没有创建单例的能力，因为他只是保证在 Component 中的唯一的，那怎么实现真正的单例呢？ 单例的实现 依赖在 Component 中是单例的（供该依赖的 provide 方法和对应的 Component 类使用同一个 Scope 注解。） 对应的 Component 在 App 中只初始化一次，每次注入依赖都使用这个 Component 对象。（在 Application 中创建该 Component） Lazy这个比较简单，延迟加载模式，用 Lazy&lt;T&gt; 装饰需要被 @Inject 标注的属性 T ，这样，在 Inject 的时候并不会初始化它，而是在使用 T 的时候，通过 T.gey() 来得到他的实例，然后再使用。 Component 组织方式这是重中之重，前面的概念都是做铺垫，这里从一个 APP 的角度将他们融合起来。 一个app中应该根据什么来划分Component假如一个 app （app 指的是 Android app）中只有一个 Component，那这个 Component 是很难维护、并且变化率是很高，很庞大的，就是因为 Component 的职责太多了导致的。所以就有必要把这个庞大的 Component 进行划分，划分为粒度小的 Component。那划分的规则这样的： 要有一个全局的 Component (可以叫 ApplicationComponent ),负责管理整个 app 的全局类实例（全局类实例整个 app 都要用到的类的实例，这些类基本都是单例的） 每个页面对应一个 Component，比如一个 Activity 页面定义一个 Component，一个 Fragment 定义一个 Component。当然这不是必须的，有些页面之间的依赖的类是一样的，可以公用一个 Component。 第一个规则应该很好理解，具体说下第二个规则，为什么以页面为粒度来划分 Component？ 一个 app 是由很多个页面组成的，从组成 app 的角度来看一个页面就是一个完整的最小粒度了。 一个页面的实现其实是要依赖各种类的，可以理解成一个页面把各种依赖的类组织起来共同实现一个大的功能，每个页面都组织着自己的需要依赖的类，一个页面就是一堆类的组织者。 划分粒度不能太小了。假如使用 mvp 架构搭建 app，划分粒度是基于每个页面的m 、v 、p 各自定义 Component 的，那 Component 的粒度就太小了，定义这么多的 Component，管理、维护就很非常困难。 所以以页面划分 Component 在管理、维护上面相对来说更合理。 组织Component我们已经把一个 app 按照上面的规则划分为不同的 Component 了，全局类实例也创建了单例模式。问题来了：其他的 Component 想要把全局的类实例注入到目标类中该怎么办呢？这就涉及到类实例共享的问题了，因为 Component 有管理创建类实例的能力。因此只要能很好的组织 Component 之间的关系，问题就好办了。具体的组织方式分为以下2种： 依赖方式一个 Component 是依赖于一个或多个 Component，Component 中的 dependencies 属性就是依赖方式的具体实现 包含方式一个 Component 是包含一个或多个 Component 的，被包含的 Component 还可以继续包含其他的 Component。这种方式特别像 Activity 与 Fragment 的关系。SubComponent 就是包含方式的具体实现。 Dagger 注入一次的流程步骤1：查找 Module 中是否存在创建该类的方法。 步骤2：若存在创建类方法，查看该方法是否存在参数 步骤2.1：若存在参数，则按从**步骤1**开始依次初始化每个参数 步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 步骤3：若不存在创建类方法，则查找 Inject 注解的构造函数，看构造函数是否存在参数 步骤3.1：若存在参数，则从**步骤1**开始依次初始化每个参数 步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 总结对象 Android：dagger2让你爱不释手-基础依赖注入框架篇 Android：dagger2让你爱不释手-重点概念讲解、融合篇 Android：dagger2让你爱不释手-终结篇","categories":[{"name":"Dagger","slug":"Dagger","permalink":"http://zengfanyu.top/categories/Dagger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"Dagger","slug":"Dagger","permalink":"http://zengfanyu.top/tags/Dagger/"}]},{"title":"Android当中的MVP模式（六）View 层 Activity 的基类--- BaseMvpActivity 的封装","slug":"MVP6","date":"2017-11-03T12:37:15.000Z","updated":"2017-11-04T09:40:07.772Z","comments":true,"path":"2017/11/03/MVP6/","link":"","permalink":"http://zengfanyu.top/2017/11/03/MVP6/","excerpt":"摘要：使用封装之后的 MVP 模式实现一个新的界面，也就是 Vie 层，那么就需要去实现 IBaseView 接口，可能还需要针对当前要实现的界面情况，在 IBaseView 的基础之上派生出一个新的接口 IXxxView,之前的 SohuAlbumInfoActivity 用于展示搜狐电视剧主要信息的 View 就是这种情况,由 IBaseView 派生了一个 ISohuSerials ,再由 SohuAlbumInfoActivity 去实现,那么随着需要展示的界面越来越多,它们坐着大量重复的工作,我们就要像个方法来简化这个过程了。","text":"摘要：使用封装之后的 MVP 模式实现一个新的界面，也就是 Vie 层，那么就需要去实现 IBaseView 接口，可能还需要针对当前要实现的界面情况，在 IBaseView 的基础之上派生出一个新的接口 IXxxView,之前的 SohuAlbumInfoActivity 用于展示搜狐电视剧主要信息的 View 就是这种情况,由 IBaseView 派生了一个 ISohuSerials ,再由 SohuAlbumInfoActivity 去实现,那么随着需要展示的界面越来越多,它们坐着大量重复的工作,我们就要像个方法来简化这个过程了。 回顾前几篇中 View 层的写法根据MVP系列第二篇当中的分析， View 层的职责如下： Loading 状态的展示隐藏 接收 Presenter 层处理后的数据 接收 Presenter 层处理后的错误信息 接收 Presenter 层处理后的服务器拒绝信息 所以当就将着一些职责抽象成方法，放在 IBaseView 接口中，看看之前的的 IBaseView： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by fanyuzeng on 2017/10/20. * @author : ZengFanyu */public interface IBaseView &#123; /** * 进行耗时操作时的用户友好交互接口，比如显示ProgressBar * * @param isShow * @author zfy * @created at 2017/10/21/021 14:12 */ void showProgress(boolean isShow); /** * 显示网络请求错的的接口 * * @param errorCode * @param errorDesc * @param errorUrl * @author zfy * @created at 2017/10/21/021 14:14 */ void showOkHttpError(int errorCode, String errorDesc, String errorUrl); /** * 现实服务器端请求错误的接口 * * @param errorCode * @param errorDesc * @author zfy * @created at 2017/10/21/021 14:14 */ void showServerError(int errorCode, String errorDesc); /** * 请求成功或者失败之后，对应UI做出改变的接口 * * @param isSuccess * @author zfy * @created at 2017/10/21/021 14:15 */ void showSuccess(boolean isSuccess); View 层每需要添加一个类， View 层的对象都需要在它的基础上去实现，比如说，在 MVP系列第三篇中，需要对搜狐视频电视剧频道的主要信息做分页展示，当时是在 IBaseView 的基础上派生出了一个 ISohuSerials ： 1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 然后再使用 SohuAlbumInfoActivity 去实现这个接口，对 IBaseView 和 ISohuSerials 中的方法又做了一遍实现，但是这次的实现过程，跟MVP系列第二篇中的 LatestNewsTitleActivity 实现的功能几乎一致，并且这个时候，我就意识到 IBaseView 接口设计的缺陷，我们在 IBaseView 的基础上派生出 ISohuSerials 接口 ILatestNewsView 接口，无非就是要展示不同类型的数据，那这个功能完全可以整合进 IBaseView 接口中，至于不同页面的数据类型不同，我们完全可以使用泛型来解决。 下面就来解决这两个问题： 将展示 Presenter 层实例好的数据的方法，由派生接口整合至基类接口中，使用泛型解决数据类型不同的问题。 封装 BaseMvpActivity，实现共有逻辑，子类不重复处理 View 层基类接口（IBaseView）中的方法。 IBaseView 的重构再回顾一下，之前要展示知乎日报的最新消息的标题内容，我写了一个 ILatestNewsView 接口，它长这样： 12345public inerface ILatestNewsView extends IBaseView &#123; void showLatestNewsTitle(List&lt;String&gt; titles)&#125; 后来又需要展示搜狐电视剧主要信息，于是写了一个 ISohuSerials ，： 12345public interface ISohuSerials extends IBaseView &#123; void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 当时怎么想的，要整个这接口出来 - - ！ 现在把他们都整合进 IBaseView： 12345678910public interface IBaseView&lt;Data&gt; &#123; //省略代码/** * 显示presenter层处理好之后的数据 * @param data data */ void showDataFromPresenter(Data data); 此处添加了一个泛型 Data ，它就可以用于指代上面两个接口中的 List&lt;String&gt; titles 和 List&lt;VideoInfo&gt; videoList ，或者是其他的数据了类型，然后在实现接口的类中去指明参数的类型就可以动态的更改它的类型了。 BaseMvpActivity 的封装上述是对之前遗留问题的一个解决，从这儿开始才正式对基类 BaseMvpActivity 进行封装。 ToolBar 的统一处理首先， Demo 是在 API 25 ，所以对 ToolBar 也要有良好的支持，所以首先是对 ToolBar 的封装，将 ToolBar 写到一个单独的 Layout 文件之中，方便其他文件引用。top_action_bar： 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt;&lt;!-- android:popupTheme 用于自定义弹出的菜单的样式--&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_tool_bar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" android:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:titleTextColor=\"#ffffff\" &gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 在 BaseMvpActivity 中的统一处理如下： 1234567891011121314151617protected void setSupportActionBar() &#123; if (mToolbar != null) &#123; setSupportActionBar(mToolbar); &#125;&#125;protected void setActionBarIcon(int resId) &#123; if (mToolbar != null) &#123; mToolbar.setNavigationIcon(resId); &#125;&#125;protected void setSupportArrowActionBar(boolean isSupport) &#123; getSupportActionBar().setDisplayHomeAsUpEnabled(isSupport);&#125; 这样处理了之后，在子类当中，就可以直接调用上述方法，就可以使用 ToolBar了， 当然，对 ToolBar 的自定义需要另外去处理。 BaseMvpActivity 的布局文件的处理由于 BaseMvpActivity 是要作为 MVP 模式下，所有 View 层的基类，所以它自己需要有布局文件，将 IBaseView 中的接口实现， activity_base_mvp： 123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/top_action_bar\"/&gt; &lt;TextView android:id=\"@+id/id_tip_content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_horizontal\" android:textSize=\"16sp\" android:text=\"tip\"/&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:id=\"@+id/id_content_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;ProgressBar android:id=\"@+id/id_progress_bar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:visibility=\"gone\"/&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 第 7 行的 include 文件，就是对上面 top_action_bar 的引用。 第 10 行的 TextView 这里用来实现 IBaseView 中 showOkHttpError 和 showServerError接口的。 第 22 行的 FrameLayout 很重要，看 id 就知道了，它是用于展示子类页面的方法的，直接将子类的布局文件给 add 进来。类似于： 1234View contentView = LayoutInflater.from(this).inflate(R.layout.activity_album_view, null);FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);mContentContainer.addView(contentView, lp); 第 27 行的 ProgressBar 就是用于实现 IBaseView 中 showProgress 的。 BaseMvpActivity 对 IBaseView 的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * @author:fanyuzeng * @date: 2017/10/30 13:50 * @desc: */public abstract class BaseMvpActivity&lt;Data&gt; extends AppCompatActivity implements IBaseView&lt;Data&gt; &#123; private static final String TAG = \"BaseMvpActivity\"; protected Toolbar mToolbar; protected ProgressBar mProgressBar; protected TextView mTipView; protected FrameLayout mContentContainer; protected Handler mHandler = new Handler(Looper.getMainLooper()); protected Context mContext; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_base_mvp); mContext = this; mToolbar = bindViewId(R.id.id_tool_bar); mProgressBar = bindViewId(R.id.id_progress_bar); mTipView = bindViewId(R.id.id_tip_content); mContentContainer = bindViewId(R.id.id_content_container); beforeInitViews(); initViews(); afterInitViews(); &#125; protected &lt;T extends View&gt; T bindViewId(int resId) &#123; return (T) findViewById(resId); &#125; //统一处理ToolBar @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTipView.setText(\"errorCode:\" + errorCode + \",errorDesc:\" + errorDesc + \",errorUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTipView.setText(\"errorCode:\" + errorCode + \",errorDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContentContainer.setBackgroundResource(android.R.color.white); &#125; else &#123; mContentContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: finish(); break; default: break; &#125; return super.onOptionsItemSelected(item); &#125; /** * 子类实现,用于初始化控件 */ protected abstract void initViews(); /** * 子类实现 在初始化控件之后进行的操作 */ protected abstract void afterInitViews(); /** * 子类实现, 在初始化控件之前的操作 */ protected abstract void beforeInitViews();&#125; 做了几点事情 实现了 IBaseView 中的接口 对 ToolBar 做统一处理 findViewById方法处理 Menu Item 中返回按键的处理 还有一个问题，似乎少了一个方法？就是在上一小节中，整合进 IBaseView 接口中的 void showDataFromPresenter(Data data) ,还没有实现。由于这里的 BaseMvpView 是 abstract 的，所以它可以不实现，也实现不了，因为实现这方法需要知道泛型参数 Data 的具体类型，所以这个函数是留给子类去实现的。上面三个抽象方法也很好理解，就是用于子类初始化操作的，并且都在基类初始化之后才执行，这一点很重要，因为子类中是需要将布局文件给 add 到基类布局当中的，所以基类的组件也必须提前初始化好。下面就看看子类中是如何处理的。 SohuAlbumInfoActivity 的重构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @author：ZengFanyu * Function: */public class SohuAlbumInfoActivity extends BaseMvpActivity&lt;List&lt;VideoInfo&gt;&gt; &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam = new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; private boolean mIsFromRefresh = false;// private View mContentView; @Override protected void beforeInitViews() &#123; mRecyclerView = new PullLoadRecyclerView(this); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); mContentContainer.addView(mRecyclerView, lp); // View contentView = LayoutInflater.from(this).inflate(R.layout.activity_album_view, null);// FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);// mContentContainer.addView(contentView, lp); &#125; @Override protected void initViews() &#123; setSupportActionBar(); //表示当前页面支持ActionBar setTitle(TAG); setSupportArrowActionBar(true); mAlbumPresenter = new AlbumPresenter(this, Album.class); mTipView.setText(TAG);// mRecyclerView = (PullLoadRecyclerView)mContentView.findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); &#125; &#125;); &#125; @Override protected void afterInitViews() &#123; &#125; @Override public void showDataFromPresenter(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); mTipView.setText(TAG); &#125; &#125;); &#125; &#125;&#125; 15 行的 beforeInitViews 方法，就是用于初始化子类的布局的，由于这个子类布局比较简单， 就是一个 RecyclerView ，所以可以直接用代码实现，然后给 add 进父类的 mContentContainer，或者用下面注释掉的，常规尝试来实现。 第 5 行，泛型参数为 List&lt;VideoInfo&gt; ,这个参数就是用于上面提到的，未实现的方法当中的，指定了泛型参数的类型。 第 26 行的 initViews 方法就用户初始化子类的 View showDataFromPresenter 的写法和未封装之前是一样的。 LatestNewsTitleActivity 的重构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author ZengFanyu */public class LatestNewsTitleActivity extends BaseMvpActivity&lt;List&lt;String&gt;&gt; &#123; private ListView mListView; private LatestNewsPresenter mBasePresenter; LatestNewsAdapter mAdapter; private View mContentView; @Override protected void beforeInitViews() &#123; mContentView = LayoutInflater.from(this).inflate(R.layout.activity_latest_news, null); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); mContentContainer.addView(mContentView, lp); &#125; @Override protected void initViews() &#123; mBasePresenter = new LatestNewsPresenter(this, LatestNews.class); mTipView.setText(LatestNews.class.getSimpleName()); mListView = (ListView) mContentView.findViewById(R.id.id_list_view); Button btnLatestNews = (Button) mContentView.findViewById(R.id.id_btn_latest_news); btnLatestNews.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mBasePresenter.requestServer(null); &#125; &#125;); &#125; @Override protected void afterInitViews() &#123; &#125; @Override public void showDataFromPresenter(List&lt;String&gt; titles) &#123; if (mAdapter != null) &#123; mAdapter.clear(); mAdapter = null; &#125; mAdapter = new LatestNewsAdapter(titles, mContext); mListView.setAdapter(mAdapter); mAdapter.notifyDataSetChanged(); mTipView.setText(LatestNews.class.getSimpleName()); &#125;&#125; 写法和上面一样，但是比起之前的代码量来说，已经少了很多了，并且对比这两个子类，都没有重复的实现方法，只专注于自己需要实现的逻辑。 还有其他的 View 层类和上述的实现过程类似，此处不再赘述。 下一篇这个系列的最后一篇准备些关于 MVP 模式在开发中使用，随着项目的复杂程度的提高， Presenter 会越来越臃肿的问题的解决思路。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（五）封装之后的OkHttp工具在Model层的使用","slug":"MVP5","date":"2017-11-02T12:37:15.000Z","updated":"2017-11-04T09:39:14.077Z","comments":true,"path":"2017/11/02/MVP5/","link":"","permalink":"http://zengfanyu.top/2017/11/02/MVP5/","excerpt":"摘要:在上一篇中对 OkHttp 进行了简单的封装,但是没有使用到这个系列当中的 Demo 里面,这一章就使用上一篇封装的 OkHttp 工具,替换掉之前 Demo 里面的 Model 层的网络请求.并且之前的部分接口方法都没有使用,比如说 IBasePresenter 接口中的 HashMap getParams() 方法, IBasePaginationPresenter 中的 boolean hasMoreData() 方法，算是对上一篇的补充。","text":"摘要:在上一篇中对 OkHttp 进行了简单的封装,但是没有使用到这个系列当中的 Demo 里面,这一章就使用上一篇封装的 OkHttp 工具,替换掉之前 Demo 里面的 Model 层的网络请求.并且之前的部分接口方法都没有使用,比如说 IBasePresenter 接口中的 HashMap getParams() 方法, IBasePaginationPresenter 中的 boolean hasMoreData() 方法，算是对上一篇的补充。 Model 层原来的写法拿分页数据获取的 Model 层举例,当时在 SohuAlbumModel 中是这样获取数据的: 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void sendRequestToServer(Param param) &#123; String validUrl = null; Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"has more data ?\" + mPaginationPresenter.hasMoreData()); if (param != null &amp;&amp; !TextUtils.isEmpty(url) &amp;&amp; mPaginationPresenter.hasMoreData()) &#123; validUrl = getValidUrl(url, param); Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl); &#125; if (!TextUtils.isEmpty(validUrl)) &#123; HttpUtils.executeByGet(validUrl, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \"); e.printStackTrace(); mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\"); mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url); &#125; String responseJson = response.body().string(); Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson); mPaginationPresenter.accessSuccess(responseJson); &#125; &#125;); &#125; else &#123; Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\"); &#125;&#125;private String getValidUrl(String url, Param param) &#123; return String.format(url, param.getPageIndex(), param.getPageSize());&#125; url 当中的参数是直接在 sendRequestToServer 方法中传递进来的,这么一来会让 Model 层的职责变得不那么单一,因为 Model 层只应该负责数据相关的工作,此处的 params 传递进来,还需要进行一个 url 的拼接工作,所以在这里是可以优化的地方。 在看看上一篇中的 OkHttpManager 类中请求服务器数据的核心方法： 123456789101112131415161718192021/** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 使用 OkHttpManager 来请求服务器获得数据，第二个参数 HashMap&lt;String, String&gt; paramsMap 就是已经在 Presenter 层中处理好的键值对参数，然后在 CommonRequest.createGetRequest(baseUrl, requestParams); 或者是 CommonRequest.createPostRequest(baseUrl, requestParams) 中就已经把完整的 url 拼接出来了。具体如何拼接，如何构造 Request 对象，Model 层完全不用关心，它只需要在请求成功或者是请求失败的回调接口中将数据回调到 Presenter 层去即可。 那么现在就开始重构 Model 层的方法。 Model 层现在的写法12345678910111213141516171819202122@Overridepublic void sendRequestToServer() &#123; if (mPaginationPresenter.hasMoreData()) &#123; OkHttpManager.getInstance().requestServerData(method, baseUrl, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; @Override public void onSuccess(Object responseObj) &#123; String responseJson = (String) responseObj; Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); mPaginationPresenter.accessSuccess(responseJson); &#125; @Override public void onFailure(OkHttpException exception) &#123; Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode()); mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url); &#125; &#125;, null)); &#125;else &#123; Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"No more data!\"); &#125;&#125; 是不是简单了很多！和之前的方法相比较，有三处不同的地方： 第 2 行的 sendRequestToServer() 方法中已经没有了 param 参数了。（那么参数从哪儿来呢？） 第 3 行多了一个 hasMoreData() 的方法，用于判断服务器端还有没有更多的数据。若没有，那就没有必要去请求了。它是在哪儿初始化的？ 第 4 行的多了 mPaginationPresenter.getParams() ，它是在什么地方初始化的? 第 4 行的 baseurl 不是之前 Model 层的 url 下面就解释为什么可以这么操作。 BasePaginationPresenter 的修改观察之前 Model 层的写法就知道，这个地方的参数，主要是从其中取出 pageIndex 和 pageSize ，用于拼接新的 url ，然后再请求数据，这儿不需要这个参数了， 那肯定就是有地方已经提供了这个参数了咯。 对，就是 mPaginationPresenter.getParams() 这个之前没有用过的方法，先回顾一下这个方法在哪儿定义的： 1234567891011public interface IBasePresenter&lt;Param&gt; &#123; //省略部分代码 /** * 在Model层中调用，此方法用于获取Presenter层处理好的参数 * @author zfy * @return 请求参数 * @Created at 2017/10/21/021 15:05 */ HashMap&lt;String, String&gt; getParams();&#125; 在第二篇中，针对每一层封装的时候，这个接口就已经定义好了，只是一直没有使用上，在这儿就用上了。而 BasePaginationPresenter 类是实现这个街口的，并且这个 Presenter 是分页请求数据中 Presenter 层的基类，在第三篇也提到过。下面看看 BasePaginationPresenter ： 1234567891011121314151617181920212223242526272829303132333435/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePaginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; //省略部分代码 /** * 子类实现，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); /** * 子类实现,用于返回请求服务器的url当中的参数 * * @return HashMap&lt;String,String&gt; url 中的 kay value 对 */ public abstract HashMap&lt;String, String&gt; getHttpRequestParams(); //省略部分代码 @Override public HashMap&lt;String, String&gt; getParams() &#123; return getHttpRequestParams(); &#125; @Override public boolean hasMoreData() &#123; return serverHaveMoreData(); &#125;&#125; 只贴出和之前不同的部分， 多了一个 serverHaveMoreData() 抽象方法，子类去实现的，用于判断服务器还有没有更多的数据。 多了以个 getHttpRequestParams() 抽象方法，子类去实现，用于将参数填充到 HashMap 中，供 Model 层使用。 接下里看看子类 AlbumPresenter 的实现： AlbumPresenter 的修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private int mTotalCount=-1; public AlbumPresenter(BaseMvpActivity baseListView, Class&lt;Album&gt; aClass) &#123; super(baseListView, aClass); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL_BASE); &#125; //省略代码 @Override public void serverResponse(Album album) &#123; //省略代码 mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际适用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); //第一次需要返回true 才能进到 serverResponse 方法中去初始化 mTotalCount 值 return mTotalCount == -1 || (pageIndex * pageSize) &lt;= mTotalCount; &#125; @Override public HashMap&lt;String, String&gt; getHttpRequestParams() &#123; HashMap&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); paramsMap.put(\"cid\", \"2\"); paramsMap.put(\"o\", \"1\"); paramsMap.put(\"plat\", \"6\"); paramsMap.put(\"poid\", \"1\"); paramsMap.put(\"api_key\", \"9854b2afa779e1a6bff1962447a09dbd\"); paramsMap.put(\"sver\", \"6.2.0\"); paramsMap.put(\"sysver\", \"4.4.2\"); paramsMap.put(\"partner\", \"47\"); paramsMap.put(\"page\", String.valueOf(mParam.getPageIndex())); paramsMap.put(\"page_size\", String.valueOf(mParam.getPageSize())); return paramsMap; &#125;&#125; 与之前实现不同地方在于： 构造方法当中设置的 url ，现在是 baseUrl ，后面的参数由 getHttpRequestParams方法生成，在CommonRequest 中生成完整 url。 serverResponse() 方法中，对 mTotalCount 进行了初始化， 这个值就是记录服务器端一共有多少条数据的。 serverHaveMoreData()拿当前已经加载的数据条数和 mTotalCount 进行对比，判断是否还有数据。 getHttpRequestParams() 构造参数的 HashMap 。 小结从这一章的从重构部分代码，很明显可以看到，各层之间的依赖关系： 主要是替换网络请求的工具，那么就是只涉及到 Model 层的改动。 这里 Presenter 层改动了，其实是不需要改动的， 这里改动了的原因是，我把之前没有实现的功能补上了，并且将sendRequestToServer() 的参数去掉了导致的。 可以发现， View 层代码没有进行一点修改，也就是 Activity 并没有动。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（四）插曲-封装OkHttp","slug":"MVP4","date":"2017-10-27T14:37:15.000Z","updated":"2017-10-29T12:38:18.194Z","comments":true,"path":"2017/10/27/MVP4/","link":"","permalink":"http://zengfanyu.top/2017/10/27/MVP4/","excerpt":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，并且可用性也不高，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。","text":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，并且可用性也不高，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。 官方给的例子 同步方法 1234567891011OkHttpClient client = new OkHttpClient();String run(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string();&#125; 异步方法 1234567891011121314151617OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125; 封装思路结合上面异步方法，稍作分析，涉及到如下几个对象 OkHttpClient , Request , Call,Response ,其他的都一些方法的调用，而 Response 是返回结果的对象，所以我们的封装应该重点针对剩余三个对象来进行。 RequestRequest 在 Okhttp 当中是抽象出来的一个请求对象，它封装了请求报文信息：请求的 Url 地址，请求的方法（Get Post等），各种请求头（Content-Type Cookie）以及可以选择的请求体，一般通过内部的 Builder 类来构建对象，建筑者设计模式。 那么我们这里就针对 Post Get 两种请求方式做封装，但是这里又涉及到一个问题，就是我们还需要参数，用于拼接请求 Url 的参数，举个栗子： 这是搜狐电视剧频道的 API 接口： 12http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22?cid=2&amp;o=1&amp;plat=6&amp;poid=1&amp;api_key=9854b2afa779e1a6bff1962447a09dbd&amp;%22%20+%20%22sver=6.2.0&amp;sysver=4.4.2&amp;partner=47&amp;page=1&amp;page_size=10 这么看可能特别的麻烦，我们把它拆分一下： 12String baseUrl=http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22 然后剩下的都是参数了，以键值对的形式存在： 这些参数拼接在 baseUrl 后面的顺序是没有要求的，不一定要按照上面的顺序来，只要每个参数都按照固定的格式出现就可以。 看上面的完整 Url 可以发现规律，在 baseUrl 后面有一个 ？， 然后就就是 key1=value1&amp;key2=value2&amp;key3=value3 这种形式的 其实遵循 RESTful API 设计的接口，都会是这种形式，所以这里也利于我们进行封装了。而 key-value 这种形式，就特别适合使用 Map 结构来封装。 说这么多，上代码，首先是对参数进行封装： RequestParam 12345678910111213141516171819202122232425262728293031323334353637/** * @author:fanyuzeng * @date: 2017/10/27 13:55 * @desc: 封装url中的参数 */public class RequestParams &#123; /** * 使用&#123;@link ConcurrentHashMap&#125;是为了保证线程安全 */ private ConcurrentHashMap&lt;String, String&gt; urlParams = new ConcurrentHashMap&lt;&gt;(); public RequestParams() &#123; &#125; public RequestParams(Map&lt;String, String&gt; source) &#123; for (Map.Entry&lt;String, String&gt; entry : source.entrySet()) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; public RequestParams(String key, String value) &#123; put(key, value); &#125; private void put(String key, String value) &#123; if (!TextUtils.isEmpty(key) &amp;&amp; !TextUtils.isEmpty(value)) &#123; urlParams.put(key, value); &#125; &#125; public ConcurrentHashMap&lt;String, String&gt; getUrlParams() &#123; return urlParams; &#125;&#125; 这地方使用 ConcurrentHashMap 就是为了保证线程安全的，这个类使用的是锁分段技术，不同于一般的同步方法或者是同步代码块，它只会锁住其中一个 segment，其他的 segment 仍然是可以访问的，所以他的效率会比 synchronized 高。 有了 RequestParam 之后，就可以使用它来拼接 url，有了 url 之后，就可以使用它来构建 Request对象了。 CommonRequest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1 /** 2 * @author: fanyuzeng 3 * @date: 2017/10/27 14:08 4 * @desc: response for build various kind of &#123;@link okhttp3.Request&#125; include Get Post upload etc. 5 */ 6 public class CommonRequest &#123; 7 private static final String TAG = \"CommonRequest\"; 8 /** 9 * create a Get request10 *11 * @param baseUrl base url12 * @param params see &#123;@link RequestParams&#125;13 * @return &#123;@link Request&#125;14 * @created at 2017/10/27 14:3915 */16 public static Request createGetRequest(@NonNull String baseUrl, @Nullable RequestParams params) &#123;17 StringBuilder urlBuilder = new StringBuilder(baseUrl).append(\"?\");18 if (params != null) &#123;19 //将请求参数合并进url中20 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;21 urlBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&amp;\");22 &#125;23 24 Log.d(TAG,\"&gt;&gt; createGetRequest &gt;&gt; \" + urlBuilder.toString());25 &#125;26 return new Request.Builder().get().url(urlBuilder.substring(0, urlBuilder.length() - 1)).build();27 &#125;28 29 /**30 * create a post request31 *32 * @param baseUrl base url33 * @param params see &#123;@link RequestParams&#125;34 * @return &#123;@link Request&#125;35 * @created at 2017/10/27 14:3936 */37 public static Request createPostRequest(@NonNull String baseUrl, @NonNull RequestParams params) &#123;38 FormBody.Builder mFormBodyBuilder = new FormBody.Builder();39 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;40 mFormBodyBuilder.add(entry.getKey(), entry.getValue());41 &#125;42 FormBody formBody = mFormBodyBuilder.build();43 return new Request.Builder().post(formBody).url(baseUrl).build();44 &#125;45 46 &#125; 第 16 行的 createGetRequest 方法是用于创建一个 Get 请求，主要就是使用 StringBuilder 进行 Url 的拼接，第 37 行的 createPostRequest 方法是用于创建一个 Post 请求的。 Post 请求是先创建 FormBody ，然后和 baseUrl 一个构造 Request 。 封装到这里， Request 就算是封装完了， 当然这里只封装了 Post Get ，也可以继续封装文件上传和文件下载的Request。 CallCall 代表的是一个实际的 HTTP 请求，它是链接 Request 和 Response 的桥梁，通过 Request 对象的 newCall 方法可以得到一个 Call 对象，既支持同步获取数据，也支持异步，在上面官方例子里，也可以看出来，在异步回调中，当获取到数据，会将 Response 对象传入 Callback 的 onSuccess 方法中，如果请求没有成功，就会调用 onFailure 方法（Response 下面说）。那么看看 Callback 是什么。 先看看官方的 Callback 是什么 ： 1234567public interface Callback &#123; void onFailure(Call call, IOException e); void onResponse(Call call, Response response) throws IOException;&#125; 对，把注释删除了之后，其实就是两个接口，简单的理解成，一个是请求成功时的回调，一个是请求失败时的回调。 那么对这一层的封装思路是这样子的： 一般来说，在上层，我们是需要去处理上面两个回调的，在 onFailure 中，请求失败，应该做什么操作，在 onResponse 中，HTTP 返回的状态码在 [200,300）之间应该有什么操作，在其他区间又应该有什么操作。那么在这里，我们就创建一个类，去实现这个接口，将基本的处理都在这个类里写好，出错误了，就拿到 erroeCode errorMsg 回调给上层，正确的返回信息，就直接回调给上一层。 那么这里就涉及到我们自定义的一个 Exception 和 Listener 以及实现了 Callback 接口的 CommonCallback 类。 OkHttpException 1234567891011121314151617181920212223/** * @author:fanyuzeng * @date: 2017/10/27 13:44 * @desc: */public class OkHttpException extends Exception &#123; private int mErrorCode; private String mErrorMsg; public OkHttpException(int errorCode, String errorMsg) &#123; this.mErrorCode = errorCode; this.mErrorMsg = errorMsg; &#125; public int getErrorCode() &#123; return mErrorCode; &#125; public String getErrorMsg() &#123; return mErrorMsg; &#125;&#125; DisposeDataListener 123456789101112131415161718192021/** * @author:fanyuzeng * @date: 2017/10/27 13:49 * @desc: */public interface DisposeDataListener &#123; /** * 请求服务器数据成功时回调的方法 * * @param responseObj 需要回调到上层的请求结果 */ void onSuccess(Object responseObj); /** * 请求服务器失败时候的回调方法 * * @param exception 需要回调到上层的错误反馈 */ void onFailure(OkHttpException exception);&#125; 再将这个 Listener 用代理设计模式再封装一层 DisposeDataHandler12345678910111213141516171819202122232425262728293031/** * @author:fanyuzeng * @date: 2017/10/27 13:52 * @desc: 代理模式,使用DisposeDataHandler 代理 DisposeDataListener的操作 */public class DisposeDataHandler &#123; public DisposeDataListener mListener; public Class&lt;?&gt; mClass; public DisposeDataHandler(DisposeDataListener listener) &#123; mListener = listener; &#125; public DisposeDataHandler(DisposeDataListener listener, Class&lt;?&gt; aClass) &#123; mListener = listener; mClass = aClass; &#125; public void onSuccess(Object responseObj) &#123; mListener.onSuccess(responseObj); &#125; public void onFailure(OkHttpException exception) &#123; mListener.onFailure(exception); &#125; public Class&lt;?&gt; getClassType() &#123; return mClass; &#125;&#125;此处用代理模式，主要是为了优雅（装X）的处理 Class&lt;?&gt; 这个对象，这是用于映射的类型，在调用 Listener 的回到方法之后做判断这个对象是否存在，是，则再映射在返回，否，直接返回。然后将三面三个类聚合到一起CommonJsonCallback 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @author:fanyuzeng * @date: 2017/10/27 14:41 * @desc: */public class CommonJsonCallback implements Callback &#123; private static final String TAG = \"CommonJsonCallback\"; private static final String MSG_RESULT_EMPTY = \"request could not be ececuted\"; private static final String MSG_JSON_EMPTY = \"json is empty or null\"; private static final String MSG_RETURN_CODE = \"http return code is not [200,300)\"; private static final int NETWORK_ERROR = -1; private static final int JSON_ERROR = -2; private Handler mDeliveryHandler = new Handler(Looper.getMainLooper()); private Gson mGson = new Gson(); private DisposeDataHandler mDisposeDataHandler; public CommonJsonCallback(DisposeDataHandler dataHandler) &#123; mDisposeDataHandler = dataHandler; &#125; @Override public void onFailure(@NonNull Call call, @NonNull final IOException e) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RESULT_EMPTY + e.getMessage())); &#125; &#125;); &#125; @Override public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RETURN_CODE + response.message())); &#125; &#125;); &#125; final String resultJson = response.body().string(); mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; handleResponse(resultJson); &#125; &#125;); &#125; private void handleResponse(String resultJson) &#123; if (TextUtils.isEmpty(resultJson)) &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_JSON_EMPTY)); return; &#125; if (mDisposeDataHandler.getClassType() == null) &#123; mDisposeDataHandler.onSuccess(resultJson); &#125; else &#123; Object mappedDataType = mGson.fromJson(resultJson, mDisposeDataHandler.getClassType()); if (mappedDataType == null) &#123; mDisposeDataHandler.onFailure(new OkHttpException(JSON_ERROR, MSG_JSON_EMPTY)); &#125; else &#123; mDisposeDataHandler.onSuccess(mappedDataType); &#125; &#125; &#125;&#125; 自我感觉用代理之后，处理对象都是 DisposeHandler ，不会在看到 Listener Class&lt;?&gt; ,适应起来方便些了。 要注意一点是，在 onResponse 方法中，还是在子线程中的，要及时切换线程。 到这里，就对 Call 这个对象封装完成了。 ResponseResponse 类封装了响应报文信息：状态吗（200、404 等）、响应头（Content-Type、Server 等）以及可选的响应体。可以通过 Call 对象的 execute() 方法获得 Response 对象，异步回调执行 Callback 对象的 onResponse 方法时也可以获取 Response 对象。 这东西人家已经给我们封装好了， 需要什么直接去拿就行， 也不需要在封装。 OkHttpClient官方文档有这么一句话： OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools. 翻译一下：当你使用一个全局的 OkHttpClient ，并且重用它发起 HTTP 请求的时候，OkHttp 的能够发挥最 NB 的性能，因为每一个客户端都持有它的连接池和线程池，如果这俩东西可以重用的话，那么就能减少潜在的因素，并且节省内存，相反的，如果为每一个客户端的每一个请求都创建一个 OkHttpClient ，那么就会浪费空闲的连接池和线程池中的资源。 叽叽歪歪这么多，就是说用 OkHttpClient 的时候要用单例模式。 刚开始我是这么设计的： CommonokHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author:fanyuzeng * @date: 2017/10/27 15:21 * @desc: */@Deprecatedpublic class CommonOkHttpClient &#123; private static final int TIME_OUT = 30; private static OkHttpClient sOkHttpClient; static &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https sOkHttpClient = builder.build(); &#125; /** * 请求服务器数据的方法 * * @param request Use &#123;@link com.project.fanyuzeng.mvpdemo.utils.okhttp.request.CommonRequest&#125; to build * @param handler see &#123;@link DisposeDataHandler&#125; proxy class */ public static void requestServerData(Request request, DisposeDataHandler handler) &#123; sOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 恩，静态代码块中初始化实例化 OkHttpClient，我认为饿汉模式没有本质的区别， 但是这种方式比饿汗模式的初始化时间更早。 好吧 ，我承认我懒，不想在整个单例类出来。。 这样写，也没什么问题，但是外界在使用的使用，比较麻烦 创建RequestParams，涉及到 HashMap 的好多 put 操作 用 RequestParam 去初始化 CommonRequest 在上层根据请求方式去创建对应的 Request 再实例化一个DisposeHandler 所以只好接着封装吧，分析上面 4 个步骤，其中步骤 1 那是不能再简化了的，因为具体的请求参数肯定是要从外界传进来的，这里涉及到的 HashMap 以及它的 put 操作是不可避免的。步骤 2 和步骤 3 完全是可以封装一下的，步骤 4 也是需要从外外界回调的方法，类似于点击监听的 onClick 方法回调。 所以把 CommonOkHttpClient 给 Deprecated 掉，重新来一个 OkHttpManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author:fanyuzeng * @date: 2017/10/27 17:57 * @desc: */public class OkHttpManager &#123; private static volatile OkHttpManager sManager; private OkHttpClient mOkHttpClient; private OkHttpManager() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https mOkHttpClient = builder.build(); &#125; public static OkHttpManager getInstance() &#123; if (sManager == null) &#123; synchronized (OkHttpManager.class) &#123; if (sManager == null) &#123; sManager = new OkHttpManager(); &#125; &#125; &#125; return sManager; &#125; /** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */ public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125; &#125;&#125; 好吧，还是用双重锁模式的单例比较放心 。 到此就封装完了，下面简单的使用一下。 使用姿势12345678910111213 1 OkHttpManager.getInstance().requestServerData(method, url, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; 2 @Override 3 public void onSuccess(Object responseObj) &#123; 4 String responseJson = (String) responseObj; 5 Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); 6 mPaginationPresenter.accessSuccess(responseJson); 7 &#125; 8 @Override 9 public void onFailure(OkHttpException exception) &#123;10 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode());11 mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url);12 &#125;13 &#125;,null)); 没有将 Json 数据映射成实体类， 所以在 13 行构造 DisposeDataHandler 的时候，第二个 类参数传的是 null。 这个例子是结合上一篇请求分页数据来用的，所以这里直接将 Json 数据抛给 Presenter 层，让它去处理。 第 1 行的 mPaginationPresenter.getParams() 就是拿 url 中的参数。 由于篇幅的限制，这一篇先到这里，下一篇再把这个封装的 OkHttp 工具用于 MVP 模式的 Demo 当中 最后，贴个 AS 中封装之后工具的结构图。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（三）基于分页列表的封装","slug":"MVP3","date":"2017-10-25T12:37:15.000Z","updated":"2017-10-28T10:30:28.153Z","comments":true,"path":"2017/10/25/MVP3/","link":"","permalink":"http://zengfanyu.top/2017/10/25/MVP3/","excerpt":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。","text":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。 presenter 层作为 MVP 模式的桥梁， 那就先从这一层开始说起吧。 Presenter上一篇中对 Presenter 层的公共方法进行了抽取并且封装成了一个接口 IBasePresenter ，那么现在我们需要实现分页加载还有刷新的功能，那么在 IBasePresenter 接口的基础之上，在对其封装一个接口 IBasePeginationPresenter：123456789101112131415161718192021222324252627/** * Created by fanyuzeng on 2017/10/23. * Function:在IBasePresenter的基础上扩展的接口，适用于分页加载的情况 */public interface IBasePaginationPresenter&lt;Param&gt; extends IBasePresenter&lt;Param&gt; &#123;/** * 刷新数据的接口 * * @param param 访问服务器的参数 * @created at 2017/10/23 20:07 */void refresh(Param param);/** * 加载更多的接口 * * @created at 2017/10/23 20:07 */void loadingNext();/** * 用于判断服务器端是否还有更多的数据 * @return true -还有更多数据 - false 没有更多的数据 */boolean hasMoreData();&#125; 也是一个泛型的接口，增加的三个方法 ： refresh(Param param) 在 View 层调用，用于通知 Model 层刷新数据 loadingNext() 在 View 层调用，用于通知 Model 层加载下一页数据 hasMoreData() 在 Model 层请求网络数据前调用做判断，是否还有下一页数据 有了针对分页刷新的接口之后，还需要有一个实现它的基类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePeginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; private static final String TAG = \"BasePaginationPresenter\"; private IBaseModel mBaseModel; private IBaseView mBaseListView; private Param mParam; private Class&lt;Data&gt; mClazz; private Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mHasMoreData=true; /** * 子类中调用，用于传递服务器返回的，处理好的结果 * * @param data View层需要的数据类型 * @created at 2017/10/23 20:10 */ public abstract void serverResponse(Data data); /** * 子类中调用，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); public BasePaginationPresenter(IBaseView baseListView, Class&lt;Data&gt; Clazz) &#123; this.mBaseListView = baseListView; mClazz = Clazz; mBaseModel = new SohuAlbumModel(this); &#125; @Override public void refresh(Param param) &#123; requestServer(param); &#125; @Override public void loadingNext() &#123; if (mParam != null) &#123; int pageIndex = mParam.getPageIndex(); mParam.setPageIndex(pageIndex + 1); requestServer(mParam); &#125; &#125; @Override public void requestServer(@Nullable Param param) &#123; mBaseListView.showProgress(true); mParam = param; Log.d(TAG, \"&gt;&gt; requestServer &gt;&gt; \"); getModel().sendRequestToServer(param); &#125; @Override public void accessSuccess(String responseJson) &#123; mBaseListView.showProgress(false); Gson gson = new Gson(); serverResponse(gson.fromJson(responseJson, mClazz)); mBaseListView.showSuccess(true); &#125; @Override public void cancelRequest() &#123; mBaseModel.cancelRequest(); &#125; @Override public void okHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showOkHttpError(errorCode, errorDesc, errorUrl); mBaseListView.showProgress(false); mBaseListView.showSuccess(false); &#125; &#125;); &#125; @Override public IBaseModel getModel() &#123; return mBaseModel; &#125; @Override public HashMap&lt;String, String&gt; getParams() &#123; return null; &#125; @Override public boolean hasMoreData() &#123; return ServerHaveMoreData(); &#125;&#125; 在类申明时，可以看到 Param extends BasePeginationParam ，这里的 BasePeginationParam主要是封装了摘要中提到的 PageIndex 和 PageSize 两个参数，以及他们的 Getter Seeter 方法。 重点看 IBasePeginationPresenter 中新增加的三个方法，refresh(Param param) 会重新调用一次 requestServer(Param param) （此方法在上一篇也提过了，就是通知 Model 层获取数据）； loadingNext() ，加载下一页数据的方法，就是将参数中的 PageIndex + 1 之后，重新调用 requestServer(Param param) 方法。此处只改变了页码，如果需要改变请求数据的条数，也是相应的在 loadingNext() 中修改 PageSize 的值。 hasMoreData() ,这里返回抽象方法 serverhaveMoreData() ，这个方法是在子类中实现的，子类解析了数据之后，判断服务器是否还有数据返回。 然后有需要实现分页功能的 Presenter 就可以直接继承 BasePaginationPresenter 。 Model 层由于 Model 层的职责比较单一，就是向数据源请求数据，并且返回给 Presenter 层，所以此处不需要额外封装接口或者是基类，只需要重新实现上一篇中提到的 IBaseModel 接口即可。 View 层此处和请求一次数据相比较， View 层就是需要在两个事件触发的时候，重新设置参数通知 Presenter 去请求数据，然后再展示出来。这两个事件分别是：上拉到底时加载更多、下拉时刷新数据（当然可以别的）。 针对上一小节中封装类的具体实现View 层的具体实现主要是展示电视剧的主要信息，那么需要提供一个接口方法，给 Presenter 层调用，展示处理好的 JavaBean：1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 此处的 VideoInfo 是一个JavaBean，对应的就是电视剧信息的实体类。1234567891011121314public class VideoInfo &#123; @SerializedName(\"main_actor\") private String mMainActor; @SerializedName(\"total_video_count\") private int mTotalVideoCount; @SerializedName(\"album_name\") private String mAlbumName; @SerializedName(\"director\") private String mDirector; @SerializedName(\"publish_time\") private String mPublishTime; //Getter and setter methods&#125; 之前映射数据需要保证字段名和 Json 数据的字段名一致，其实本来把这个类的字段名改得一致就行啦，但是服务器端返回的数据字段，很多都是以“_”进行连接，而不是使用驼峰命名法则，这个时候 Gson 的 @SerializedName 注解就派上用场了，注解中用服务器端返回值字段，成员变量仍然使用驼峰命名法。但是上个周末安装了最近 Alibaba 10 月 14 日 推出的 Coding Guidelines 插件，发现代码中很多不规范的地方，并且人家规定了成员变量就必须要使用驼峰命名！所以我决定要按照这个插件的规范来写代码了，虽然现在进不了大厂，但是先熟悉大厂的代码规范也是好事，哈哈~ 咳咳，按照大厂的代码规范，成员变量的命名必须使用驼峰命名法！这个插件是真心好用，比如对类名要 javadoc 注释 参数、返回值、异常说明、此方法做什么事情、实现什么功能（领域模型相关命名除外，比如：DO、BO、DAO），并且是全中文的！直接在 AS 的 Inspection Results 窗口中显示，这 IDE 内置功能啥时候讲过中文反馈结果的？ 《阿里巴巴Java开发规约》插件全球首发！ 广告时间结束，言归正传！ 这个 Activity 实现了 ISohuSerials 接口，布局文件和上一篇一样，只是把 ListView 换成了自定义的 PullLoadRecyclerView 了，这个RecycyclerView 支持上拉加载更多和下拉刷新， 这里不展开说了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author：ZengFanyu */public class SohuAlbumInfoActivity extends AppCompatActivity implements ISohuSerials &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private Context mContext; private ProgressBar mProgressBar; private TextView mTip; private RelativeLayout mContainer; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam= new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mIsFromRefresh = false; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_album_view); mContext = this; mAlbumPresenter = new AlbumPresenter(this, Album.class); mContainer = (RelativeLayout) findViewById(R.id.id_success_content); mTip = (TextView) findViewById(R.id.id_tip); mProgressBar = (ProgressBar) findViewById(R.id.id_progress_bar); mRecyclerView = (PullLoadRecyclerView) findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); //通知Presenter层刷新数据 mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); //通知Presenter层加载下一页数据 &#125; &#125;); &#125; @Override public void showAlbumMainInfo(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;); &#125; &#125; @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"http err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc + \",errUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"server err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContainer.setBackgroundResource(android.R.color.white); mTip.setText(\"Sohu Serials album\"); &#125; else &#123; mContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125;&#125; 在上面代码中可以看到: 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onRefresh() 回调方法中，核心代码就是这一行 mAlbumPresenter.refresh(mParam); ，通知 Presenter 层去刷新数据， 至于 Presenter 层如何刷新。。 关我 View 层 X 事~ 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onLoadMore() 回调方法中,也是直接调用 mAlbumPresenter.loadingNext()。 下面说说 Presenter 层的代码 Presenter 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private ISohuSerials mBaseListView; private Handler mHandler = new Handler(Looper.getMainLooper()); private int mTotalCount; public AlbumPresenter(ISohuSerials baseListView, Class&lt;Album&gt; CLazz) &#123; super(baseListView, CLazz); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL); &#125; @Override public void serverResponse(Album album) &#123; mBaseListView.showAlbumMainInfo(album.getData().getVideos()); mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showProgress(false); &#125; &#125;); mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际使用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); return (pageIndex * pageSize) &lt;= mTotalCount; &#125;&#125; 首先是要继承之前编写的 BasePaginationPresenter类，泛型参数 BasePaginationParam 可以根据实际需求进行拓展，基本使用在前面已经介绍过，此处不做赘述。 Album 是搜狐视频电视剧频道返回数据的实体类，上面提到的 VideoInfo 包含在 Album 里面，因为现在只需要展示 VideoInfo 里的信息， 所以在 serverRespomse 方法里，有一个转换 mBaseListView.showAlbumMainInfo(album.getData().getVideos()); 实现父类 BasePaginationPresenter 中的抽象方法 serverHaveMoreData() ,思路就是 当前页面数 * 每一页的数据量，然后和 数据总量 比较大小。 Model 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 1 /** 2 * @author：ZengFanyu 3 */ 4 public class SohuAlbumModel&lt;Param extends BasePaginationParam&gt; implements IBaseModel&lt;Param&gt; &#123; 5 private static final String TAG = \"SohuAlbumModel\"; 6 private String url; 7 private int method; 8 private IBasePaginationPresenter mPaginationPresenter; 9 10 public SohuAlbumModel(IBasePaginationPresenter paginationPresenter) &#123;11 mPaginationPresenter = paginationPresenter;12 &#125;13 14 @Override15 public void sendRequestToServer(Param param) &#123;16 String validUrl = null;17 if (param != null &amp;&amp; !TextUtils.isEmpty(url)&amp;&amp;mPaginationPresenter.hasMoreData()) &#123;18 validUrl = getValidUrl(url, param);19 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl);20 &#125;21 Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"check param,url and server have data or not!\")22 if (!TextUtils.isEmpty(validUrl)) &#123;23 HttpUtils.executeByGet(validUrl, new Callback() &#123;24 @Override25 public void onFailure(Call call, IOException e) &#123;26 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \");27 e.printStackTrace();28 mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url);29 &#125;30 31 @Override32 public void onResponse(Call call, Response response) throws IOException &#123;33 if (!response.isSuccessful()) &#123;34 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\");35 mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url);36 &#125;37 38 String responseJson = response.body().string();39 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson);40 mPaginationPresenter.accessSuccess(responseJson);41 42 &#125;43 &#125;);44 &#125; else &#123;45 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\");46 &#125;47 &#125;48 49 private String getValidUrl(String url, Param param) &#123;50 return String.format(url, param.getPageIndex(), param.getPageSize());51 &#125;52 53 54 @Override55 public void setRequestUrl(String url) &#123;56 this.url = url;57 &#125;58 59 @Override60 public void setRequestMethod(int method) &#123;61 this.method = method;62 &#125;63 64 @Override65 public void cancelRequest() &#123;66 HttpUtils.cancelCall();67 &#125;68 &#125; Model 层的实现还是跟之前的一样，直接实现 IBaseModel 接口即可。 在 17 行可以看到，mPaginationPresenter.hasMoreData() ，这个就是对服务器点是否还有数据可以返回的判断，如果这里返回 false 那么就不回去进行网络请求,然后在 22 行打印个 Log 提醒。 在看看 49 行的 getVaildUrl 方法，这个方法主要就是把传进来的 param 参数拼接进 url 中，形成有效的，可以请求到数据的 Url。 效果图 Item 就展示了一下电视剧的 主演、名字、导演、集数、更新时间的信息。 小结通过上面的封装和例子，起码证明了这一套封装能够跑的通了，以后如果还有关于分页请求的需求，可以直接继承上面的基类来实现，无非就是修改param 和 Data 两个泛型的参数。 前者是请求 url 的参数，根据具体的业务需求，封装 BasePaginationParam 的子类即可。 后者是服务器端返回数据的实体类，也是根据数据的结构来封装的，在 Android Studio 中有 Gson Formatter 这个插件，封装 JavaBean 插件也轻松很多，在结合上面提到的 Gson 注解，全套了。 下一篇准备封装一下 OkHttp ,然后将封装之后的 OkHttp 整合到当前框架中,当然了,还是以分页接在为例","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android 当中的 MVP 模式（二）封装","slug":"MVP2","date":"2017-10-22T14:00:15.000Z","updated":"2017-10-28T10:38:12.190Z","comments":true,"path":"2017/10/22/MVP2/","link":"","permalink":"http://zengfanyu.top/2017/10/22/MVP2/","excerpt":"摘要：在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。","text":"摘要：在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。 一个简单的网络请求 一个简单的需求：通过 url 获取数据，然后用 Gson 解析成 JavaBean，然后展示到 ListView上。这里使用知乎日报的获取最新消息的 API 接口 https://news-at.zhihu.com/api/4/news/latest 那么按照普通 MVP 的思路，首先 view 层： 为了突出重点，当前View层只做一件事情：就是展示获取的数据 ILatestVIew 此接口需要一个 String 类型的列表数据，主要是用于给 Adapter 展示用。 LatestViewActivity 很简答，就是实现接口。 IRequestLatestModel 请求服务器端数据的接口 RequestLatestNewsModel 使用 okhttp 请求数据，然后将返回的json类型数据传递给 Presenter 层。 ILatestNewsPresenter 一个接口用于处理 Json 数据，一个接口用于通知 model 层向服务器发起请求 。 LatestNewsPresenter 实现接口定义的方法 其中 HttpUtils 方法如下： 此处 OKhttp 也可以进行封装， 后面再写一篇文章， 专门记录，先暂时简单的使用。 运行之后，点击 button， 即可发起网络请求，运行效果如下： 弊端： 假设我们现在又有另外的一个需求， 请求知乎日报过往的消息， 对应的 API 接口为URL: https://news-at.zhihu.com/api/4/news/before/20131119,那么我就需要按照上述的方式，又写一套MVP的代码，最少又得留个类，如此一来，随着需求的增多，代码量会极具增大，但是多余增加的每层代码所做的事情又大多数相同，只是具体细节不一样，那么我们可不可以把每一层要做的事情给抽取出来，封装成基类，然后让子类去继承，去实现，这样就可以大量减少代码量？ 抱着这个问题，我就来分析一下 MVP 每一层所做的事情。 以简单网络请求为例，分析 MVP 各层的职责以上面请求知乎日报的最新消息为例，分析每一层的职责。 Model 层Model 角色主要是提供数据的存取功，并且将数据或者是错误信息回调给 Presenter 层。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。所以它主要的功能是： 1. 向数据源发起请求 2. 取消发起的请求 3. 通知 Presenter 处理结果 Presenter 层一般是通知 Model 向服务器发起请求，然后接收 Model 层的请求结果，包括成功的数据和错误的信息，同时也负责将处理之后的数据或者是错误信息通知 View 层，由 View 层作展示。所以他的主要功能是： 1. 通知 Model 层向服务器发起数据请求 2. 通知 Model 层取消这次请求 3. 接收 Model 层返回的数据 4. 接收 Model 层返回的错误信息 5. 通知 View 层接收处理之后的结果或者是错误信息 View 层此处 View 层的作用就比较专一化，只用于处理 UI 相关的事情，不再负责业务逻辑。主要职责如下： 1. Loading 状态的展示隐藏 2. 接收 Presenter 层处理后的数据 3. 接收 Presenter 层处理后的错误信息 4. 接收 Presenter 层处理后的服务器拒绝信息 嗯，差不多就是这么多吧 既然将每一层的主要职责总结了出来， 很明显就可以将这些职责「在代码中就是对应的方法」抽象成方法，然后让子类去个性化的实现。 抽取共性封装网络请求Model 层IBaseModel 其中 setMethod 和 setRequestUrl 方法直接在 Presenter 的构造方法中调用，设置好请求的方式和请求的 Url 地址，这样方便 model 层在请求服务器数据时，使用对应的参数，使用对应的请求方式。 此处没有用到 method 是因为知乎日报的最新新闻 API 接口是 Get 方式，不需要参数，所以此处没有根据请求方式来调用不同的请求方法 Presenter 层IBasePresenter Presenter 层是逻辑控制层，是 Model 层和 View 层的桥梁，对这一层抽取共性进行封装的时候，不能像 Model 层一样，把全部的功能装好好，原因如下： 1.如果将其全部封装起来，是没办法复用同一个功能模块的，并且会导致部分业务逻辑需要在 view 层中做处理，这样和 MVP 的思想相悖。 2.Presenter 层需要处理和 View 层的交互逻辑以及 Model 层返回的数据。 但是 Model 层是可以的，我是认为，Model 层就是从数据源中拿数据，并且将数据传递给 Presenter 层，所有的 Model 层做的都是这个操作，只是访问数据源的参数不同，数据源类型不同，访问数据源的方法不同而已，所以很明显可以全部抽取出来放基类中，然后各个子类去各自实现。 1. requestServer 在View层调用的接口，用于通知Model层想服务器发起请求，参数可为空，比如，有些Get方式的请求就不需要参数 2. requestSuccess 在Model层调用，通过此方法将服务器返回的数据传递给给Presenter层处理 3. cancelRequest 在View层调用，用于通知Model层取消请求 4. okHttpError 在Model层调用，当网络请求产生错误的时候 5. getModel 在子类中调用，用于拿到Model对象 6. getParams 在Model层中调用，此方法用于获取Presenter层处理好的参数 BasePresenter public abstract class BasePresenter&lt;Params, Data&gt; implements IBasePresenter&lt;Params&gt;这是一个泛型的抽象类，其中泛型Params是用于model层向服务器发起请求的请求参数，Data是服务器返回的Json类对应的JavaBean类。 BasePresenter处理了View层和model层中大多数的逻辑，我们要做的就是在子类中实现public abstract void serverResponse(Data data);这个抽象方法就好了。 public abstract void serverResponse(Data data);这个方法是在用于处理model层返回的结果，然后进行处理之后回调给view层。 可以看到46、47、50、51、52行的代码给注释掉了，其实一般情况下这里是不需要注释的，这里是用于判断返回数据的errorNum errorType errorDesc信息的，这么操作，是为了实现如下功能：若返回的信息有误，则BasePresenter直接回调给View层，如果正确，才会传递给子类。 上述最后一条，需要对泛型Data在进行一次封装，并且使用上 Gson 的@SerializedName(value = &quot;...&quot;,alternate = {&quot;...&quot;,&quot;...&quot;,&quot;...&quot;})这个注解，并且这里涉及到泛型擦除的问题，这一块我还没有很好的解决办法，所以此处没有进行封装。 View 层还是按照上面分析的 View 层职责来写： IBaseView 到此为止，对 MVP 模式的每一层都写出了对应的基类，有了这件基类作为基础之后，在进行同样的网络请求。 使用上述封装好的类进行相同的网络请求LatestNewsModel LatestNewsPresenter 其中Param泛型参数填的是nullable是因为这个请求是get方式，没有涉及到参数。LatestNews作为Data的泛型，主要是用于BasePresenter解析并映射。 ILatestNewsView IlatestNewsVIew接口是继承IBaseView接口的，是因为它需要在IBaseView接口所定义的功能之上，还需要实现将数据展示到列表中这么一个操作，所以添加上了一个showLatestViewTitle方法。 LatestNewsTitleActivity 这个类写起来就简单了，跟着接口来， 把之前每一个接口提到的功能给实现以下就可以了。 顺便贴个 XML 文件： 搞定，实现的效果和上面是一样的。 回过头一看，MMP，这代码量似乎也没有少很多啊，-。- ，没事没事，需求多了就少了~ 小结先看看上一篇中提到的一张图此处将MVP模式封装后，MVP的流程图如下： 后面的文章将使用上面封装的框架，通过扩展 BasePresenter 来增加新的模块。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（一）基本概念","slug":"MVP1","date":"2017-10-20T12:37:15.000Z","updated":"2017-10-28T10:45:23.740Z","comments":true,"path":"2017/10/20/MVP1/","link":"","permalink":"http://zengfanyu.top/2017/10/20/MVP1/","excerpt":"摘要：Github上看到很多项目，都是 MVP+RxJava+Retrofit+Dragger2 这种架构，再加上一个 OkHttp， 虽说这几个东西，我都或多或少听过，用过，但是从来没有认真的研究过，没有把他们整合起来开发一个应用。从 MVP 开始，认真学习这几个框架，然后整合起来，做一个应用。先立一个 FLAG！","text":"摘要：Github上看到很多项目，都是 MVP+RxJava+Retrofit+Dragger2 这种架构，再加上一个 OkHttp， 虽说这几个东西，我都或多或少听过，用过，但是从来没有认真的研究过，没有把他们整合起来开发一个应用。从 MVP 开始，认真学习这几个框架，然后整合起来，做一个应用。先立一个 FLAG！ 为什么要使用MVP在传统的Android开发中，我们一般是使用MVC模式进行开发的。 传统MVC模式介绍： View: 视图层，对应xml文件 Controller: 控制层，对应Activity和Fragment层，进行数据处理 Model：实体层，负责获取实体数据 采用MVC模式的一个最大的弊端就是xml作为View层视图能力实在太弱，所以一般情况下我们都是通过Controller层来辅助处理一些视图的。这样的结果就导致Controller既作为控制层的同时又承担了View层的大部分功能，采用MVC模式往往会导致Activity和Fragment中的代码非常复杂。我们将Android中采用的MVC模式称为MV模式更加恰当。 MVP模式介绍： View: 视图层，对应xml文件与Activity/Fragment Presenter: 逻辑控制层，同时持有View和Model对象 Model: 实体层，负责获取实体数据 MVP模式的流程图如下： 采用MVP模式的优势是： 把业务逻辑抽离到Presenter层中，View层专注于UI的处理。 分离视图逻辑与业务逻辑，达到解耦的目的。 提高代码的阅读性。 Presenter被抽象成接口，可以根据Presenter的实现方式进行单元测试。可拓展性强。 采用MVP模式的缺点： 项目结构会对后期的开发和维护有一定的影响。具体视APP的体量而定。 代码量会增多，如何避免编写过多功能相似的重复代码是使用MVP开发的一个重点要处理的问题。 有一定的学习成本。综上所述，在Android上采用MVP模式的优势是：大大优化代码的维护性与拓展性的同时对代码进行深度解耦，使各个层级的分工更加明晰。 一个简单的应用模拟Android中登陆的功能 界面 项目结构 从上图中可以看到，一个简单的基于 MVP 的项目，最少也需要创建 6 个文件夹，分别是 M、V、P 的接口和它们各自的实现类，其中 LoginActivity 就是 View 层的具体实现，它只需要负责处理 UI 的逻辑，而业务相关的逻辑都抽象到 LoginPresenter 中，这样就避免了传统开发中 Activity 、Fragment 既处理 UI 又负责业务逻辑的情况。 代码实现ILoginView： view层只负责和 UI 相关的操作，那么在这个小 Demo 中，和 UI 相关的操作有如下几点： 1. 从EditText中拿到用户输入的userName 2. 从EditText中拿到用户输入的password 3. 在登录过程中需要展示一个progressbar，登录过程结束之后隐藏这个progressbar 4. 展示登录成功后的view 5. 展示登录失败后的view 综上五个操作，所以有了ILoginView中的五个接口 LoginActivity： 当点击登录按钮时，会将请求服务器合适账号密码这个过程交给presenter层去处理，所以在LoginActivity里，会有preserent的引用。 ILoginPersenter： presenter层处理业务逻辑，有如下几点: 1. 负责接收model的返回结果并且处理 2. 将处理的结果以特定的形式，传递给view层，让view层去展示 3. 通知model层去向数据源请求数据 LoginPresenter： 因为presenter层相当于一个中间交互人，所以它必须要持有对 view 、model 层对象的引用。 ILoginModel： model负责数据的存取： 在这个Demo中，数据的存取使用一个线程和简单的字符串判断来模拟。 LoginModel： 因为model层需要将获取的数据传递给presenter层去做处理，所以此处也需要持有对presenter层的引用。 这样一来就成功的将简单的登录案例，由MVP模式来实现了, 在 LoginActivity 中处理的都是和 UI 相关的， 在 LoginPresenter 中处理的是业务的逻辑， 在 LoginModel 中处理的是网络数据获取。 小结 Presenter—交互中间人 主要作为沟通 View 和 Model 的桥梁，它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务从 View 角色上抽离出来。 View—用户界面 View 通常是指Activity、Fragment或者某个 View 控件，它含有一个 Presenter 成员变量。通常 View 需要实现一个逻辑接口，将 View 上的操作转换给 Presenter 进行实现，最后，Presenter 调用 View 逻辑接口将结果返回给 View 元素。 Model—数据的存取 对于一个结构化的 APP 来说，Model角色主要是提供数据的存取功能。Presenter 需要通过 Model 层存储、获取数据，Model就想一个数据仓库。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。 MVP 并不是一个标准化的模式，它有很多种实现方式，也可以根据自己的需求去修正MVP的实现方式，可以随着 Presenter 的复杂程度而变化，只要保证是通过 Presenter 将 View 和 Model 解耦，降低类型复杂度，各个模块单元可以独立测试、独立变化，这就是正确的方向。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-14T15:40:28.953Z","updated":"2017-10-21T16:06:55.127Z","comments":true,"path":"2017/10/14/hello-world/","link":"","permalink":"http://zengfanyu.top/2017/10/14/hello-world/","excerpt":"","text":"To be a better man1Hello , 个人博客搭好了，老规矩，先来个 Hello World！，然后，撸起袖子就是干！","categories":[],"tags":[]}]}