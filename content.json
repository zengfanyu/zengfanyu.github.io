{"meta":{"title":"CODE FRAMER BIGZ","subtitle":"Every little makes a mickel","description":null,"author":"BIGZ","url":"http://zengfanyu.top"},"pages":[{"title":"分类","date":"2017-10-25T14:59:18.000Z","updated":"2017-10-25T15:05:10.156Z","comments":false,"path":"categories/index.html","permalink":"http://zengfanyu.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:58:45.000Z","updated":"2017-10-25T15:05:14.395Z","comments":false,"path":"tags/index.html","permalink":"http://zengfanyu.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WebSocket、Socket、SocketIO、HTTP的关系","slug":"WebSocket_Socket_HTTP_SocketIO","date":"2018-02-03T02:16:16.000Z","updated":"2018-02-03T02:52:32.992Z","comments":true,"path":"2018/02/03/WebSocket_Socket_HTTP_SocketIO/","link":"","permalink":"http://zengfanyu.top/2018/02/03/WebSocket_Socket_HTTP_SocketIO/","excerpt":"","text":"摘要：最近部门在做一个基于 WebRTC 的视频会议系统，其中 Android 端代码需要连接三个服务器，分别是 RoomServer、MessageServer、MediaServer。 其中 RoomServer 用于处理 client 请求（创建房间、发布视频等），并且将 MediaServer 的最新消息通过 MessageServer 推送至 client。 client 和 RoomServer 之间使用 http 连接实现；既然 client 需要接受 MessageServer 的消息推送，那么用 HTTP 明显是不能完成的，所以 client 到 MessageServer 之间使用了 WebSocket，用于保持长连接，这样 client 和 MessageServer 都可以主动发送消息； client 和 MediaServer 之间使用了 SocketIO，这样信令通道也是全双工的工作类型。 其中涉及到的 HTTP、WebSocket、SocketIO 的，一顿 google 之后，搞清楚了三者之间的关系，这里记录做下记录。 要搞清楚的问题说到底，这篇博文就是要搞清楚以下的问题，从宏观上了解，不深究细节部分。 socket 是觉得了什么问题？ WebSocket 为什么被引入？ 又解决了什么问题？ Socket 和 WebSocket 有哪些区别和联系？ WebSocket 和 HTML5 是什么关系？ 必须在浏览器中才能使用 WebSocket 吗？ WebSocket 能和 Socket 一样传输 raw 数据么？ WebSocket 和 HTTP 什么关系？有什么区别？ Socket.IO 是什么？ Socket.IO 与 WebSocket 之间是什么关系？ OSI模型与TCP/IP以下是 维基百科 中关于OSI 模型的说明： 开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，ISO/IEC 7498-1），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。 而 TCP/IP 协议可以看做是对 OSI 模型的一种简化（以下内容来自 维基百科）： 它将软件通信过程抽象化为四个抽象层，采取协议堆叠的方式，分别实作出不同通信协议。协议套组下的各种协议，依其功能不同，被分别归属到这四个阶层之中7，常被视为是简化的七层OSI模型。 这里有一张图详细介绍了 TCP/IP 协议族中的各个协议在 OSI模型 中的分布，一图胜千言（下图来自 科来）： HTTP 、WebSocket 等协议运行在应用层，TCP 协议运行在传输层，IP 协议运行在网络层。 WebSocket 与 HTTP从上图可以看出，HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的。我们可以把这些高级协议理解成对 TCP 的封装。 既然大家都使用 TCP 协议，那么大家的连接和断开，都要遵循 TCP 协议中的三次握手和四次挥手 ，只是在连接之后发送的内容不同，或者是断开的时间不同。 对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。 至于具体的这里就不展开了，可以参考： WebSocket详解（四）：刨根问底HTTP与WebSocket的关系(上篇) WebSocket详解（五）：刨根问底HTTP与WebSocket的关系(下篇) 为什么引入WebSocket协议从整个计算机网络的层面面知道了 WebSocket 的定位之后，接下来的问题就是：已经有了 HTTP 协议，为什么还需要 WebSocket 协议？ 现在提到 WebSocket，首先会想到 “及时通讯” 和 “推送” 这类词。在 WebSocket 以前，很多网站通过其他方式来推送信息，下面我们先看看以前的推送方式，这样，有比较才能看出 WebSocket 的优势以及为什么引入WebSocket协议。 (短)轮询（Polling） 这种方式下，client 每隔一段时间都会向 server 发送 http 请求，服务器收到请求后，将最新的数据发回给 client。一开始必须通过提交表单的形式，这样的后果就是传输很多冗余的数据，浪费了带宽。后来 Ajax 出现，减少了传输数据量。 如图所示，在 client 向 server 发送一个请求活动结束后，server 中的数据发生了改变，所以 client 向 server 发送的第二次请求中，server 会将最新的数据返回给 client。 但这种方式也存在弊端。比如在某个时间段 server 没有更新数据，但 client 仍然每隔一段时间发送请求来询问，所以这段时间内的询问都是无效的，这样浪费了网络带宽。将发送请求的间隔时间加大会缓解这种浪费，但如果 server 更新数据很快时，这样又不能满足数据的实时性。 Comet鉴于（短）轮询的弊端，一种基于 HTTP 长连接的 “服务器推” 的技术被 hack 了出来，这种技术被命名为 Comet。其与（短）轮询主要区别就是，在轮询方式下，要想取得数据，必须首先发送请求，在实时性要求较高的情况下，只能增加向 server 请求的频率；而 Comet 则不同，client 与 server 端保持一个长连接，只有数据发生改变时，server 才主动将数据推送给 client。Comet 又可以被细分为两种实现方式，一种是长轮询机制，一种是流技术。 长轮询（Long-polling） client 向 server 发出请求，server 接收到请求后，server 并不一定立即发送回应给 client，而是看数据是否更新，如果数据已经更新了的话，那就立即将数据返回给 client；但如果数据没有更新，那就把这个请求保持住，等待有新的数据到来时，才将数据返回给 client。 当然了，如果 server 的数据长时间没有更新，一段时间后，请求便会超时，client 收到超时信息后，再立即发送一个新的请求给 server。 如图所示，在长轮询机制下，client 向 server 发送了请求后，server会等数据更新完才会将数据返回，而不是像（短）轮询一样不管数据有没有更新然后立即返回。 这种方式也有弊端。当 server 向 client 发送数据后，必须等待下一次请求才能将新的数据发送出去，这样 client 接收到新数据的间隔最短时间便是 2 * RTT（往返时间），这样便无法应对 server 端数据更新频率较快的情况。 流技术（Http Streaming） 流技术基于 Iframe。Iframe 是 HTML 标记，这个标记的 src 属性会保持对指定 server 的长连接请求，server 就可以不断地向 client 返回数据。 可以看出，流技术与长轮询的区别是长轮询本质上还是一种轮询方式，只不过连接的时间有所增加，想要向 server 获取新的数据，client 只能一遍遍的发送请求；而流技术是一直保持连接，不需要 client 请求，当数据发生改变时，server 自动的将数据发送给 client。 如图所示，client 与 server 建立连接之后，便不会断开。当数据发生变化，server 便将数据发送给 client。 但这种方式有一个明显的不足之处，网页会一直显示未加载完成的状态。 WebSocket前人推出那么多的解决方案，想要解决的唯一的问题便是怎么让 server 将最新的数据以最快的速度发送给 client。 但 HTTP 是个懒惰的协议，server 只有收到请求才会做出回应，否则什么事都不干。因此，为了彻底解决这个 server 主动向 client 发送数据的问题，W3C 在 HTML5 中提供了一种 client 与 server 间进行全双工通讯的网络技术 WebSocket。WebSocket 是一个全新的、独立的协议，基于 TCP 协议，与 HTTP 协议兼容却不会融入 HTTP 协议，仅仅作为 HTML5 的一部分。 那 WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 相比于传统 HTTP 的每次“请求-应答”都要 client 与 server 建立连接的模式，WebSocket 是一种长连接的模式。具体什么意思呢？就是一旦 WebSocket 连接建立后，除非 client 或者 server 中有一端主动断开连接，否则每次数据传输之前都不需要 HTTP 那样请求数据。从上面的图可以看出，client 第一次需要与 server 建立连接，当 server 确认连接之后，两者便一直处于连接状态。直到一方断开连接，WebSocket 连接才断开。 从报文层面来说，如下： 首先，client 发起 WebSocket 连接，报文类似于 HTTP，但主要有几点不一样的地方： “Upgrade: websocket”： 表明这是一个 WebSocket 类型请求，意在告诉 server 需要将通信协议切换到 WebSocket “Sec-WebSocket-Key: *”: 是 client 发送的一个 base64 编码的密文，要求 server 必须返回一个对应加密的 “Sec-WebSocket-Accept” 应答，否则 client 会抛出 “Error during WebSocket handshake” 错误，并关闭连接 server 收到报文后，如果支持 WebSocket 协议，那么就会将自己的通信协议切换到 WebSocket，返回以下信息： “HTTP/1.1 101 WebSocket Protocol Handshake”：返回的状态码为 101，表示同意 client 的协议转换请求 “Upgrade: websocket” “Connection: Upgrade” “Sec-WebSocket-Accept: *” … 客户端请求响应报文：（引用自即时通讯网） 以上都是利用 HTTP 协议完成的。这样，经过“请求-响应”的过程， server 与 client 的 WebSocket 连接握手成功，后续便可以进行 TCP 通讯了，也就没有 HTTP 什么事了。可以查阅WebSocket 协议栈了解 WebSocket 的 client 与 server 更详细的交互数据格式。 什么是 Socket网络应用中，两个应用程序同时需要向对方发送消息的能力（即全双工通信），所利用到的技术就是 socket，其能够提供端对端的通信。 对于程序员而言，其需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP 连接，从而可以进行双向通信。 Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。 最早的一套 Socket API 是 Berkeley sockets ，采用 C 语言实现。它是 Socket 的事实标准，POSIX sockets 是基于它构建的，多种编程语言都遵循这套 API，在 JAVA、Python 中都能看到这套 API 的影子。 下面摘录一段更容易理解的文字： Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。 而 WebSocket 则不同，它是一个完整的 应用层协议，包含一套标准的 API 。 所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。 WebSocket 与 SocketWebSocekt 是 HTML5 规范中的一部分，其借鉴了 socket 的思想，为 client 和 server 之间提供了类似 Socket 的双向通信机制。同时，WebSocket 又是一种新的应用层协议，包含一套标准的 API；而 socket 并不是一个协议，而是一组接口，其主要方便大家直接使用更底层的协议（比如 TCP 或 UDP），所以，从使用上来说，WebSocket 更易用，而 Socket 更灵活。 HTML5 与 WebSocketWebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。 实际上，许多语言、框架和服务器都提供了 WebSocket 支持，例如： 基于 C 的 libwebsocket.org 基于 Node.js 的 Socket.io 基于 Python 的 ws4py 基于 C++ 的 WebSocket++ Apache 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel Nginx 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying lighttpd 对 WebSocket 的支持：mod_websocket 什么是 Socket.IOSocket.IO 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node。其屏蔽了所有底层细节，你不用关心里面用了什么连接方式,让顶层调用非常简单。 另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。 好了，基本搞清楚 WebSocket、Socket、HTTP、SocketIO 的概念以及之间的关系了。","categories":[{"name":"计算机网络基础拾遗","slug":"计算机网络基础拾遗","permalink":"http://zengfanyu.top/categories/计算机网络基础拾遗/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://zengfanyu.top/tags/HTTP/"}]},{"title":"SQLite IllegalStateException 的隐蔽 bug 修复","slug":"SQLiteException","date":"2018-01-20T06:16:16.000Z","updated":"2018-01-20T06:50:45.159Z","comments":true,"path":"2018/01/20/SQLiteException/","link":"","permalink":"http://zengfanyu.top/2018/01/20/SQLiteException/","excerpt":"摘要：java.lang.IllegalStateException: Couldn’t read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it.","text":"摘要：java.lang.IllegalStateException: Couldn’t read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it. 发生场景：查询数据库 报错日志如下： 12345678910111213141516171819202122232425262728293031323334353637java.lang.RuntimeException: An error occurred while executing doInBackground() at android.os.AsyncTask$3.done(AsyncTask.java:325) at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:354) at java.util.concurrent.FutureTask.setException(FutureTask.java:223) at java.util.concurrent.FutureTask.run(FutureTask.java:242) at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:243) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761)Caused by: java.lang.IllegalStateException: Couldn't read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it. at android.database.CursorWindow.nativeGetLong(Native Method) at android.database.CursorWindow.getLong(CursorWindow.java:511) at android.database.CursorWindow.getInt(CursorWindow.java:578) at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:69) at com.pplive.media.upload.db.UploadDataBaseManager.searchAllUploads(UploadDataBaseManager.java:146) at com.pplive.media.upload.UploadManager.searchAllUploads(UploadManager.java:400) at com.suning.mobile.ebuy.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1201) at com.suning.mobile.ebuy.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1196) at android.os.AsyncTask$2.call(AsyncTask.java:305) at java.util.concurrent.FutureTask.run(FutureTask.java:237) ... 4 morejava.lang.IllegalStateException: Couldn't read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it. at android.database.CursorWindow.nativeGetLong(Native Method) at android.database.CursorWindow.getLong(CursorWindow.java:511) at android.database.CursorWindow.getInt(CursorWindow.java:578) at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:69) at com.pplive.media.upload.db.UploadDataBaseManager.searchAllUploads(UploadDataBaseManager.java:146) at com.pplive.media.upload.UploadManager.searchAllUploads(UploadManager.java:400) at com.xxxx.zzzz.cccc.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1201) at com.xxxx.zzzz.cccc.uvideo.MainActivity$GetReLunchDataTask.doInBackground(MainActivity.java:1196) at android.os.AsyncTask$2.call(AsyncTask.java:305) at java.util.concurrent.FutureTask.run(FutureTask.java:237) at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:243) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607) at java.lang.Thread.run(Thread.java:761) 最开始一看这个日志「Couldn’t read row 0, col -1 from CursorWindow. Make sure the Cursor is initialized correctly before accessing data from it」，应该是 SQLite 查询的时候字段写错了吧，因为这个情况之前也遇到过，所以 google 验证一下，确实很多都是因为字段写错了。于是我返回代码中去查看字段。 很遗憾的是，数据库相关字段我都是用 public static final String XXXX 的形式来定义，并且在创建数据库和查询表的时候，都是使用的 XXXX ，那么照理来说是不会出现建表和查询时，填错大小写或者多一个空格少一个空格的情况，那么这种情况被 pass。 接着又去检查 SQL 语句，因为之前会碰到一个 SQL 语句当中插入一个值，而没有用空格，导致的 SQL 语句不正确的情况，例如：”select from”+TABLENAME ,这样就不对，应该是：”select from “+TABLENAME，但是如果是 SQL 语句的问题，那么不应该是报这个错误呀，应该会报 SQL 语句相关的错误才对，于是这个情况也被 pass。 于是接着从日志当中的 -1 入手，cursor 的 getColumnIndex() 方法注解是这样的： 123456789101112/** * Returns the zero-based index for the given column name, or -1 if the column doesn't exist. * If you expect the column to exist use &#123;@link #getColumnIndexOrThrow(String)&#125; instead, which * will make the error more clear. * * @param columnName the name of the target column. * @return the zero-based column index for the given column name, or -1 if * the column name does not exist. * @see #getColumnIndexOrThrow(String) */int getColumnIndex(String columnName); 这么说，当前列如果不存在的话，那么这个方法的返回值是 -1 ，那么上面的报错日志就合理啦，于是我在查询之前打印了一下当前数据库的情况： 12UploadInfo&#123;status=0, ppfeature='null', fid='null', categoryId=0, state=0, size='null', name='null', localPath='null', id=6, progress=0, token='null', isPause=false, channel_web_id='null', pic_upload_url='null', startTime=1516106247809, length=0, channelId=0, userId=0, maxSpeed=0, minSpeed=0, fileState=0, isStop=false&#125; 对的，没问题，我要查询的那一列是存在的，并且这里的字段和建表语句是符合的。要查询的那一列不存在这种情况也被 pass。 到了这里，我感觉我已经把可能出现问题的地方都检查过了，但是还有一个地方，日志当中有这么一句： at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:69) 是不是 getInt 的问题？？ 看看源码注释： 12345678910111213/** * Returns the value of the requested column as an int. * * &lt;p&gt;The result and whether this method throws an exception when the * column value is null, the column type is not an integral type, or the * integer value is outside the range [&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;] is implementation-defined. * * @param columnIndex the zero-based index of the target column. * @return the value of that column as an int. */int getInt(int columnIndex); 「当结果为默认值」，「列值为空」，「不是 integer 类型」， 「integer 类型超出范围」，这几种情况下，该方法会不会引起异常，是由现实情况决定的。 现实情况决定的？？那就是可以理解成，跟设备相关咯（这个想法后来被证实是正确的，确实跟设备型号相关，上述异常在部分设备上不会抛出）。 那么这个注释的意思就是说：上述四种情况，我们去获取它，那么结果在不同的设备上不一样，有的设备上是可以正常获取到 SQLite 中定义的初始值的，有的就会直接抛异常。 以上几种情况，根据项目代码的一些限定和过滤以及之前的单元测试（业务相关），只有「当结果为默认值」这种情况可能会发生，也就是程序只创建了数据库和数据表，但是还没有往里面插入数据，就查询数据，那么这时数据表中的字段就应该是默认值。 怎么解决？ 既然出问题的是默认值，那么我就在应该返回默认值的时候，手动去赋一个默认值。 保证每次调用 cursor 的 getXXX 方法时，都需要检查返回值是否为空。用下面的代码去替代系统 cursor 的 getXXX 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private long getLong(Cursor cursor, String indexName) &#123; long value = 0; int columnIndex = -1; try &#123; columnIndex = cursor.getColumnIndex(indexName); if (!cursor.isNull(columnIndex)) &#123; value = cursor.getLong(columnIndex); &#125; &#125; catch (Throwable tr) &#123; LogUtils.error(\"columnIndex:\" + columnIndex + \"e:\" + tr.getMessage()); &#125; return value;&#125;private int getInt(Cursor cursor, String indexName) &#123; int value = 0; int columnIndex = -1; try &#123; columnIndex = cursor.getColumnIndex(indexName); if (!cursor.isNull(columnIndex)) &#123; value = cursor.getInt(columnIndex); &#125; &#125; catch (Throwable tr) &#123; LogUtils.error(\"columnIndex:\" + columnIndex + \"e:\" + tr.getMessage()); &#125; return value;&#125;private String getString(Cursor cursor, String indexName) &#123; String value = null; int columnIndex = -1; try &#123; columnIndex = cursor.getColumnIndex(indexName); if (!cursor.isNull(columnIndex)) &#123; value = cursor.getString(columnIndex); &#125; &#125; catch (Throwable tr) &#123; LogUtils.error(\"columnIndex:\" + columnIndex + \"e:\" + tr.getMessage()); &#125; return value;&#125; 使用后，异常完美解决。 还有一种思路没有实践： 既然是默认值的问题，那么在 SQLiteOpenHelper 的 onCreate 方法中建表的时候，就将默认值写死就好啦，就是在每一个字段的建表语句后加上一个 DEFAULT ，比如： 123456789101112131415161718@Overridepublic void onCreate(SQLiteDatabase db) &#123; db.execSQL(String.format( \"CREATE TABLE %s (%s INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, \" // BaseColumns._ID + \"%s TEXT DEFAULT null, \" // FIELD_LOCAL_PATH + \"%s TEXT DEFAULT null, \" // FIELD_NAME + \"%s TEXT DEFAULT null, \" // FIELD_TOKEN + \"%s TEXT DEFAULT null, \" // FIELD_SIZE + \"%s INTEGER DEFAULT 0, \" // FIELD_STATE + \"%s TEXT DEFAULT null, \" // FIELD_PPFEATURE + \"%s TEXT DEFAULT null, \" // FIELD_FID + \"%s TEXT DEFAULT null, \"// FIELD_CATEGORY_ID + \"%s TEXT DEFAULT null, \"// FIELD_CHANNEL_WEB_ID + \"%s INTEGERvDEFAULT 0, \" // CHANNEL_ID TABLE_UPLOAD, BaseColumns._ID, FIELD_LOCAL_PATH, FIELD_NAME, FIELD_TOKEN, FIELD_SIZE, FIELD_STATE, FIELD_PPFEATURE, FIELD_FID, FIELD_CATEGORY_ID, FIELD_CHANNEL_WEB_ID,CHANNEL_ID));&#125; 后面可以实践下。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"BugFix","slug":"BugFix","permalink":"http://zengfanyu.top/tags/BugFix/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （四） RxJava 调度器和操作符","slug":"RxJava4","date":"2018-01-20T06:16:16.000Z","updated":"2018-01-20T09:10:42.323Z","comments":true,"path":"2018/01/20/RxJava4/","link":"","permalink":"http://zengfanyu.top/2018/01/20/RxJava4/","excerpt":"摘要：之前的记录了一下 RxJava 最基本的使用方法，没有涉及到为什么这么多人使用它的具体原因，就是说没体现它的魅力所在嘛， 所以这一篇就记录一下我学习的RxJava 当中的变换操作符（Operator）和调度器（Scheduler），前者可以说是 RxJava 的核心功能之一，也是大多数人使用 RxJava 的主要原因，后者是可以让不同线程之间的代码在一条链路代码中书写，极大简化逻辑。","text":"摘要：之前的记录了一下 RxJava 最基本的使用方法，没有涉及到为什么这么多人使用它的具体原因，就是说没体现它的魅力所在嘛， 所以这一篇就记录一下我学习的RxJava 当中的变换操作符（Operator）和调度器（Scheduler），前者可以说是 RxJava 的核心功能之一，也是大多数人使用 RxJava 的主要原因，后者是可以让不同线程之间的代码在一条链路代码中书写，极大简化逻辑。 调度器（Scheduler）开发过程中经常会碰到这样的需求：子线程中去请求服务器数据，拿到数据之后进行解析，然后回调给主线程中的接口去展示。 这种需求有很多种写法，比如用 AsyncTask ，在 doInBackground 中进行耗时操作，然后在 onPostExecute 当中接受结果，进行处理；或者是直接在主线程中切进行耗时操作，然后通过用 Looper.getMainLooper() 创建的 Handler 将结果发送至主线程去处理。 上面提到的两种方法，主要要解决的问题就是切换线程，因为 Android 中规定耗时操作不能在主线程当中进行，但是 UI 的更新操作又必须在主线程中进行，而 UI 的更新状态往往是需要耗时操作所得到的结果来做支撑的。所以为了解决这一矛盾，Google 官方给了 AsyncTask 和 Handler 两个工具。 RxJava 当然也可以解决上述问题，并且是在同一条链路中，不存在各种接口的回调，起到这个作用的就是 Scheduler，线程调度器。RxJava 通过它来指定每一行代码应该运行在什么样的线程环境，RxJava 当中已经内置了好几种 Scheduler： Scheduler 的种类1. Schedulers.newThread() 这个 Scheduler 会创建一个新的线程，并且用这个 Scheduler 指定的代码会在新创建的线程中去执行。 2. Scheduler.io() 这个 Scheduler 适用于一些执行阻塞式 IO 操作的，比如说：读写文件、读写数据库、访问网络等。它在内部是使用 CacheThreadPool 实现的。 123456public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 这个线程池没有核心线程数，它会根据需要去创建线程，并且有 60秒 的超时机制。不要用这个 Scheduler 去指定计算操作的运行线程，这样可以避免创建多余的线程。 3. Schedulers.computation() 这个 Scheduler 适合执行 CPU 密集型的操作，比如事件循环，处理回调和其他计算工作。它内部使用的是固定线程数的线程池，大小等于 CPU 核数。不要用它去指定 IO 操作的代码运行线程环境，不然 IO 操作的等待会浪费 CPU。 4. AndroidScheculers.mainThread() 这个 Scheduler 是 Android 独有的， 用它指定的代码会运行在主线程当中。 Scheduler 的使用有了上述 Scheduler 之后， 就可以使用 subscribeOn() 和 observerOn() 两个方法来指定代码的运行环境了。 这里的代码使用的是 RxJava2 的 API1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); tv = findViewById(R.id.id_tv); Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; String result = getDataFromServer(); if (!TextUtils.isEmpty(result)) &#123; e.onNext(result); &#125; &#125; &#125;) .subscribeOn(Schedulers.io())//指定subscribe（）发生在io线程 .observeOn(AndroidSchedulers.mainThread())//指定 Subscriber 的回调发在主线程 .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String result) throws Exception &#123; LogUtil.d(TAG, \"[ accept ] \" + \"result=\" + result); LogUtil.d(TAG, \"[ accept ] \" + \"current thread is \" + Thread.currentThread().getName()); tv.setText(result); &#125; &#125;);&#125;public String getDataFromServer() &#123; LogUtil.d(TAG, \"[ getDataFromServer ] \" + \"current thread is \" + Thread.currentThread().getName()); LogUtil.d(TAG, \"[ getDataFromServer ] \" + \"get data from server\"); return \"Hello RxJava\";&#125; 看看 Log情况： 12345D/===RxJavaSample==: TestActivity [ getDataFromServer ] current thread is RxCachedThreadScheduler-1D/===RxJavaSample==: TestActivity [ getDataFromServer ] get data from serverD/===RxJavaSample==: TestActivity [ accept ] result=Hello RxJavaD/===RxJavaSample==: TestActivity [ accept ] current thread is main 很明显了， Observable 是在子线程中发送事件， 而 Obserber 接收并处理事件是在 主线程中进行的。 总结一下， subscribeOn() 用于指定 Observable 发送事件的线程。 obserberOn() 用于指定 Observer 接受并处理事件的线程。 关于两者多次使用的情况，做一下总结： subscribeOn()：多次调用，只有第一次有效。 observerOn()：每调用一次，下面的代码就会切换一次。 举个例子(使用了 lambda 表达式)： 123456789101112131415161718192021222324252627282930313233343536373839@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); tv = findViewById(R.id.id_tv); Observable.create((ObservableOnSubscribe&lt;String&gt;) e -&gt; &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"current thread is \" + Thread.currentThread().getName()); String token = getTokenFromServer(); LogUtil.d(TAG, \"[ subscribe ] \" + \"token:\" + token); e.onNext(token); &#125;) .subscribeOn(Schedulers.io())//第一次指定subscribe()在io线程 .subscribeOn(AndroidSchedulers.mainThread())//第二次指定subscribe()的线程在主线程 .observeOn(Schedulers.io())//指定下面map操作发生在io线程 .map(s -&gt; &#123; LogUtil.d(TAG, \"[ apply ] \" + \"current thread is \" + Thread.currentThread().getName()); String playUrl = getPlayUrl(s); LogUtil.d(TAG, \"[ apply ] \" + \"play url is \" + playUrl); return playUrl; &#125;) .observeOn(AndroidSchedulers.mainThread())//指定Observer接受事件是在主线程 .subscribe(s -&gt; &#123; LogUtil.d(TAG, \"[ accept ] \" + \"current thread is \" + Thread.currentThread().getName()); LogUtil.d(TAG, \"[ accept ] \" + \"s=\" + s); tv.setText(s); &#125;); &#125; public String getTokenFromServer() &#123; return \"token-123456\"; &#125; public String getPlayUrl(String token) &#123; return \"api.xxxx.com?a=12&amp;b=34&amp;token=\" + token; &#125; 输出结果： 123456701-07 18:45:51.191 12827-12853/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] current thread is RxCachedThreadScheduler-101-07 18:45:51.191 12827-12853/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] token:token-12345601-07 18:45:51.191 12827-12854/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ apply ] current thread is RxCachedThreadScheduler-201-07 18:45:51.191 12827-12854/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ apply ] play url is api.xxxx.com?a=12&amp;b=34&amp;token=token-12345601-07 18:45:51.351 12827-12827/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] current thread is main01-07 18:45:51.351 12827-12827/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] s=api.xxxx.com?a=12&amp;b=34&amp;token=token-123456 可以看到在第二次调用 subscribeOn(AndroidSchedulers.mainThread()) 并没有起作用，拿 token 的操作仍然是在 io 线程执行的。 而第一次调用 observeOn(Schedulers.io()) 之后，后面的 map 操作用 token 去拿 url 地址这个过程是在 io 线程执行的。 在第二次调用 observeOn(AndroidSchedulers.mainThread()) 之后，将 url 地址显示在 TextView 这个过程是在 主线程中执行的。 变换操作符在 只因为在众多框架中多看了你一眼 RxJava （二） 从概念上理解 RxJava 这篇中举了一个过滤的例子，那么我理解的 RxJava 的变换操作，就类似于过滤过程，“过滤” 就是这个变换，但是变换不仅仅包含过滤。下面记录一些常用的操作符。 mapmap 就是对 Observable 发出的每一个事件，都施加一个函数，使得每一个事件都按照指定的函数去变化，Observer 接收到的事件就是经过函数变化后的。 官方图： 用代码实现： 1234567891011121314Observable.just(1,2,3) .map(new Function&lt;Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer) throws Exception &#123; return integer*10; &#125; &#125;) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer s) throws Exception &#123; LogUtil.d(TAG,\"[accept] \" + \"after map s:\"+s); &#125; &#125;); 从上面的代码和示意图能看出来， map 操作符是一种一对一的关系。 flatMap这个操作符通过例子来理解： 需求：打印出每一个学生所选修的课程，一个学生不止选修一门课程。 学生和课程的数据结构如下： 12345678910111213141516171819/** * @author: fanyuzeng on 2018/1/8 10:22 */public class Student &#123; private String mName; private List&lt;Course&gt;mCourses; //getter setter&#125;/** * @author: fanyuzeng on 2018/1/8 10:35 */public class Course &#123; private String courseName; //getter setter&#125; 常规写法： 12345678910Observable.fromIterable(mStudentList) .subscribe(new Consumer&lt;Student&gt;() &#123; @Override public void accept(@NonNull Student student) throws Exception &#123; for (Course course : student.getCourses()) &#123; LogUtil.d(TAG, \"[accept] \" + course.toString()); &#125; &#125; &#125;); mStudentList 中，xiaoming1 选修 yuwen1、yuwen2;xiaoming2 选修 yuwen3、yuwen4;xiaoming3 选修 yuwen5、yuwen6; 上述代码没报名，可以打印出每一个学生的选修课程，但是这对代码的复用性不高，我们希望的是在 Consumer 的 accept() 当中传入的参数就是一个一个的 Course 对象。 这个时候就要靠 flatMap 了。 123456789101112131415Observable.fromIterable(mStudentList) .flatMap(new Function&lt;Student, ObservableSource&lt;Course&gt;&gt;() &#123; @Override public ObservableSource&lt;Course&gt; apply(@NonNull Student student) throws Exception &#123; return Observable.fromIterable(student.getCourses()); &#125; &#125;) .subscribe(new Consumer&lt;Course&gt;() &#123; @Override public void accept(@NonNull Course course) throws Exception &#123; LogUtil.d(TAG, \"[accept] \" + course); &#125; &#125;); flatMap 将原始 Observable 发送的事件构造成多个 Observable 对象，然后将他们发送的事件整合到另外的一个单独的 Observable 中。 官方解释图： 扔物线的解释图： 还有一种图，很形象： flatMap 的原理： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable, 而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。 这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象「铺平」之后通过统一路径分发了下去。而这个「铺平」就是 flatMap() 所谓的 flat。 可以看得出来上面的示意图能看出来，flatMap 并不能保证事件的顺序，要想保证顺序，则用 ConcatMap。 从上面的代码和示意图能看出来， flatMap 操作符是一种一对多的关系。 flatMap 拓展传统的嵌套请求是需要嵌套回调机制来实现的，但是使用 flatMap 就可以把请求写在一条链中，使逻辑清晰，这也可以体现它的优势吧：随着程序逻辑越来越复杂，它仍然能保持简洁。 假设存在两个 Retrofit 接口， 一个用于注册，一个用于登录： 12345678public interface Api &#123; @GET Observable&lt;LoginResponse&gt; login(@Body LoginRequest request); @GET Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);&#125; (这里涉及到Rxjava + Retrofit 的使用) 1234567891011121314151617181920212223242526272829api.register(new RegisterRequest()) //发起注册请求 .subscribeOn(Schedulers.io()) //在IO线程进行网络请求 .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求注册结果 .doOnNext(new Consumer&lt;RegisterResponse&gt;() &#123; @Override public void accept(RegisterResponse registerResponse) throws Exception &#123; //先根据注册的响应结果去做一些操作 &#125; &#125;) .observeOn(Schedulers.io()) //回到IO线程去发起登录请求 .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;LoginResponse&gt;&gt;() &#123; @Override public ObservableSource&lt;LoginResponse&gt; apply(RegisterResponse registerResponse) throws Exception &#123; return api.login(new LoginRequest()); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) //回到主线程去处理请求登录的结果 .subscribe(new Consumer&lt;LoginResponse&gt;() &#123; @Override public void accept(LoginResponse loginResponse) throws Exception &#123; Toast.makeText(MainActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; Toast.makeText(MainActivity.this, \"登录失败\", Toast.LENGTH_SHORT).show(); &#125; &#125;); concatconcat 操作符用于链接多个事件，只有当前面一个事件结束之后，才会发送后面的事件。 官方图： 我们获取网络数据的时候，经常会在本地缓存一份，然后在下一次获取数据的时候，会先从缓存中去拿数据，如果拿到了数据就直接返回，如果没有拿到数据，再去请求网络获取数据。 这样的需求就十分适合使用 concat 操作符来完成。 从缓存中拿数据的 Observable 123456789101112131415161718192021222324//从缓存获取数据Observable&lt;FidResponseBean&gt; getCacheDataObservable = Observable.create(new ObservableOnSubscribe&lt;FidResponseBean&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;FidResponseBean&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"current thread:\" + Thread.currentThread().getName()); //尝试从缓存弄中拿数据 FidResponseBean cacheData = CacheManager.getInstance().getCache(Network.fid); if (cacheData != null) &#123; isFromNet = false; LogUtil.d(TAG, \"[ subscribe ] \" + \"data from cache\"); runOnUiThread(() -&gt; tv.setText(\"data from: cahce\")); //调用 onNext 方法不会触发下一个 Observable e.onNext(cacheData); &#125; else &#123; isFromNet = true; LogUtil.d(TAG, \"[ subscribe ] \" + \"data from net\"); runOnUiThread(() -&gt; tv.setText(\"data from: net\")); //只有调用 onComplete 之后，才会执行下一个 Observable e.onComplete(); &#125; &#125;&#125;); 从网络拿数据的 Observable 123456//从网络获取数据Observable&lt;FidResponseBean&gt; getNetDataObservable = Network.getFidApi().getFidInfo( Network.name, Network.length, Network.ppfeature); 其中 Network 是封装好的 Retrofit 工具。 API： 1234567public interface FidApi &#123; @GET(\"uploadtest/uptoken\") Observable&lt;FidResponseBean&gt; getFidInfo(@Query(\"name\") String name, @Query(\"length\") String length, @Query(\"ppfeature\")String ppfeature);&#125; 使用 concat 操作符。 1234567891011121314151617181920212223Observable.concat(getCacheDataObservable, getNetDataObservable) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;FidResponseBean&gt;() &#123; @Override public void accept(@NonNull FidResponseBean fidResponseBean) throws Exception &#123; LogUtil.d(TAG, \"[ accept ] \" + \"subscribe success thread:\" + Thread.currentThread().getName()); show.setText(String.format(\"data: %s\", fidResponseBean.toString())); if (isFromNet) &#123; //缓存 CacheManager.getInstance().putCache(fidResponseBean); &#125; &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(@NonNull Throwable throwable) throws Exception &#123; LogUtil.d(TAG, \"[ accept ] \" + \"subscribe fail thread:\" + Thread.currentThread().getName() + \"\\n\" + \"e:\" + throwable.toString()); &#125; &#125;); 输出结果： 12345678910//没有缓存的时候01-20 13:58:56.774 6750-7543/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] current thread:RxCachedThreadScheduler-101-20 13:58:56.775 6750-7543/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] data from net01-20 13:58:57.491 6750-6750/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] subscribe success thread:main//有缓存的时候01-20 14:06:32.625 6750-14144/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] current thread:RxCachedThreadScheduler-201-20 14:06:32.625 6750-14144/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ subscribe ] data from cache01-20 14:06:32.627 6750-6750/com.rengwuxian.rxjavasamples D/===RxJavaSample==: TestActivity [ accept ] subscribe success thread:main zip关于 zip 操作符，官方的解释图： 另一种解释图： 详细版： 后两张水管图引用自： https://www.jianshu.com/p/bb58571cdb64 有了上面三张图， zip 操作符的作用就很好理解了，就是通过一个函数将多个 Observable 发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个 Observable 一样多的数据。 当然了，还有一些细节上的问题需要注意的，闲先总结： zip 可以将多个 Observable 发送的事件组合在一起，并且基于这个函数的结果，将每一个组合后的事件重新发送出去，并且一个事件只能被组合一次，组合的顺序是严格按照事件发送的顺序来进行的。 最终 Observer 接收到的事件的数量，是 Observable 发送事件最少的哪一个的事件数量。 举个栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 1\"); e.onNext(1); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 2\"); e.onNext(2); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 3\"); e.onNext(3); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 4\"); e.onNext(4); LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 1\"); e.onComplete(); &#125; &#125;); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter a\"); e.onNext(\"a\"); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter b\"); e.onNext(\"b\"); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter c\"); e.onNext(\"c\"); LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 2\"); e.onComplete(); &#125; &#125;); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(@NonNull Integer integer, @NonNull String s) throws Exception &#123; return integer+s; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtil.d(TAG, \"[ onSubscribe ] \"); &#125; @Override public void onNext(String s) &#123; LogUtil.d(TAG, \"[ onNext ] \" + \"s:\" + s); &#125; @Override public void onError(Throwable e) &#123; LogUtil.d(TAG, \"[ onError ] \" + e.toString()); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"[ onComplete ] \"); &#125; &#125;); 代码很简单，一个 Observable 发送 1、2、3、4、onCompele，另外一个 Observab 发送 a、b、c、onComplete。 打印出的结果： 照这个顺序看，似乎是先发送 Observable1 的事件，然后再发送 Observable2 的事件，并且每发送一个 Observable2 的事件就会触发 Observer 做出反应。 那么是不是这样呢？ 我们将每个发送事件的代码都延时 1s ，这里就不贴代码了。 似乎是这样哈？ 但是按照上面的解释图来说，不应该是这样呀，应该是 Observable1 发送一个事件，然后 Observable2 发送一个事件，然后组合了之后，Observer 接收一个事件 才对。 分析一下原因： 目前的代码，Observable1 和 Observable2 发送事件都在同一个线程当中，在同一个线程里代码的执行时有先后顺序的，当然是先执行完 Observable1 发送的所有事件之后，再执行 Observer2 发送的事件，然后组合，然后 Observer 接收。 如果将 Observa1 和 Observa2 发送事件分别放在两个线程当中呢？ 修改一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 1\"); e.onNext(1); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 2\"); e.onNext(2); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 3\"); e.onNext(3); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter 4\"); e.onNext(4);//注意这里没有睡 1s LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 1\"); e.onComplete(); &#125; &#125;).subscribeOn(Schedulers.io()); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter a\"); e.onNext(\"a\"); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter b\"); e.onNext(\"b\"); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"emitter c\"); e.onNext(\"c\"); Thread.sleep(1000); LogUtil.d(TAG, \"[ subscribe ] \" + \"complete 2\"); e.onComplete(); &#125; &#125;).subscribeOn(Schedulers.io()); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(@NonNull Integer integer, @NonNull String s) throws Exception &#123; return integer + s; &#125; &#125;) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; LogUtil.d(TAG, \"[ onSubscribe ] \"); &#125; @Override public void onNext(String s) &#123; LogUtil.d(TAG, \"[ onNext ] \" + \"s:\" + s); &#125; @Override public void onError(Throwable e) &#123; LogUtil.d(TAG, \"[ onError ] \" + e.toString()); &#125; @Override public void onComplete() &#123; LogUtil.d(TAG, \"[ onComplete ] \"); &#125; &#125;); 跟之前的代码比较，就是将两个 Observab 放在子线程中去执行了。 看看 Log 动态图： 这次的 Log 是不是就比较合理了！两个 Observable 同时开始发送，每发送一个 zip 就会组合一个，然后发送给 Observer，然后当事件少的哪一个 Observab2 发送了 onComplete 之后，虽然 Observable1 还是会继续发送，但是 Obserber 不会接收了。 还有一点要注意的：上面图片中的 红色的框框，会发现并不一定就是 observable1 发一个，然后 Observable2 发送一个，两者可能是交错进行的，这个涉及到某一时刻是哪个线程获取到 cpu 的执行权，所以上面代码多运行几次，log 并不相同，比如还有这种情况： 并且把延迟的代码去掉之后，再看看 log 对的，毫无规律可言，因为当前是哪个线程拿到 cpu 的控制权是不确定的，并且在每一轮当中的时间片长短也有差别，所以日志中会出现这种情况。 这个部分就总结到这了，后面看看背压相关的。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （三） RxJava 最基础的使用","slug":"RxJava3","date":"2018-01-06T08:27:16.000Z","updated":"2018-01-06T09:04:10.179Z","comments":true,"path":"2018/01/06/RxJava3/","link":"","permalink":"http://zengfanyu.top/2018/01/06/RxJava3/","excerpt":"摘要：上一篇理解了概念之后，这里就要用代码来实现以下了，这一篇只涉及到 RxJava 的最基础的用法，不涉及高级特性。","text":"摘要：上一篇理解了概念之后，这里就要用代码来实现以下了，这一篇只涉及到 RxJava 的最基础的用法，不涉及高级特性。 RxJava的基本用法RxJava 的基本实现,总结起来,主要有三点: 创建 Observer 创建 Observable 订阅 创建 Observer 观察者Observer 即观察者,它决定当事件发生的时候,会有怎么样的行为.RxJava 中 Observer 接口的实现方式: 1234567891011121314151617Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 除了 Observer 接口之外, Rxjava 当中还内置了一个实现了 Observer 接口的抽象类, Subscriber , Subscriber 对 Observer 做了扩展,但是两者的使用方式是完全一样的. 1234567891011121314151617Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, \"Item: \" + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, \"Completed!\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, \"Error!\"); &#125;&#125;; 既然 观察者的作用是 决定当事件触发时,会有什么样的行为,那么我们能不能直接有方法定义出行为就可以了呢? 123456789101112131415161718192021222324Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;//Action1接口是RxJava当中定义的,其中只有一个call(T param)方法,这个call方法有1个参数,无返回值Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;//Action0接口是RxJava当中定义的,其中只有一个call()方法,这个call方法无参数无返回值Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, \"completed\"); &#125;&#125;; 至于 onNextAction onErrorAction onCompletedAction 如何使用,为什么几个 Action 就能代表 Subscriber 的 onNext onError onCompleted 方法呢 ? 下面 Subscribe 订阅的时候说. 创建 Observable 被观察者Observable 指的是被观察者,它决定事件什么时候触发,以及触发何种事件. RxJava 用 create() 方法来创建一个 Observable ,并为它定义触发规则. 12345678910Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"Java\"); subscriber.onNext(\"C++\"); subscriber.onNext(\"Python\"); subscriber.onCompleted(); &#125;&#125;); 这里参数传入的是 OnSubscribe 对象,这个对象会被存储在 Observable 中,充当一个计划表的角色,具体的计划内容就是 call 方法中的实现. call() 方法的参数 Subscriber 就是观察者,两者关系的建立看下面. 当 Observable 被订阅的时候, OnSubscribe 的 call 方法会被自动调用,然后去执行计划,上面的代码的计划就是执行三次 onNext() ,然后执行一次 onCompleted(). 到这里就实现了事件由被观察者向观察者的传递. 看上面的代码,被观察者的作用就是触发事件,那么可不可以有一种类似于 Java8 当中的便捷构造流的方法一样(Stream.of(T…)),直接将事件按照顺序创建出来就行了?当然有 just(T…) 1234Observable observable = Observable.just(\"Java\", \"C++\", \"Python\");//上述代码等价于创建被观察者,然后依次调用了观察者的 onNext(\"Java\"), onNext(\"C++\"),onNext(\"Python\"),onCompleted() from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 1234String[] words = &#123;\"Java\", \"C++\", \"Python\"&#125;;Observable observable = Observable.from(words);// 效果和上面一样 Subscribe 订阅之前创建了 Observer 和 Observable 之后,就要将两者关联起来了,这就相当于创建了 Button 和 OnClickListener 之后,需要有一个 setOnClickListener 方法,将两者关联起来,这样当 Button 上有点击事件发生的时候,它就回去调用 OnClickListener 的 onClick 方法.这里的 Subscribe 订阅起的作用和 setOnClickListener 是一样的. 123456observable.subscribe(observer);//或者observable.subscribe(subscriber);//这个过程就类似于//button.setOnClickListener(mOnClickListener); Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）: 123456public Subscription subscribe(Subscriber subscriber) &#123; subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;&#125; 订阅过程做三件事: 调用 subscriber.onStart() 做预处理工作. 调用 onSubscribe.call(subscriber) 方法.(这也就是为什么在上面创建被观察者时,我们说 「当 Observable 被订阅的时候, OnSubscribe 的 call 方法会被自动调用,然后去执行计划.」) 将传入的 subscriber 返回,便于 unSubscribe(). 现在可以说说之前在创建 Observer 时,创建的三个 Action 了. 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。 1234567// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 我们观察可以发现, Subscriber 的 onNext , onError 方法的返回类型是 void , 并带有一个参数,分别是 String , Throwable 而 Action1 接口里面的 call 方法也是有一个参数 T ,返回类型是 void. Subscriber 的 onCompleted 方法的返回类型是 void, 没有参数,而 Action0 接口里的 call 方法也是没有参数的, 并且返回值为 void. 这么一总结,上面这个操作是不是就像 java8 当中的 lamuda 表达式了 ? 我在学习lambda表达式时总结的一篇文章 123456789101112//Before Java8mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; System.out.println(\"Button clicked!\"); &#125; &#125;);//In java8 way mButton.setOnClickListener((v)-&gt; &#123; System.out.println(\"Button clicked!\"); &#125;); 注意看下面的 lambda 表达式中的 (V) ,这里的 v 形参, 就是代表的是上面回调方法中的 view ,后面的 -&gt;System.out.println(“Button clicked!”) ,就是用于定义 onClick() 的方法体的. 确实类似,这里相当于其他语言中的 「闭包」. 到这里,就已经说完了 RxJava 当中最基础的三个角色了. 那么也可以简单的使用一下啦. 简单使用1)打印一串字符串 12345678Observable.just(\"Java\",\"C++\",\"Python\") .subscribe(new Action1&lt;String&gt;()&#123; @override public void call(String languageName)&#123; log.d(\"RxJava\",\"languageName\"); &#125; &#125;) 2)根据 drawable 资源名, 取出 drawable,然后显示到 imageView 上. 12345678910111213141516171819202122232425int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （二） 从概念上理解 RxJava","slug":"RxJava2","date":"2018-01-06T08:27:15.000Z","updated":"2018-01-06T09:23:54.313Z","comments":true,"path":"2018/01/06/RxJava2/","link":"","permalink":"http://zengfanyu.top/2018/01/06/RxJava2/","excerpt":"摘要：一开始学习 RxJava ，觉得这东西特抽象，不好把握，但是在阅读了一些文章之后，也逐渐对 RxJaba 在宏观上有一个大概的认识，这一篇就记录一下我对 RxJava 最基础的理解。","text":"摘要：一开始学习 RxJava ，觉得这东西特抽象，不好把握，但是在阅读了一些文章之后，也逐渐对 RxJaba 在宏观上有一个大概的认识，这一篇就记录一下我对 RxJava 最基础的理解。 RxJava 是什么想要知道 RxJava 是什么，当然还是要去看看 RxJava 在 Github 上面的主页，毕竟官方的介绍是最准确的。 RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM. 对，这就是官方对 RxJava 的解释，翻译一下：RxJava—JVM的反应式扩展。 是一个使用可观测的序列来组成异步的，基于事件序列的库。这么一说，我还是不能理解这个库到底是干嘛的，毕竟这是官方站在一定的高度上对 RxJava 的总结，就类似于在 Java 中的一句话：Everything is objects，刚开始接触 Java 时肯定也无法理解这句话的意思 。 既然官方的解释对于初学者的我来说这么难懂，那就先看看 Rx 是什么意思吧。Rx—全称是Reactive Extensions，直译过来就是响应式扩展。Rx基于观察者模式，他是一种编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。 这么一捋之后，我似乎有一点点理解了，它完成的功能似乎就是和 Google 官方的 AsyncTask Handler 类似，解决异步问题的，但是为什么大家都用它而不去使用 AsyncTask Handler 呢？ 这些也都是解决异步的呀？ 答案是：简洁，逻辑上的简洁。 所以这里就一句话，RxJava 是用一种扩展的观察者模式解决异步问题的基于事件序列的库。 所以我就从观察者模式开始学习了。 观察者模式那就要先说说观察者模式了。 打个比方来说，我们公司外面的馄饨店，每天中午好多人都回去哪里吃馄饨，大家过去了之后「点了一碗馄饨并付账」，就坐在那里等着老板叫号了。老板一叫：25号鲜肉小馄饨好了，那么一哥们听到之后，就立马「屁颠颠的跑过去端回来吃」，老板又叫：28号荠菜大馄饨好了，一妹子又「屁颠颠的跑过去端回来吃」。这个过程就是一个观察者模式。 这里涉及到三个对象，观察者：坐着等馄饨的吃货们。被观察者：馄饨店老板。订阅关系：点了一碗馄饨并付账。 还涉及到一个具体的反应过程：「屁颠颠的跑过去端回来吃」。 图解： 再说说在 Android 开发中会经常接触到的观察者模式，对一个 Button 的监听。Button 是被观察者，OnClickListener 是观察者，两者通过 setOnClickListener 方法达成订阅关系，那么此时 OnClickListener 就对 Button 的点击事件高度敏感了，只要 Button 以被用户点击，那么 OnClickListener 就会“立马”（这个立马，要打个引号，应为这里还涉及到事件的分发过程，不展开说了）做出反应，也就是调用它的 onClick 方法。 图解： 其实上面两个过程我们也可以这样理解，观察者和被观察者之间先有订阅关系，然后被观察者发出了一个事件，然后观察者接收到这个事件之后，做出了响应。 在从事件出发的角度捋捋上面两个过程： 吃货去馄饨店里「点了一碗馄饨并付账」，那么就订阅了馄饨店老板发出的 HuntunReady 事件。当馄饨店老板发出了一个 HuntunReady 的事件（图中没有画出）的时候，吃货A接收到这个事件并做出反应，也就是调用了 onHuntunReady 方法去处理,具体的处理逻辑就是：「屁颠颠的跑过去端回来吃」（图中也没有画出）。 OnClickListener 通过 setOnclickListener 订阅 Button 的 Click 事件，当Button 发出了一个 Click 的事件， OnClickListener 接受到了这个事件，就要做出了反映，也就是调用 onClick 方法，执行当中的逻辑。 对照表： 那么我们把这个概念抽象为观察者，被观察者，订阅，那么图应该是这样的： RxJava 当中的观察者模式有了上面两个例子的铺垫，这里就推导出，RxJava 就是 Observer 和 Observable 两者先发生订阅关系，然后 Observable 发出事件序列，Observer 接受事件并响应处理。 但之前又说到 RxJava 使用的是一种扩展的观察者模式，那么跟上面两个例子中肯定是有不同的。它扩展之后的形式如下： 区别（一）看的出来， RxJava 中的观察者模式跟传统观察者模式比起来，事件的回调方法除了普通事件 onNext（相当于上面例子中的 onClick 和 onHuntunReady）之外，还定义了两个特殊的事件， onCompleted()， onError(); 这三个事件遵从一定的规则： Observable 可以发送无限个 onNext 事件，Observer 可以接受无限个 onNext 事件。 当 Observable 发送了 onCompleted 或者 onError 序列之后，之后的事件序列仍然会发送，但是 Observer 这边在接收到 onCompleted 或者 onError 事件之后，是不会在继续接收之后的事件序列的。 Observable 可以不发送 onCompleted 或者 onError 事件。 onCompleted 和 onError 事件必须互斥。也就是说在一个事件序列中，要么是没有 onCompleted 和 onError 事件，要么有且只能有其中一个。 区别（二）就是 Observable 在发送事件到 Observer 的过程中，多了一个 Operate 过程，这个操作就是对事件进行一系列的处理，然后再发送至 Observer。要说到这个操作就不得不提 Java8 当中的 Stream 和它对其中每一个元素进行的函数式操作。 我们用“过滤”这个操作来打个比方， 就像下面这幅图中画的那样，我有一杯混合着大大小小石子的蓝色的水。 现在按照我们关于“流”的定义，我用下图中的方法将水转化成“流”。 为了让水变成水流，我把水从一个杯子倒进另一个杯子 里。现在我想去掉水中的大石子，所以我造了一&gt; 个可以帮我滤掉大石子的过滤器。“大石子过滤器”如下图所示。 现在，将这个过滤器作用在水流上，这会得到不包含大石子的水。如下图所示。 接下来，我想从水中清除掉所有石子。已经有一个过滤大石子的过滤器了，我们需要造一个新的来过滤&gt;小石子。“小石子过滤器”如下图所示。 像下图这样，将两个过滤器同时作用于水流上。 接下来，我想把水的颜色从蓝色变成黑色。为了达到这个目的，我需要造一个像下图这样的“水颜色转换器（mapper）”。 像下图这样使用这个转换器。 把水转换成水流后，我们做了很多事情。我先用一个过滤器去掉了大石子，然后用另一个过滤器去掉了&gt;小石子， 最后用一个转换器（map）把水的颜色从蓝色变成黑色。 这个过程就是 Java8 当中对流的操作的一个具体的体现。 好了，现在可以回到 Rxjava 当中了。 RxJava 当中的 operate 过程也类似于上面的过滤过程，在 Observable 发出事件之后，可以利用「操作符」对事件进行一系列的操作，包括但不仅仅局限于 “过滤”、“合并”、“线程切换”等等，得到我们最终想要的“过滤”后的事件。 恩，这就是 RxJava 当中最基础的东西了，先对 RxJava 有一个宏观上的认识，后面才好继续学习。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"只因为在众多框架中多看了你一眼 RxJava （一）","slug":"Rxjava1","date":"2018-01-04T13:27:15.000Z","updated":"2018-01-06T08:47:39.021Z","comments":true,"path":"2018/01/04/Rxjava1/","link":"","permalink":"http://zengfanyu.top/2018/01/04/Rxjava1/","excerpt":"","text":"前言年关将近,部门里任务也多了起来,最近一个月多都在忙着部门项目,因为突然接手了三个项目,虽然已经开发了一个版本,但是我还是花了很多时间去消化现有的版本,然后接着迭代开发,昨天上线了,现在有了空余的时间,准备接着写博客了。 之前在写 MVP 系列第一篇文章的时候就立了一个 Flag， 要学习 MVP、okHttp、Rxjava、Retrofit2、Dagger2，然后用这些流行开源框架撸一个 APP。现在 MVP 系列算是有了基础的了解了，并在学 MVP 的时候，把 OkHttp 也封装着在 Model 层使用，Retrofit2 也零零散散看过一些 Demo ，Dagger2 之前也总结了一篇文章 Dagger2基础内容归纳。剩下比较难啃的就是 RxJava了。这个任务已经被我添加到我 2018 年的计划当中了。 在两年前刚开始接触到 RxJava 的时候，是被它的链式调用所吸引，子线程操作、主线程操作、线程切换、事件变换在链式调用里一气呵成，再也看不到 AsyncTask 中繁琐的各种方法，同时也被它的各种高级特性所迷惑，各种操作符，各种闭包特性。之前在学校里的时候就看过「扔物线」大神的经典入门文章给 Android 开发者的 RxJava 详解 ，但是当时忙于找工作、实习，之后忙着毕业论文、毕业疯，一直没有好好实践，现在准备好好学习一下时发现，已经到了 RxJava2 的时代了，之前「扔物线」大神的那篇是基于 Rxjava1 写的，是先学学 RxJava1 再去学习 2 好呢，还是直接去学习 2 ，思来想去感觉这个问题就像： 学习 java 之前要先学习 C 吗？ 抛开别的不说，「扔物线」的那篇入门文章是质量是相当高的，深入浅出，对于我这样的初学者来说，学习的价值是十分大的，然后在看完这篇 RxJava2 vs RxJava1 对比的文章之后，我觉得还是很有必要去了解一下 Rxjava1 的，这样才能知道 2 改进在哪里，为什么这么改进， 是因为 1 中使用有什么问题。 并且后来在学习了 java8 当中的 Lambda 以及 Streams 之后发现，RxJava 当中很多实现都和其十分相似，比如说「闭包」特性的体现，和 Stream 当中对元素的挨个处理再返回，以及函数式编程的思想。 刚接触RxJava的情景还原说说最开始接触到 RxJava 的代码吧，应该是 2016 年的某一天。 一开始看到的是下面这两段代码： 12345678910111213141516171819202122232425//被观察者Observable&lt;String&gt; myObservable = Observable.create( new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; sub) &#123; sub.onNext(\"Hello, world!\"); sub.onCompleted(); &#125; &#125;);//观察者Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125;&#125;;//订阅myObservable.subscribe(mySubsciber); 好了，一个简单的使用 RxJava 的代码就完成了，最初我看到这段代码，心中就是 打印一个字符串搞这个复杂？？ 这是靠代码量算工资吗？？？ 后来人家说，上面那样写太复杂了，正确姿势： 12345678Observable.just(\"Hello, world!\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; System.out.println(s); &#125; &#125;); 人家说这样跟上面那一梭代码功能是一样的。 后来又有人说，这还是太复杂，要简化一下： 123Observable.just(\"Hello, world!\") .subscribe(s -&gt; System.out.println(s)); 我的内心： 之后我知道，原来这段单代码使用了 Java8 Lambda 表达式，利用函数式编程的优势，简化了程序中余的代码，所以在学习 RxJava 之前我应该先去学习一下 Java8 lambda 。总结文章：新姿势学习之Java8—Lambda Expressions。 我以为这就行了，但是接下来看到的代码更是让我更加坚定。。。 要想在 Subscriber 当中打印出 Observable 发送出来的每一个字符串后面加上 &quot;-ZFY&quot;: 123456789Observable.just(\"Hello, world!\") .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s + \" -ZFY\"; &#125; &#125;) .subscribe(s -&gt; System.out.println(s)); 同样的用 Lambda 简化； 1234Observable.just(\"Hello, world!\") .map(s -&gt; s + \" -ZFY\") .subscribe(s -&gt; System.out.println(s)); 然后我突然又想输出 接受的字符串拼接上”-ZFY” 的HashCode 的字符串， 那么可以这样： 12345Observable.just(\"Hello, world!\") .map(s -&gt; s.hashCode()) .map(i -&gt; Integer.toString(i)) .subscribe(s -&gt; System.out.println(s)); 到这里还没有涉及到线程切换的问题，还没有涉及到和 Retrofit 配合使用，虽然那时候我都不知道 这个 map 是干嘛的，总之觉得这个操作很 NB ，但是单单就上面那些特性，就足以对我产生强大的吸引力。 就在这一刻，我决定，Lambda 、Stream、函数式编程、RxJava 我也要学，我也要写出上面那样简洁高效的代码。 这就是我刚看到 RxJava 的情景。 到现在 Java8 Lambda Stream 函数式编程这些相关的， 我已经学习了一阵子了，该开始 RxJava 了。","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://zengfanyu.top/tags/RxJava/"}]},{"title":"一口一口啃完Java中的24种设计模式---桥接模式","slug":"桥接模式","date":"2018-01-04T08:27:16.000Z","updated":"2018-01-06T09:23:45.290Z","comments":true,"path":"2018/01/04/桥接模式/","link":"","permalink":"http://zengfanyu.top/2018/01/04/桥接模式/","excerpt":"","text":"问题引入:蜡笔与毛笔在正式介绍桥接模式之前，先谈谈两种常见文具的区别，它们是毛笔和蜡笔。假如我们需要大中小 3 种型号的画笔，能够绘制 12 种不同的颜色，如果使用蜡笔，需要准备 3×12 = 36 支，但如果使用毛笔的话，只需要提供 3 种型号的毛笔，外加 12 个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与 36 支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有 12 种颜色，对应的蜡笔需增加 12 支，而毛笔只需增加一支。为什么会这样呢？通过分析我们可以得知：在蜡笔中，颜色和型号两个不同的变化维度（即两个不同的变化原因）融合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方都没有任何影响。如果使用软件工程中的术语，我们可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也更为方便。在软件开发中，我们也提供了一种设计模式来处理与画笔类似的具有多变化维度的情况. 跨平台图像浏览系统开发一个跨平台图像浏览系统，要求该系统能够显示 BMP、JPG、GIF、PNG 等多种格式的文件，并且能够在 Windows、Linux、Unix 等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵（Matrix），然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。系统需具有较好的扩展性以支持新的文件格式和操作系统。 某公司的开发人员针对上述要求，提出了一个初始设计方案，其基本结构如图所示： 在图的初始设计方案中，使用了一种多层继承结构，Image 是抽象父类，而每一种类型的图像类，如 BMPImage、JPGImage 等作为其直接子类，不同的图像文件格式具有不同的解析方法，可以得到不同的像素矩阵；由于每一种图像又需要在不同的操作系统中显示，不同的操作系统在屏幕上显示像素矩阵有所差异，因此需要为不同的图像类再提供一组在不同操作系统显示的子类，如为 BMPImage 提供三个子类 BMPWindowsImp、BMPLinuxImp 和 BMPUnixImp，分别用于在 Windows、Linux 和 Unix 三个不同的操作系统下显示图像。 我们现在对该设计方案进行分析，发现存在如下两个主要问题： (1)由于采用了多层继承结构，导致系统中类的个数急剧增加，图中，在各种图像的操作系统实现层提供了12个具体类，加上各级抽象层的类，系统中类的总个数达到了 17 个，在该设计方案中，具体层的类的个数 = 所支持的图像文件格式数×所支持的操作系统数。 (2)系统扩展麻烦，由于每一个具体类既包含图像文件格式信息，又包含操作系统信息，因此无论是增加新的图像文件格式还是增加新的操作系统，都需要增加大量的具体类，例如在图中增加一种新的图像文件格式 TIF，则需要增加 3 个具体类来实现该格式图像在3种不同操作系统的显示；如果增加一个新的操作系统 Mac OS，为了在该操作系统下能够显示各种类型的图像，需要增加 4 个具体类。这将导致系统变得非常庞大，增加运行和维护开销。 如何解决这两个问题？我们通过分析可得知，该系统存在两个独立变化的维度：图像文件格式和操作系统，如图所示： 在图中，如何将各种不同类型的图像文件解析为像素矩阵与图像文件格式本身相关，而如何在屏幕上显示像素矩阵则仅与操作系统相关。正因为图所示结构将这两种职责集中在一个类中，导致系统扩展麻烦，从类的设计角度分析，具体类 BMPWindowsImp、BMPLinuxImp 和 BMPUnixImp 等违反了“单一职责原则”，因为不止一个引起它们变化的原因，它们将图像文件解析和像素矩阵显示这两种完全不同的职责融合在一起，任意一个职责发生改变都需要修改它们，系统扩展困难。 如何改进？我们的方案是将图像文件格式（对应图像格式的解析）与操作系统（对应像素矩阵的显示）两个维度分离，使得它们可以独立变化，增加新的图像文件格式或者操作系统时都对另一个维度不造成任何影响。看到这里，大家可能会问，到底如何在软件中实现将两个维度分离呢？这里就可以使用 桥接模式. 处理多维度变化——桥接模式概述桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。 桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下： 桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体（Handle and Body）模式或接口（Interface）模式。 角色关系桥接模式的结构与其名称一样，存在一条连接两个继承等级结构的桥，桥接模式结构如图所示： 在桥接模式结构图中包含如下几个角色： Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个 Implementor（实现类接口）类型的对象并可以维护该对象，它与 Implementor 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。 RefinedAbstraction（扩充抽象类）：扩充由 Abstraction 定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在 Abstraction 中声明的抽象业务方法，在 RefinedAbstraction 中可以调用在 Implementor 中定义的业务方法。 Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor 接口仅提供基本操作，而 Abstraction 定义的接口可能会做更多更复杂的操作。Implementor 接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用到 Implementor 中定义的方法，使用关联关系来替代继承关系。 ConcreteImplementor（具体实现类）：具体实现 Implementor 接口，在不同的 ConcreteImplementor 中提供基本操作的不同实现，在程序运行时，ConcreteImplementor 对象将替换其父类对象，提供给抽象类具体的业务操作方法。桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。 简单实现在使用桥接模式时，我们首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，我们将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此我们可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。在此，型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分，结构示意图如图所示： 在图中，如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。 在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了使两者之间耦合度降低，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分”维度，典型的实现类接口代码如下所示： 1234 interface Implementor &#123; public void operationImpl(); &#125; 在实现 Implementor 接口的子类中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法。对于另一“抽象部分”维度而言，其典型的抽象类代码如下所示： 12345678910abstract class Abstraction &#123; protected Implementor impl; //定义实现类接口对象 public void setImpl(Implementor impl) &#123; this.impl=impl; &#125; public abstract void operation(); //声明抽象业务方法 &#125; 在抽象类 Abstraction 中定义了一个实现类接口类型的成员对象 impl，再通过注入的方式给该对象赋值，一般将该对象的可见性定义为 protected，以便在其子类中访问 Implementor 的方法，其子类一般称为扩充抽象类或细化抽象类（RefinedAbstraction），典型的 RefinedAbstraction 类代码如下所示： 12345678 class RefinedAbstraction extends Abstraction &#123; public void operation() &#123; //业务代码 impl.operationImpl(); //调用实现类的方法 //业务代码 &#125; &#125; 对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。 适用范围 一个类存在两个或者以上的维度独立变化,并且这两个维度都需要扩展. 不希望使用继承或者因为多层次继承而导致整个系统类个数急剧增加的系统. 如果一个系统需要在构建的抽象画角色和具体化角色之间增加更多的灵活性,避免在两个层次之间建立静态的继承联系,可以通过桥接模式使它们在抽象层建立一个关联关系. 任何多维度之间的耦合都可以用桥接模式来解耦. 桥接模式在跨平台图片浏览系统中的应用为了减少所需生成的子类数目，实现将操作系统和图像文件格式两个维度分离，使它们可以独立改变，Sunny 公司开发人员使用桥接模式来重构跨平台图像浏览系统的设计，其基本结构如图所示： 代码实现: 像素矩阵类123456//像素矩阵类：辅助类，各种格式的文件最终都被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵class Matrix &#123; //此处代码省略&#125; 抽象图像类(其中一个变化维度)123456789101112131415/** * 抽象图像类 * * @author: fanyuzeng on 2018/1/4 14:46 */public abstract class Image &#123; protected IOperatorSystem os; public void setOS(IOperatorSystem os) &#123; this.os = os; &#125; public abstract void praseFileIntoImage(String filePath);&#125; 扩充图像类123456789101112131415161718/** * BMP格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:57 */public class BMPImage extends Image &#123; private static final String TAG = \"==BMPImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \",格式为:BMP\"); &#125;&#125; 123456789101112131415161718/** * GIF格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:58 */public class GIFImage extends Image &#123; private static final String TAG = \"==GIFImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \",格式为:GIF\"); &#125;&#125; 123456789101112131415161718/** * JPG格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:56 */public class JPGImage extends Image &#123; private static final String TAG = \"==JPGImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \"格式为:JPG\"); &#125;&#125; 123456789101112131415161718/** * PNG格式图像扩充类 * * @author: fanyuzeng on 2018/1/4 14:51 */public class PNGImage extends Image &#123; private static final String TAG = \"==PNGImage==\"; @Override public void praseFileIntoImage(String filePath) &#123; //模拟创建图像矩阵 Matrix m = new Matrix(filePath); //调用不同操作系统的展示图像方法去显示图片 os.showImage(m); System.out.println(\"[praseFileIntoImage] \" + filePath + \",格式为:PNG\"); &#125;&#125; 抽象操作系统接口(另外一个变化维度)123456789101112 /** * @author: fanyuzeng on 2018/1/4 14:48 */ public interface IOperatorSystem &#123; /** * 各个操作系统自带的将像素矩阵显示到屏幕上的方法 * * @param m 像素矩阵 */ void showImage(Matrix m);&#125; 具体操作系统实现类12345678910111213/** * Linux 操作系统 * * @author: fanyuzeng on 2018/1/4 15:02 */public class LinuxOS implements IOperatorSystem &#123; private static final String TAG = \"==LinuxOS==\"; @Override public void showImage(Matrix m) &#123; System.out.print(\"[showImage] \" + \"在Linux操作系统中显示像素矩阵 \"); &#125;&#125; 1234567891011121314/** * Unix 操作系统 * * @author: fanyuzeng on 2018/1/4 15:02 */public class UnixOS implements IOperatorSystem &#123; private static final String TAG = \"==UnixOS==\"; @Override public void showImage(Matrix m) &#123; System.out.print(\"[showImage] \" + \"在Unix操作系统中显示像素矩阵 \"); &#125;&#125; 123456789101112/** * Window操作系统 * @author: fanyuzeng on 2018/1/4 15:01 */public class WindowsOS implements IOperatorSystem &#123; private static final String TAG = \"==WindowsOS==\"; @Override public void showImage(Matrix m) &#123; System.out.print(\"[showImage] \" + \"在Windows操作系统中显示像素矩阵 \"); &#125;&#125; 测试类1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; Image image1=new JPGImage(); image1.setOS(new WindowsOS()); image1.praseFileIntoImage(\"e:/pic/image1\"); System.out.println(\"===============================\"); Image image2=new GIFImage(); image2.setOS(new WindowsOS()); image2.praseFileIntoImage(\"e:/pic/image2\"); System.out.println(\"===============================\"); Image image3=new BMPImage(); image3.setOS(new LinuxOS()); image3.praseFileIntoImage(\"e:/pic/image3\"); System.out.println(\"===============================\"); Image image4=new PNGImage(); image4.setOS(new UnixOS()); image4.praseFileIntoImage(\"e:/pic/image4\"); &#125;&#125; 输出12345678[showImage] 在Windows操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image1格式为:JPG===============================[showImage] 在Windows操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image2,格式为:GIF===============================[showImage] 在Linux操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image3,格式为:BMP===============================[showImage] 在Unix操作系统中显示像素矩阵 [praseFileIntoImage] e:/pic/image4,格式为:PNG 扩展假设此时又需要支持一个 tiff 格式的图片,并且还要支持 MacOS,在这种模式下只需要继续在 Image 和 IOperatorSystem 下继续扩展和实现即可,大大提升了系统的可扩展性,降低了耦合性 Demo地址https://github.com/zengfanyu/23DesignPatterns","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://zengfanyu.top/tags/Design-Patterns/"}]},{"title":"Android中的Window、WindowManager以及悬浮框视频播放的实现","slug":"FloatWindow","date":"2018-01-02T13:27:15.000Z","updated":"2018-01-06T04:15:32.416Z","comments":true,"path":"2018/01/02/FloatWindow/","link":"","permalink":"http://zengfanyu.top/2018/01/02/FloatWindow/","excerpt":"摘要:近日看公司直播项目,其中有一个功能就是退出某房间之后,直播界面会以悬浮窗的形式出现,并且可以拖动悬浮窗到界面中任意位置,点击悬浮框之后,又可以回到房间中继续观看直播。现在这个功能在主流的直播或者视频类软件中都可以看到，比如：某鱼、某猫、某珠、某牙、某tube。当然了，某tobe当中的悬浮窗效果更佳炫酷，可以炫酷地从悬浮框中将视频主界面慢慢拖动出来，具体效果下载某tube就能看到。这篇文章就记录一下传统悬浮窗播放视频的原理，以及悬浮框涉及到的 Window 和 WindowManager 的相关知识。","text":"摘要:近日看公司直播项目,其中有一个功能就是退出某房间之后,直播界面会以悬浮窗的形式出现,并且可以拖动悬浮窗到界面中任意位置,点击悬浮框之后,又可以回到房间中继续观看直播。现在这个功能在主流的直播或者视频类软件中都可以看到，比如：某鱼、某猫、某珠、某牙、某tube。当然了，某tobe当中的悬浮窗效果更佳炫酷，可以炫酷地从悬浮框中将视频主界面慢慢拖动出来，具体效果下载某tube就能看到。这篇文章就记录一下传统悬浮窗播放视频的原理，以及悬浮框涉及到的 Window 和 WindowManager 的相关知识。 Window 和 WindowManager 概述Window 表示一个窗口的概念，在日常开发中直接接触到 Window 的机会并不多，但是在某些特殊的时候，我们需要在桌面上显示一个类似悬浮框的东西（360的小火箭、360手机助手最新版当中桌面上显示的枫叶），那么这种效果就需要用 Window 来实现。Window 是一个抽象类，它的具体实现类是 PhoneWindow，创建一个 Window 跟简单，只需通过 WindowManager 即可完成。WindowManager 是完结访问 Window 的入口，Window 的具体实现位于 WindowManagerService 中，WindowManager 和 Window 打交道是一个 IPC 过程。Android 中的所有视图都是通过 Window 来呈现的，不管是 Activity 、 Dialog 还是 Toast，他们的实际视图都是附加在 Window 上的，因此，Window 实际是 View 的直接管理者。比如说，在事件分发的过程中，点击事件首先是由 Window 传递给 DecorView，然后再由 DecorView 往子 View 分发，最终分发到能够消耗这个点击事件的 View 当中；并且 Activity 生命周期方法 onCreate 中经常调用的 setContentView 方法底层也是通过 Window 来完成的。 创建一个 Window上面概述中提到，要想创建一个 Window ，只需通过 WindowManager 即可实现。 12345678910111213public void addWindow()&#123; Button button = new Button(getApplicationContext()); button.setText(\"动态添加\"); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; layoutParams.gravity = Gravity.LEFT | Gravity.TOP; layoutParams.x= 600; layoutParams.y= 600; getWindowManager().addView(button, layoutParams); &#125; 上面的代码就将一个 Button 添加到屏幕上 （600,600） 的位置，对 WindowMnager.Layoutparams 常用参数做说明： 12public LayoutParams(int w, int h, int xpos, int ypos, int _type,int _flags, int _format) &#123; w ,h 表示 Window 的宽高，可以通过构造方法传入，也可以在创建好 WindowManager.Layoutparams 之后，直接给其 width ，height 成员变量赋值。 xpos，ypos 表示 Window 在手机屏幕上的绝对位置，与 w，h 一样，这两个值也可以在实例化 WindowManager.Layoutparams 之后给 x，y 成员变量属性赋值，要向更改悬浮窗的位置，就是改变的这两个参数 _type 表示的是 Window 的类型，Window 有三种类型： 应用 Window ，这个 Window 对应着一个 Activity，层级范围（1~99） 子 Window ， 不能单独存在，它需要附属在一个特定的父 Window 中，比如说 Dialog ，层级范围（1000~1999） 系统 Window ，这是需要申明权限才能够创建的 Window， 比如说常用的 Toast ,层级范围（2000~2999）。 TYPE_SYSTEM_OVERLAY（2006），TYPE_TOAST（2005），TYPE_PHONE（2002） Flags 参数表示 Window 的属性，它可以有很多选项，通过这些选项可以控制 Window 的显示特性，比较常用的有： 1. FLAG_NOT_FOCUSABLE 表示 Window 不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用 FLAG_NOT_TOUCH_MODE，事件会直接传递给下层的具有焦点的 Window。 2. FLAG_NOT_TOUCH_MODE 此模式下,系统会将当前 Window 区域以外的点击事件传递给底层的 Window ，当前 Window 区域以内的会自己处理，一般来说这个标记都需要开启，不然其他的 Window 接收不到单击事件。 3. FLAG_SHOW_WHEN_LOCKED 让 Window 显示在锁屏界面上。 WindowManager 常用的方法就三个：添加 View，删除 View，更新 View 。这三个方法定义在 ViewManager 中，WindowManager 继承了 ViewManager。想做悬浮窗播放视频，就需要用到这三个方法，其中悬浮框随手指拖拽而移动就是在 onTouchEvent 回调中调用 updateView 的方法。 123456789101112public interface ViewManager&#123; public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params); public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params); public void removeView(View view);&#125; 悬浮框实现要点 WindowManager 和 Window 相关，用于展示悬浮框。 要实现悬浮框，那么就会涉及到权限问题，从 Andtoid 6.0 开始，需要在运行时去获取悬浮窗的权限。 启动悬浮窗的组件（Activity 或者 Fragment or else）在启动了悬浮窗之后，自己本身肯定是要关闭的，所以这里悬浮框就很适合在 Service 中管理。 悬浮窗一般是可以与用户交互的，那么这里就会涉及到触摸反馈。 后续代码前提 播放器播放需要一个 m3u8 url,公司自研播放器代码不贴出。 当前 WatchVideoActivity 正在全屏播放，此时点击了“悬浮窗播放”按钮。 这里的悬浮窗播放指的是点播,非直播情况 清单文件中的权限12&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt; 检查权限并启动Service1234567891011121314151617181920212223//悬浮窗播放按钮 final Button button_litter_player = (Button) findViewById(R.id.button_litter_player); button_litter_player.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //此处为检查用户是否已经授权我们的应用悬浮窗权限 boolean check = ConstInfo.hasPermissionFloatWin(getApplicationContext()); if (!check) &#123; Toast.makeText(getApplication(), \"悬浮窗权限未打开，请去打开应用悬浮窗权限\", Toast.LENGTH_SHORT).show(); &#125; else &#123; //FloatWindowService 就是用于管理悬浮窗的 Service Intent intent = new Intent(WatchVideoActivity.this, FloatWindowService.class); Bundle bundle = new Bundle(); //当前播放视频的m3u8地址 bundle.putString(\"m3u8Url\", getCurrentUrl()); //主要是记录当前播放的位置,这样在悬浮窗出现后,可以接着之前全屏播放的点继续播放 bundle.putInt(EXTRA_VIDEO_CURRENT_POSITION, mVideoView.getCurrentPosition()); finish(); &#125; &#125; &#125;); 其中检查权限的方法是发射调用: 1234567891011121314151617181920212223242526/** * 判断是否开启浮窗权限,api未公开，使用反射调用 * @return */public static boolean hasPermissionFloatWin(Context context) &#123; Log.d(ConstInfo.TAG, \"hasAuthorFloatWin android.os.Build.VERSION.SDK_INT=\"+android.os.Build.VERSION.SDK_INT); if (android.os.Build.VERSION.SDK_INT &lt; 19) &#123; return true; &#125; try &#123; AppOpsManager appOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); Class c = appOps.getClass(); Class[] cArg = new Class[3]; cArg[0] = int.class; cArg[1] = int.class; cArg[2] = String.class; Method lMethod = c.getDeclaredMethod(\"checkOp\", cArg); //24是浮窗权限的标记 return (AppOpsManager.MODE_ALLOWED == (Integer) lMethod.invoke(appOps, 24, Binder.getCallingUid(), context.getPackageName())); &#125;catch(Exception e)&#123; return false; &#125;&#125; FloatWindowService Service 详情戳 Android Developer # Service Guide Service 的 onCreate 方法只会在 Service 首次创建的时候调用一次,所以在这个方法中创建悬浮框的实例比较适合,因为只支持一个悬浮窗 onStartCommond 方法在每次调用 startService 方法时都会调用,所以在这个方法中适合检查悬浮窗的状态,比如:是否需要退出悬浮窗,还是直接开始在悬浮窗中继续播放等等. onDestroy 方法中就直接销毁悬浮窗实例即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class FloatWindowService extends Service &#123; private static final String TAG = \"==FloatWindowService==\"; public static final String ACTION_PLAY = \"com.xxxx.testxxxsdk.FloatWindowService.ACTION_PLAY\"; public static final String ACTION_EXIT = \"com.xxxx.testxxxsdk.FloatWindowService.ACTION_EXIT\"; public static final String PLAY_TYPE = \"com.xxxx.testxxxsdk.FloatWindowService.PLAY_TYPE\"; public static final String EXTRA_VIDEO_LIST = \"list\"; //用于标记当前悬浮窗时候已经显示 public static boolean mIsFloatWindowShown = false; //悬浮窗实例 private FloatWindow mFloatWindow; @Override public void onCreate() &#123; super.onCreate(); LogUtil.d(TAG,\"[onCreate] \" + \"FloatWindowService onCreate\"); //这里将Service本身传入悬浮窗,是为了实现点击悬浮窗重新进入WatchVideoActivity 全屏播放,且提供 Context, mFloatWindow = new FloatWindow(this); mFloatWindow.createFloatView(); mIsFloatWindowShown = true; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; LogUtil.d(TAG, \"[onStartCommand] \" + \"FloatWindowService onStart\"); //此处为特殊逻辑处理,和项目需求相关,不做解释 if (intent.hasExtra(ACTION_EXIT)) &#123; stopSelf(); &#125; else &#123; //在这里就拿到之前点击悬浮窗按钮时传递过来的数据,包括播放m3u8地址和当前播放位置等 Bundle bundle = intent.getBundleExtra(ACTION_PLAY); if (bundle != null &amp;&amp; mFloatWindow != null) &#123; LogUtil.d(TAG,\"[onStartCommand] \" + \"FloatWindowService onStart play bundle\"); //将bundle数据交给悬浮窗控件本身去处理 mFloatWindow.play(bundle); &#125; &#125; return START_STICKY; &#125; @Override public void onDestroy() &#123; super.onDestroy(); LogUtil.d(TAG,\"[onDestroy] \" +\"FloatWindowService onDestroy\" ); if (mFloatWindow != null) &#123; mFloatWindow.destroy(); &#125; mIsFloatWindowShown = false; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 上述代码可以看到,Service 在这里就是管理了悬浮窗的生命周期,以及传递数据的作用. FloatWindow这是悬浮窗的实现类,之前的代码在”悬浮播放”这一功能来说,都是铺垫. 参照文章前面对 WindowManager 的描述,这里肯定也会涉及到悬浮窗参数和悬浮窗布局,以及悬浮窗的交互. 首先是布局,这列悬浮窗比较简单 top_window_player: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout android:id=\"@+id/root_view\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@drawable/top_window_player_bg\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:padding=\"10dp\" android:src=\"@drawable/logo\" /&gt; &lt;ProgressBar android:id=\"@+id/progressbar_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:indeterminateDrawable=\"@anim/loading_anim\" android:visibility=\"gone\" /&gt; &lt;com.xxxxxx.xxxsdk.XXXVideoView android:id=\"@+id/live_player_videoview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_centerInParent=\"true\" android:visibility=\"gone\"/&gt; &lt;ImageButton android:id=\"@+id/lsq_closeButton\" android:layout_width=\"20dp\" android:layout_height=\"20dp\" android:layout_alignParentRight=\"true\" android:background=\"@drawable/close_small\" android:paddingRight=\"5dp\" android:paddingTop=\"5dp\"/&gt;&lt;/RelativeLayout&gt; ImageView 是用于展示默认状态图,ImageButton 为右上角叉叉,XXXVideoView 为自研的播放器,这里就不贴出代码了. 构造方法 这里将 Service 本身传入悬浮窗,是为了实现点击悬浮窗重新进入 WatchVideoActivity 全屏播放, 提供 Context 绑定两者生命周期,即悬浮窗销毁时,服务就要停止 123456public FloatWindow(Service hostService)&#123; mHostService = hostService; mAppContext = mHostService.getApplication();&#125; createFloatView() 真正创建 Window 的方法 这个方法中做 3 件事 : 使用 WindowManager 创建 Window 布局控件初始化 触摸反馈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 public void createFloatView() &#123; wmParams = new WindowManager.LayoutParams(); mWindowManager = (WindowManager) mAppContext.getSystemService(mAppContext.WINDOW_SERVICE); //即使应用退出,悬浮窗也可以可以再桌面当中显示 wmParams.type = WindowManager.LayoutParams.TYPE_PHONE; wmParams.format = PixelFormat.RGBA_8888; //悬浮窗需要自己处理点击事件 wmParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; //初始位置在屏幕左边的中间 wmParams.gravity = Gravity.LEFT | Gravity.CENTER_VERTICAL;// 悬浮窗的宽为手机屏幕宽度的三分之一, 4:3 高宽比 wmParams.width = TestApplication.SCREEN_WIDTH / 3; wmParams.height = (wmParams.width / 3) * 4; //Service中的Context LayoutInflater inflater = LayoutInflater.from(mAppContext); mFloatLayout = (RelativeLayout) inflater.inflate(R.layout.top_window_player, null); mWindowManager.addView(mFloatLayout, wmParams); progressbar_loading = (ProgressBar) mFloatLayout.findViewById(R.id.progressbar_loading); ImageButton closebutton = (ImageButton) mFloatLayout.findViewById(R.id.lsq_closeButton); closebutton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mHostService.stopSelf(); &#125; &#125;); // 设置悬浮窗的Touch监听 mFloatLayout.setOnTouchListener(new View.OnTouchListener() &#123; int lastX, lastY; int paramX, paramY; public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: //手指按下的位置 lastX = (int) event.getRawX(); lastY = (int) event.getRawY(); //记录手指按下时,悬浮窗的位置 paramX = wmParams.x; paramY = wmParams.y; break; case MotionEvent.ACTION_MOVE: int dx = (int) event.getRawX() - lastX; int dy = (int) event.getRawY() - lastY; wmParams.x = paramX + dx; wmParams.y = paramY + dy; // 更新悬浮窗位置 mWindowManager.updateViewLayout(mFloatLayout, wmParams); break; case MotionEvent.ACTION_UP: //当手指按下的位置和手指抬起来的位置距离小于5像素时,将此次触摸归结为点击事件, if (Math.abs(event.getRawX() - lastX) &lt; 5 &amp;&amp; Math.abs(event.getRawY() - lastY) &lt; 5) mFloatLayout.callOnClick(); break; &#125; return true; &#125; &#125;); //设置悬浮窗的点击监听 mFloatLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击悬浮窗重新跳转回 WatchVideoActivity 全屏播放 Intent intent = new Intent(mHostService.getApplicationContext(), WatchVideoActivity.class); //同理播放器在WatchVideoActivity 中全屏播放也是需要播放地址和 悬浮窗已经播放到的无照顾 intent.putExtra(\"m3u8Url\", mUrl); intent.putExtra(EXTRA_VIDEO_CURRENT_POSITION, mVideoView.getCurrentPosition()); //Service 中启动 Activity intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mHostService.startActivity(intent); //销毁服务 mHostService.stopSelf(); &#125; &#125;); mVideoView = (XXXVideoView) mFloatLayout.findViewById(R.id.live_player_videoview); //初始化播放器 mVideoView.initialize(); //监听播放器 播放器相关不贴出代码 mVideoView.setListener(mVideoListener); &#125; 开始播放的方法 1234567891011121314public void play(Bundle param) &#123; mBundleParam = param; if (mBundleParam == null) return; //拿到从 WatchVideoActivity 中传递过来的 播放地址 mUrl = mBundleParam.getString(\"m3u8Url\"); //拿到从 WatchVideoActivity 中传递过来的当前播放位置,以便继续播放 mCurrPositionFromWatchVod = mBundleParam.getInt(WatchVideoActivity.EXTRA_VIDEO_CURRENT_POSITION, -1); //播放器相关,省略部分代码 stop_play(); start_play();&#125; 效果 相关知识点学习资料 Android 悬浮窗参数权限的小结,这篇文章写得时间较早,其中有点内容在我测试机 红米Note 4X 当中并没有办法验证,索性,还是需要向用户申请悬浮窗权限. Service 官方文档 运行时权限官方文档 , 鸿洋大神—— Android 6.0 运行时权限处理完全解析 Android 带你彻底理解 Window 和 WindowManager , 《Android 开发艺术探索》 08-理解Window和WindowManager抄书系列","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"}]},{"title":"Android---View的工作流程","slug":"View work process","date":"2017-11-24T16:37:15.000Z","updated":"2017-11-25T05:35:12.790Z","comments":true,"path":"2017/11/25/View work process/","link":"","permalink":"http://zengfanyu.top/2017/11/25/View work process/","excerpt":"摘要：一直关注 Hencoder 的教程，前阵子刚好出了一期 View 的工作流程系列，然后结合《Android开发艺术探索》相关章节，做一下笔记。","text":"摘要：一直关注 Hencoder 的教程，前阵子刚好出了一期 View 的工作流程系列，然后结合《Android开发艺术探索》相关章节，做一下笔记。 MeasureSpec在很大程度上，MeasureSpec 决定了一个 View 的尺寸，作所以说“很大程度上”，是因为这个过程还会受到父容器的影响，因为父容器会硬性 View 的 MeasureSpec 的创建过程。在测量过程中，系统会将 View 的 LayoutParams 根据父容器施加的规则转换成 MeasureSpec，然后再根据这个 MeasureSpec 来测量出 View 的宽高。 MeasureSpec 是一个 32 位的 int 值，高 2 位代表SpecMode，低30位代表SpecSize。 SpecMode：测量模式 SpecSize：在某一测量模式下的规格大小1234567891011121314151617181920 public static class MeasureSpec &#123; ...public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125; public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; &#125; ... MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存，为了方便操作，其提供了打包和解包的方法。 SpecMode有三类， UNSPECIFIED 父容器不对 View 有任何显示，要多大给多大，这种模式一般是用于系统内部绘制。 EXACTLY 对应于 LayoutParams 的 match_content 和具体数值两种情况。表示父容器已经检测出 View 所需要的精确大小，这个大小由 SpecSize 给出。 AT_MOST 对用于 LayoutParams 中的 wrap_content 模式。表示父容器制定了一个可用大小，即 SpecSize，View的大小不能大于这个值，具体是多少要看不同View的具体实现。 MeasureSpec 和 LayoutParams 的对应关系在View 测量的时候，系统会将 View 的 LayoutParams 参数在父容器的约束之下转换成MeasureSpec，然后根据这个 MeasureSpec 来决定 View 测量后的宽高。什么叫做父容器的约束呢？也就父容器的 MeasureSpec，所以对于普通 View 来说，其 MeasureSpec 就是由父容器的MeasureSpec 和其自身的 LayoutParams 共同决定的。 上面说的是一个总结，这个总结，体现在ViewGroup的getChildMeasureSpec()方法中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @param spec The requirements for this view * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 这个方法看上去这么长，其实总结起来就是上面那句话：View 的 LayoutParams 参数在父容器的约束之下转换成 MeasureSpec。 这个方法是在 measureChildWithMargins() 方法中会调用： 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 在第 7 行可以看到，调用了 getChildMeasureSpec 方法，这个方法传入的第一个参数是parentWidthMeasureSpec，第三个参数是lp.width，这就充分说明上面的总结：一个 View 的MeasureSpec和其本身的LayoutParams和父容器的 MeasureSpec 相关。 最后一行，是拿到 View 的 MeasureSpecHeight 和 MeasureSpecWidth 值，去调用View的measure 方法，View 的 measure 方法放在下一节。 这么说起来，还是有点模糊，总结如下（也就是 getChildMeasureSpec 方法的表格呈现形式）： 其中 parentSize 指的是父容器中当前可用的大小 按子View的LayoutParams总结如下： 当View采用固定宽高的时候，无论父容器的SpecMode是什么，View的SpecMode都是EXACTLY，SpecSize遵循LayoutParams中的大小。 当View采用match_parent时，如果父容器的SpecMode是EXACTLY，那么View的SpecMode也是EXACTLY，SpecSize是父容器的剩余空间；如果父容器的SpecMode是AT_MOST，那么View的SpecMode也是AT_MOST，并且SpecMode不会超过父容器的剩余空间。 当View采用wrap_content时，无论父容器的SpecMode是什么，View的SpecMode都是AT_MOST，SpecSize不得超过父容器的剩余空间。 View的工作流程View的工作流程主要包括measure、layout、draw三个，即测量布局和绘制，其中measure确定View的测量宽高，layout确定View的最终宽高和四个顶点的位置，而draw将View绘制到屏幕上。 measure过程measure() 方法被父 View 调用，在 measure() 中做一些准备和优化工作后，调用 onMeasure() 来进行实际的自我测量。 onMeasure() 做的事，View 和 ViewGroup 不一样： View：View 在 onMeasure() 中会计算出自己的尺寸然后保存； ViewGroup：ViewGroup 在 onMeasure() 中会调用所有子 View 的 measure() 让它们进行自我测量，并根据子 View 计算出的期望尺寸来计算出它们的实际尺寸和位置（实际上 99.99% 的父 View 都会使用子 View 给出的期望尺寸来作为实际尺寸）然后保存。同时，它也会根据子 View 的尺寸和位置来计算出自己的尺寸然后保存； 那么久针对 View 和 ViewGroup 这两种情况分析了。 View 的 measure 过程View 的 measure 过程是由其 measure 方法完成的，在这个方法中又会去调用 onMeasure 方法，onMeasure实现： 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 就是调用了一个 setMeasureDimension 方法，将 View 的宽高传递进去，这个方法在自定义 View 的时候经常用到，就是在确定了自定义 View 的宽高值之后，在 onMeasure 方法中最后调用的，用于确定自定义 View 的测量宽高。 这里对宽高传入的都是 getDefaultSize() 函数的返回值，那么久看看这个函数： 1234567891011121314151617public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 就是根据 specMode 的不同值，返回不同的大小，当 AT_MOST 和 EXACTLY 模式下，就是返回 specSize 的值，也就是 View 测量后的大小。 在 UNSPECIFIED 模式下，View 的大小就是 getDefaultSize 方法的第一个参数 size ，即宽高分别为 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 这两个函数的返回值。在看下这两个函数(只贴出width的代码)： 1234protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 若 View 没有指定背景，那么 View 的宽度为 mMinWidth ，这个值是由 View 的 android:minWidth 属性指定的，若没有指定这个属性，那么这个 mMinWidth 为 0。 若 View 指定了背景，那么 View 的宽度就是 mMinWidth 和 mBackground.getMinimumWidth() 两者中较大的一个。前者上面已经说了是什么，那么后者又是什么东西呢？mBackground 是一个 Drawable，那么点进 Drawable 里面去看就知道了： 12345public int getMinimumWidth() &#123; final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;&#125; getMinimumWidth 返回的就是 Drawable 的原始高度，前提是这个 Drawable 有原始高度，不然就返回0； ViewGroup 的 measure 过程ViewGroup 是一个抽象类，因此他没有重写 View 的 onMeasure 方法，它提供了一个 measureChildren 方法： 1234567891011 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 这个方法就是调用 ViewGroup 的所有子 View 的 measureChild 方法，这个 measureChild方法如下： 123456789101112protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 就是拿到子 View 的 LayoutParams ，然后通过 getChildMeasureSpec 方法生成子 View 的 MeasureSpec，接着就将生成的 MeasureSpec 直接传递给子 View 的 measure 方法进行测量。 getChildMeasureSpec 的逻辑上述已经说明。 可以发现 ViewGroup 并没有定义其本身具体的测量过程，因为 ViewGroup 是一个抽象类， onMeasure 需要各个具体的子类去实现，不想 View 一样，对 onMeasure 方法做具体实现，是因为不同的 ViewGroup 的实现类，有不同的布局特性，这导致他们的测量细节各不相同，比如 LinearLayout 和 RelativeLayout 两者的布局特性显然不同。 layout 过程 layout 方法确定 View 本身的位置 onLayout 方法确定子 View 的位置 layout 的作用是 ViewGroup 用于确定子 View 的位置，当 ViewGroup 的位置确定了之后，它会在 onLayout 中遍历所有子 View ，并且调用其 layout 方法，而在子 View 的 layout 方法中，onLayout 方法又会被调用，先看 View 的layout 方法： 123456789101112131415161718192021222324252627282930public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; ...&#125; 14 行调用了 setFrame 方法，这个方法就是用于确定 View 的四个顶点的位置，一旦四个顶点确定了，那么 View 在 ViewGroup 中的位置也就确定了。贴出 setFrame 中的一段代码，稍后用于说明问题。 123456789protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; ...&#125; 17 行，会调用 onLayout 方法，这个方法的用途是父容器确定子 View 的位置，和 onMeasure 方法类似，onLayout 的实现和具体的布局相关，所以 View 和 ViewGroup 都没有实现这个方法。看看 LinearLayout 中的 onLayout 方法： 123456789@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 这里分为竖直方向上的 layout 和水平方向上的 layout，这里看看 竖直方向上的： 123456789101112131415161718192021222324252627282930void layoutVertical(int left, int top, int right, int bottom) &#123; final int count = getVirtualChildCount(); for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); ... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125;&#125; 首先遍历竖直方向上的所有子 View ，并且调用 setChildFrame 方法来为子 View 确定位置 注意 childTop 值会逐渐增加，这个增量包括分割线宽度、margin 值、childHeight，这样一来，在竖直方向上就符合 LinearLayout 的特性了。 接下来看看 setChildFrame 方法： 1234private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; 就是直接调用子 View 的 layout 方法，这样 LinearLayout 是父容器，父容器在 layout 中完成自己的定位之后，就通过 onLayout 去调用子 View 的 layout 方法，让子 View 完成其对自身的 layout 过程，然后在子 View 的 layout 方法中，又会通过 onLayout 方法去调用下一级子 View 的 layout 方法… 这样一层一层的传递下去之后，就会遍历完整个 View 树。 测量宽高和最终宽高的区别这个问题可以具体为：getMeasureWidth/height 和 getWidth/height 有什么区别。 前者很明显，就是 measure 过程中得到的宽高，那么重点在后者，先看看 View 中的 getWidth 方法： 1234public final int getWidth() &#123; return mRight - mLeft;&#125; 现在就是要搞清楚 mRight 和 mLeft 两个变量是在什么时候赋值的。 还是看看 LinearLayout 的竖直方向的 layout 过程，也就是上面的 layoutVertical 方法，在第 9、10 行可以看到： 123final int childWidth = child.getMeasuredWidth();final int childHeight = child.getMeasuredHeight(); 然后在 22 行的 setChildFrame 方法，将 childWidth 和 childHeight 作为参数传入， 123setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); 然后在 setChildFrame 中会去调用子 View 的 layout 方法，继续讲参数传递 12child.layout(left, top, left + width, top + height); 在 View 的 layout 方法中会调用 setFrame(l, t, r, b)，这里的 l、t、r、b 和上面的参数对应，在 setFrame 中： 123456789protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; ...&#125; 这段代码之前提到过，在这里，就将 mLeft mTop mRight mBottom 给赋值了，这个值就是在 LinearLayout 中通过 getMeasureWidth 和 getMeasureHeight 方法得到的。 现在可以知道区别了在 View 的默认实现中，View 的测量宽高和最终宽高是相等的，只是两者的赋值时机不同，测量宽高形成于View 的 measure 过程，而最终宽高形成于View 的 layout 过程，在日常开发中，就可以认为 View 的测量宽高就等于 View 的最终宽高。 一个好习惯就是：在 onLayout 方法中去拿 View 的测量宽高或者是最终宽高，因为在某些极端的情况下，系统需要经过多次的 measure 才能确定最终的宽高，这种情况下，在 onMeasure 方法中拿到的测量宽高可能是不准确的。 draw 过程一个完整的绘制过程会依次绘制以下几个内容： 背景 主体（onDraw()） 子 View（dispatchDraw()） 滑动边缘渐变和滑动条 前景 一般来说，一个 View（或 ViewGroup）的绘制不会这几项全都包含，但必然逃不出这几项，并且一定会严格遵守这个顺序。例如通常一个 LinearLayout 只有背景和子 View，那么它会先绘制背景再绘制子 View；一个 ImageView 有主体，有可能会再加上一层半透明的前景作为遮罩，那么它的前景也会在主体之后进行绘制。需要注意，前景的支持是在 Android 6.0（也就是 API 23）才加入的；之前其实也有，不过只支持 FrameLayout，而直到 6.0 才把这个支持放进了 View 类里。 绘制背景它的绘制发生在一个叫 drawBackground() 的方法里，但这个方法是 private 的，不能重写，你如果要设置背景，只能用自带的 API 去设置（xml 布局文件的 android:background 属性以及 Java 代码的 View.setBackgroundXxx() 方法），而不能自定义绘制 绘制主体这个过程是在 onDraw 方法中执行的，但是在 View 中，这个方法是没有实现的，因为具体的 View 需要如何绘制，需要 View 的子类去具体的定制。所以当我们自定义 View 的绘制的时候，就就可以直接重写 onDraw 方法。 123456789101112public class AppView extends View &#123; ... protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... // 自定义绘制代码 &#125; ...&#125; 这里注意，是将自定义绘制的代码写在 super 的下面，不过这里写在 super 的上面和下面其实都是一样的， 因为上面提到，View 的这个方法是一个空实现，所以。 下面来讨论自定义 View 的绘制方法时，自定义的代码写在 super 上下的区别。 写在 super.onDraw() 的下面把绘制代码写在 super.onDraw() 的下面，由于绘制代码会在原有内容绘制结束之后才执行，所以绘制内容就会盖住控件原来的内容。这是最为常见的情况：为控件增加点缀性内容。比如，在 Debug 模式下绘制出 ImageView 的图像尺寸信息： 写在 super.onDraw() 的上面如果把绘制代码写在 super.onDraw() 的上面，由于绘制代码会执行在原有内容的绘制之前，所以绘制的内容会被控件的原内容盖住。 这种方式可以实现马克笔的效果： 绘制子 View有部分的遮盖关系是无法通过 onDraw 方法来实现的，例如，你继承了一个 LinearLayout，重写了它的 onDraw() 方法，在 super.onDraw() 中插入了你自己的绘制代码，使它能够在内部绘制一些斑点作为点缀： 12345678910public class SpottedLinearLayout extends LinearLayout &#123; ... protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); ... // 绘制斑点 &#125;&#125; 没毛病。 但是当添加了子 View 之后， 12345678910&lt;SpottedLinearLayout android:orientation=\"vertical\" ... &gt; &lt;ImageView ... /&gt; &lt;TextView ... /&gt;&lt;/SpottedLinearLayout&gt; 造成这种情况的原因是 Android 的绘制顺序：在绘制过程中，每一个 ViewGroup 会先调用自己的 onDraw() 来绘制完自己的主体之后再去绘制它的子 View。对于上面这个例子来说，就是你的 LinearLayout 会在绘制完斑点后再去绘制它的子 View。那么在子 View 绘制完成之后，先前绘制的斑点就被子 View 盖住了。 具体来讲，这里说的「绘制子 View」是通过另一个绘制方法的调用来发生的，这个绘制方法叫做：dispatchDraw()。也就是说，在绘制过程中，每个 View 和 ViewGroup 都会先调用 onDraw() 方法来绘制主体，再调用 dispatchDraw() 方法来绘制子 View。 注：虽然 View 和 ViewGroup 都有 dispatchDraw() 方法，不过由于 View 是没有子 View 的，所以一般来说 dispatchDraw() 这个方法只对 ViewGroup（以及它的子类）有意义。 回到刚才的问题：怎样才能让 LinearLayout 的绘制内容盖住子 View 呢？只要让它的绘制代码在子 View 的绘制之后再执行就好了。 写在 super.dispatchDraw() 的下面只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。 1234567891011public class SpottedLinearLayout extends LinearLayout &#123; ... // 把 onDraw() 换成了 dispatchDraw() protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); ... // 绘制斑点 &#125;&#125; 写在 super.dispatchDraw() 的上面同理，把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间。而这个…… 其实和前面讲的，重写 onDraw() 并把绘制代码写在 super.onDraw() 之后的做法，效果是一样的。 onDrawForeground()滑动边缘渐变和滑动条以及前景，这两部分被合在一起放在了 onDrawForeground() 方法里，这个方法是可以重写的。 滑动边缘渐变和滑动条可以通过 xml 的 android:scrollbarXXX 系列属性或 Java 代码的 View.setXXXScrollbarXXX() 系列方法来设置；前景可以通过 xml 的 android:foreground 属性或 Java 代码的 View.setForeground() 方法来设置。而重写 onDrawForeground() 方法，并在它的 super.onDrawForeground() 方法的上面或下面插入绘制代码，则可以控制绘制内容和滑动边缘渐变、滑动条以及前景的遮盖关系。 写在 super.onDrawForeground() 的下面如果你把绘制代码写在了 super.onDrawForeground() 的下面，绘制代码会在滑动边缘渐变、滑动条和前景之后被执行，那么绘制内容将会盖住滑动边缘渐变、滑动条和前景。 123456789101112131415public class AppImageView extends ImageView &#123; ... public void onDrawForeground(Canvas canvas) &#123; super.onDrawForeground(canvas); ... // 绘制「New」标签 &#125;&#125;&lt;!-- 使用半透明的黑色作为前景，这是一种很常见的处理 --&gt; &lt;AppImageView ... android:foreground=\"#88000000\" /&gt; 左上角的标签没有被前景遮盖住，而是保持了它本身的颜色 写在 super.onDrawForeground() 的上面如果你把绘制代码写在了 super.onDrawForeground() 的上面，绘制内容就会在 dispatchDraw() 和 super.onDrawForeground() 之间执行，那么绘制内容会盖住子 View，但被滑动边缘渐变、滑动条以及前景盖住： 12345678910public class AppImageView extends ImageView &#123; ... public void onDrawForeground(Canvas canvas) &#123; ... // 绘制「New」标签 super.onDrawForeground(canvas); &#125;&#125; 由于被黑色的前景给遮住了，这里看到的标签也是这种半透明的黑色 想在滑动边缘渐变、滑动条和前景之间插入绘制代码？很简单：不行。 虽然这三部分是依次绘制的，但它们被一起写进了 onDrawForeground() 方法里，所以你要么把绘制内容插在它们之前，要么把绘制内容插在它们之后。而想往它们之间插入绘制，是做不到的。 draw() 总调度的方法除了 onDraw() dispatchDraw() 和 onDrawForeground() 之外，还有一个可以用来实现自定义绘制的方法： draw()。 draw() 是绘制过程的总调度方法。一个 View 的整个绘制过程都发生在 draw() 方法里。前面讲到的背景、主体、子 View 、滑动相关以及前景的绘制，它们其实都是在 draw() 方法里的。 12345678910111213// View.java 的 draw() 方法的简化版大致结构（是大致结构，不是源码哦）：public void draw(Canvas canvas) &#123; ... drawBackground(Canvas); // 绘制背景（不能重写） onDraw(Canvas); // 绘制主体 dispatchDraw(Canvas); // 绘制子 View onDrawForeground(Canvas); // 绘制滑动相关和前景 ...&#125; 从上面的代码可以看出，onDraw() dispatchDraw() onDrawForeground() 这三个方法在 draw() 中被依次调用，因此它们的遮盖关系也就像前面所说的——dispatchDraw() 绘制的内容盖住 onDraw() 绘制的内容；onDrawForeground() 绘制的内容盖住 dispatchDraw() 绘制的内容。而在它们的外部，则是由 draw() 这个方法作为总的调度。所以，你也可以重写 draw() 方法来做自定义的绘制。 写在 super.draw() 的下面由于 draw() 是总调度方法，所以如果把绘制代码写在 super.draw() 的下面，那么这段代码会在其他所有绘制完成之后再执行，也就是说，它的绘制内容会盖住其他的所有绘制内容。 它的效果和重写 onDrawForeground()，并把绘制代码写在 super.onDrawForeground() 下面时的效果是一样的：都会盖住其他的所有内容。 当然了，虽说它们效果一样，但如果你既重写 draw() 又重写 onDrawForeground() ，那么 draw() 里的内容还是会盖住 onDrawForeground() 里的内容的。所以严格来讲，它们的效果还是有一点点不一样的。 但这属于抬杠…… 写在 super.draw() 的上面同理，由于 draw() 是总调度方法，所以如果把绘制代码写在 super.draw() 的上面，那么这段代码会在其他所有绘制之前被执行，所以这部分绘制内容会被其他所有的内容盖住，包括背景。是的，背景也会盖住它。 是不是觉得没用？觉得怎么可能会有谁想要在背景的下面绘制内容？别这么想，有的时候它还真的有用。 例如我有一个 EditText： 它下面的那条横线，是 EditText 的背景。所以如果我想给这个 EditText 加一个绿色的底，我不能使用给它设置绿色背景色的方式，因为这就相当于是把它的背景替换掉，从而会导致下面的那条横线消失： 1234&lt;EditText ... android:background=\"#66BB6A\" /&gt; 在这种时候，你就可以重写它的 draw() 方法，然后在 super.draw() 的上方插入代码，以此来在所有内容的底部涂上一片绿色： 12345678910public AppEditText extends EditText &#123; ... public void draw(Canvas canvas) &#123; canvas.drawColor(Color.parseColor(\"#66BB6A\")); // 涂上绿色 super.draw(canvas); &#125;&#125; ###draw 过程注意 关于绘制方法，有两点需要注意一下： 出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，你可能会需要调用 View.setWillNotDraw(false) 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。 有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。 ###draw 过程总结 另外别忘了上面提到的那两个注意事项： 在 ViewGroup 的子类中重写除 dispatchDraw() 以外的绘制方法时，可能需要调用 setWillNotDraw(false)； 在重写的方法有多个选择时，优先选择 onDraw()。 总结对 View 的绘制过程都清楚了之后，就可以进行各种自定义 View 了，Hencoder 说过，自定义 View 无非就是三个：绘制、布局、触摸反馈。 其中绘制和布局这里总结了，在这两个操作过程中会大量使用到 Paint Canvas 和 Property Animation，这些后面再做总结。 参考引用[1] 《Android 开发艺术探索》 [2] HenCoder Android 开发进阶：自定义 View 1-5 绘制顺序 实践自定义流式布局，刚好是对上面总结内容的一个很好的实践。 View 工作流程的相关实践项目","categories":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"}]},{"title":"新姿势学习之Java8---Lambda Expressions And Stream","slug":"Java8---Lambda Expressions","date":"2017-11-12T16:37:15.000Z","updated":"2018-01-06T08:33:13.392Z","comments":true,"path":"2017/11/13/Java8---Lambda Expressions/","link":"","permalink":"http://zengfanyu.top/2017/11/13/Java8---Lambda Expressions/","excerpt":"摘要: 去年逛 Github 准备秋招项目时,就发现 Android 有的项目使用的语法似乎从来没见过,类似于 (parameters)-&gt;expression 还有ObjectReference::methodName 这种类 C++ 语法形式,查找资料之后,知道这个是 Java8 的新特性:Lambda,所以就记下了 Lambda 这个词,后来忙于秋招春招实习,一直也没有取好好学习,昨天在项目当中又看到了这个熟悉的表达式,一脸懵逼,所以准备找几篇 Java8 教程,好好学习一下”新”姿势.","text":"摘要: 去年逛 Github 准备秋招项目时,就发现 Android 有的项目使用的语法似乎从来没见过,类似于 (parameters)-&gt;expression 还有ObjectReference::methodName 这种类 C++ 语法形式,查找资料之后,知道这个是 Java8 的新特性:Lambda,所以就记下了 Lambda 这个词,后来忙于秋招春招实习,一直也没有取好好学习,昨天在项目当中又看到了这个熟悉的表达式,一脸懵逼,所以准备找几篇 Java8 教程,好好学习一下”新”姿势. 分别总结 java8 中涉及到的一些名词，可能没什么条理，都是有助于理解 java8 中的新特性，特别是 Lambda 和 Stream 相关的知识，至少我是怎么认为的，哈哈~。## 为什么需要 Java8原因众多,其中最主要的原因是: 可以让多线程并行处理 Colloection 的代码变得容易编写.商业发展需要复杂的应用,更过的应用都跑在多核的 CPU 上,既然是多核,就需要保证它的并行操作,所以之前 java 中推出了 java.util.concurrent 包来解决并行的问题,但是在大数据的处理上,这些类库的层抽象级别还不够,缺乏高效的并行操作,我们需要编写复杂的集合处理算法,用于处理大数据问题,这种算法已经很难在工具层面来解决了,所以只能上升到语言层面:增加 Lambda 表达式,## Streams API标题太广泛，需要一篇文章来总结## 函数式编程标题范围太广，需要一篇文章来总结## 函数式接口简单来说，函数式接口是只包含一个方法的接口。比如 Java 标准库中的 java.lang.Runnable 和java.util.Comparator 都是典型的函数式接口。java 8 提供 @FunctionalInterface 作为注解,这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口），虚拟机会自动判断，但最好在接口上使用注解 @FunctionalInterface 进行声明，以免团队的其他人员错误地往接口中添加新的方法。这里使用一个例子来说明：12345678910111213141516171819202122232425262728293031 //定义一个函数式接口FunctionalInterfacepublic interface WorkerInterface &#123; public void doSomeWork();&#125;public class WorkerInterfaceTest &#123;public static void execute(WorkerInterface worker) &#123; worker.doSomeWork();&#125;public static void main(String [] args) &#123; //invoke doSomeWork using Annonymous class execute(new WorkerInterface() &#123; @Override public void doSomeWork() &#123; System.out.println(\"Worker invoked using Anonymous class\"); &#125; &#125;); //invoke doSomeWork using Lambda expression execute( () -&gt; System.out.println(\"Worker invoked using Lambda expression\") );&#125;&#125;## Lambda 语法 ##语法的定义比较简单:1. 一个括号内,用逗号分隔的形式参数,这些个形参是函数式接口里的方法的参数2. 一个箭头符号 -&gt; 方法体,可以是表达式或者代码块,是函数式接口里面的方法的具体实现.如果是代码块,就必须要用 {} 包裹起来,且需要一个 return 返回值.但是如果函数式接口里面的方法本身的返回类型就是 void ,那么代码块是不需要用 {} 包裹,也不需要返回值的.总结起来,就是它的形式类似于: 12(parameters) -&gt; expression or (parameters) -&gt; &#123; statements; &#125; 4.方法引用.其实是 Lambda 表达式的一个简化写法，所引用的方法其实是 Lambda 表达式的方法体实现，语法也很简单，左边是容器（可以是类名，实例名），中间是 &quot;::&quot;，右边是相应的方法名。如下所示： 12ObjectReference::methodName 如果是静态方法，则是 ClassName::methodName。如 Object ::equals 如果是实例方法，则是 Instance::methodName。如 Object obj=new Object();obj::equals; 如果是构造函数 , 则是 ClassName::new 如果是接口方法 , 则是 InterfaceName::methodName.如 List::add , List::addAll Java 中的 Lambda 无法单独出现，它需要一个函数式接口来盛放， Lambda 表达式方法体其实就是函数接口的实现. Lambda 应用场景个人觉得，学习 Lambda 最好的方法，就是通过对比的方式去学，将实现某一功能使用 Lambda 表达式和不使用 Lambda 两套代码进行对比，这样记忆更加深刻，这一小节中也涉及到部分操作符的使用总结。 用 Lambda 表达式实现 Runnable1234567891011//Before java8new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"This is before java8\"); &#125;&#125;).start();//In java8 waynew Thread(() -&gt; System.out.println(\"Java8 coming!\")).start(); 使用 Lambda 表达式进行事件处理12345678910111213//Before Java8mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; System.out.println(\"Button clicked!\"); &#125; &#125;);//In java8 way mButton.setOnClickListener((v)-&gt; &#123; System.out.println(\"Button clicked!\"); &#125;); 这种方式其实跟上面对 Runnable 的操作是一样的,都是将匿名内部类使用 Lambda 来替换,唯一不同的就是,上面 Runnable 的例子里,方法是没有参数的,但是这个例子中, onClick(View view) 回调方法是有一个参数的. 此处的 Lambda 表达式用用的是 (v) ,而不是回调函数本身的 view ,是因为在 Lambda 表达式中的参数是形参,不恰当的例子:形参随便你写什么都行. 上面例子中,方法体的 {} 是可以不用的,这里是为了和上面保证格式一致,方便对比. 用 Lambda 表达式对集合进行迭代1234567891011 List&lt;String&gt; features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");//Before java8 for (String feature : features) &#123; System.out.println(feature); &#125;//In java8 way features.forEach((String feature) -&gt; System.out.println(feature)); //or features.forEach(System.out::println); 第 10 行使用的是方法引用,但是要注意:方法引用不能修改 Lambda 表达式提供的参数. 使用 Lambda 的 filter 操作12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(args[])&#123; List languages = Arrays.asList(\"Java\", \"Scala\", \"C++\", \"Haskell\", \"Lisp\"); System.out.println(\"Languages which starts with J :\"); filter(languages, (str)-&gt;str.startsWith(\"J\")); System.out.println(\"Languages which ends with a \"); filter(languages, (str)-&gt;str.endsWith(\"a\")); System.out.println(\"Print all languages :\"); filter(languages, (str)-&gt;true); System.out.println(\"Print no language : \"); filter(languages, (str)-&gt;false); System.out.println(\"Print language whose length greater than 4:\"); filter(languages, (str)-&gt;str.length() &gt; 4);&#125;public static void filter(List&lt;String&gt; names, Predicate&lt;String&gt; condition) &#123; for(String name: names) &#123; if(condition.test(name)) &#123; System.out.println(name + \" \"); &#125; &#125; &#125;//另一种写法 public static void filter(List&lt;String&gt; names, Predicate&lt;String&gt; condition) &#123; names.stream().filter((name) -&gt; (condition.test(name))) .forEach((name) -&gt; System.out.println(name + \" \")); &#125;//另另一种写法 public static void filter(List&lt;String&gt; names, Predicate&lt;String&gt; condition) &#123; names.forEach((String str) -&gt; &#123; if (condition.test(str)) &#123; System.out.println(str + \"\"); &#125; &#125;); &#125; 关于 Predicate,笔者的一些理解: 可以看到下面的 filter 方法,它接受一个类型为 Predicate 的参数,Predicate 本身是「谓语」的意思（也有翻译做「断言」的，不过我个人觉得，「谓语」更好理解，原因如下）比如:“我打你”,那么这个”打”就是谓语,很明显这是一个谓语动词,其实这个”打”是有一个返回的「结果」的,只是在语言本身的语法当中是没有关注的,比如,打到没有?打疼没有?打死没有? true or false ? 而 Predicate的描述是这样的: Represents a predicate (boolean-valued function) of one argument. ,代表一个参数的”谓语”,这个谓语是有返回值的,返回值的类型要是 boolean 的. boolean test(T t) 方法: Evaluates this predicate on the given argument ,用于返回这个参数的谓语的结果.拿上面的例子来说,调用 test(T t) 之后,如果返回的是 false ,那么表示「我没有打到你或者我没有打疼你或者我没打死你」,返回 true 表示,「我打到你了或者我打疼你了或者我打死你了」. 对应到上面代码第 5 行, Argument 「参数」指的是 languages 集合中的元素,predicate 「谓语」指的是 (str)-&gt;str.startWith(&quot;J&quot;),很明显,这个谓语是有返回值的,true 表示 languages 中的当前遍历的元素是 J 开头的,反之则不是. 再一次感叹老外命名的巧夺天工! 在 Lambda 表达式中加入 Predicate上面的例子一次只使用了一个 Predicate ,可以通过逻辑操作符,将两个或者多个 Predicate 的逻辑运算结果作为一个 Predicate. 123456Predicate&lt;String&gt; lengthFilter = (String str) -&gt; str.length() == 4;Predicate&lt;String&gt; startFilter = (String str) -&gt; str.startsWith(\"J\");languages.stream() .filter(lengthFilter.and(startFilter)) .forEach(language -&gt; System.out.printLn(language)); 第四行,的 filter 函数接收一个 Predicate 类型的参数,这个参数是由 lengthFilter 和 startFilter 的结果两经过与操作组成的, 同理 or() 是或操作, or() 是异或操作. 使用 Lambda 的 map 操作 需求:给出税前的列表,返回税后列表,税12% 12345678910111213//Before java8 List&lt;Integer&gt; costBeforeTax = Arrays.asList(100, 200, 300, 400, 500); for (Integer beforeTax : costBeforeTax) &#123; double costAfterTax = beforeTax + 0.12 * beforeTax; System.out.println(costAfterTax); &#125; //In java8 way List&lt;Integer&gt; costBeforeTaxL= Arrays.asList(100,200,300,400,500); costBeforeTaxL.stream().map(cost -&gt; cost + cost * 0.12).forEach(System.out::println); 这里用到了 map 操作符,它的作用就是:将 Input Strean 的每一个元素转换成 Output Stream 的另一个元素,这是一个 1:1 的映射. map 的定义:&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 官方给的注解是这么说的: Returns a stream consisting of the results of applying the given function to the elements of this stream.翻译成中文 : 返回由 将给定函数 Function 应用于此流的元素的结果 组成的流,那就来看看 Function 是什么咯. @FunctionalInterface public interface Function&lt;T, R&gt;{...} ,注解是 : Represents a function that accepts one argument and produces a result. 这个接口代表一个函数,这个函数接收一个参数(Input Stream),并且会产生一个结果( Output Stream ). 在看上面的例子, map 操作返回的就是将 cost+cost*0.12( Function ) 给应用到 costBeforeTaxl (Input Stream)的每一个元素( cost )之后的结果所组成的流( Output Stream ). 真是拗口… 使用 Lambda 的 reduce 操作 需求:给出税后总和 12345678910111213141516//Before java8List&lt;Integer&gt; costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double total = 0;for (Integer cost : costBeforeTax) &#123; double price = cost + .12 * cost; total = total + price;&#125;System.out.println(\"Total : \" + total);//In java8 wayList&lt;Integer&gt; costBeforeTaxL = Arrays.asList(100, 200, 300, 400, 500);double bill = costBeforeTaxL.stream().map((cost) -&gt; cost + 0.12 * cost).reduce((sum, cost) -&gt; sum + cost).get();//或者可以用 reduce 两个参数的方法,两个参数的形式,返回的就不是 Optional&lt;T&gt; 对象了, 而直接是 T 对象double bill = costBeforeTaxL.stream().map((cost) -&gt; cost + 0.12 * cost).reduce(0d,(sum, cost) -&gt; sum + cost)System.out.println(\"Total : \" + bill); 先用 map 操作符求出税后的金额,然后在用 reduce 求和. reduce 有两个重载方法,一个有起始参数,也就种子参数,一个是没有起始参数的. 一个参数定义: Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 这个方法的主要作用是把 Stream 元素组合起来。这种方式是没有起始值的,直接依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合,返回的是 Optional. 两个参数定义: T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); 其中 T identity 表示的是起始值.上面的例子传入的值是 0d ,所以输出和一个参数形式的输出结果一样,都是 1680,假设此处传入的起始值是 100 ,那么输出的结果就是 1780.accumulator：计算的「组合器」，其方法签名为 apply(T t,U u)，在该 reduce 方法中第一个参数 t为上次函数计算的返回值，第二个参数 u 为 Stream 中的元素，这个函数把这两个值计算 apply，得到的「组合」会被赋值给下次执行这个方法的第一个参数。 也就是说，有起始值的 reduce 返回的是具体的对象，没有起始值返回的是 optianal 对象，因为它可能没有返回的对象，会产生 NOE 异常。 Optional 可以简单的理解为一个容器,可能含有某值,也可能不含,使用这个类的目的是为了尽可能的避免 NullPointerException,若含有,则调用 get() 方法之后,就返回这个值,否则抛 NoSuchElementException.在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。 上面的例子，BinaryOperator 指的就是 (sum, cost) -&gt; sum + cost ，recuxe 函数返回的就是个 Optional 对象，然后我们通过 get（） 方法拿到 Optional 中含有的值。 使用 Lambda 的 Collect 操作123List&lt;Integer&gt; originalList= Arrays.asList(1,2,3,4);List&lt;Integer&gt; afterFilter = Stream.of(1,2,3,4).filter(n -&gt; n &gt; 2).collect(Collectors.toList());System.out.printf(\"Original List : %s, afterFilter list : %s %n\", originalList, afterFilter); 输出:1Original List : [1, 2, 3, 4], afterFilter list : [3, 4] collect 操作用处收集结果，当处理完一个流之后，想看一下处理后的结果，而不是将它们聚合起来，那么就可以用到 Collect 操作符。 首先是对流里面的每一个元素进行 filter 操作,谓语 x.length()&gt;2 这个表达式返回值为 true 的元素,然后对这些符合标准的元素组成的流进行 collect 操作. collect 操作也有两个重载的方法: &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner) supplier 一个能够创造目标类型实例的方法 accumulator 一个将元素添加到目标中的方法 combiner 一个将中间状态的结果整合到一起的方法注意上面三个参数都是方法. &lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector) collector 可以看到,它就是上面 supplier,accumulator,combiner 的聚合体. 将上述例子用三个参数的方法改写： 12345Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4);ArrayList&lt;Integer&gt; result = integerStream.collect(() -&gt; new ArrayList&lt;Integer&gt;(), (list, item) -&gt; list.add(item), (aList, bList) -&gt; aList.addAll(bList));//此处也可以使用方法引用//ArrayList&lt;Integer&gt; result=integerStream.collect(ArrayList::new,List::add,List::addAll);System.out.printf(\"Original List : %s, afterFilter list : %s %n\", integerStream, result); Collectors :看这个类的名字就类似于 Arrays,Executors 这两工具类，点进源码一看，这确实也是一个工具类，它里面都是静态的工厂方法，用于产生 Collector 类型的参数，toList 和 toSet 就是其中最常见的两个。而通过 Collectors 的静态工厂方法产生的 Collector 的类型由其输入类型和输出类型决定。以 toList() 为例，它的输入类型为 T ，输出类型为 List&lt;T&gt;。对应到上面的例子中，输入类型为 Integer ，所以输出的类型为 List&lt;Integer&gt; 使用 Lambda 的 distinct 操作1234567public static void main(String[] args) &#123; Stream.of(1, 2, 3, 4, 5, 6, 2, 3, 4, 2, 4, 5) .map(x -&gt; x * x) .distinct() .collect(Collectors.toList()) .forEach(n-&gt;System.out.print(n+\" \")); &#125; 输出结果为： 11 4 9 16 25 36 通过上面的例子可以看出来，distince 操作就是去重。 使用 summaryStatistics 获取几个统计值1234567891011IntSummaryStatistics intSummaryStatistics = Stream .of(1, 4, 3, 56, 7, 89, 5, 4, 6, 8, 4, 345, 76, 8) .mapToInt(value -&gt; value) .summaryStatistics(); System.out.println(\"max value is:\"+ intSummaryStatistics.getMax()); System.out.println(\"min value is:\"+ intSummaryStatistics.getMin()); System.out.println(\"the average is:\"+ intSummaryStatistics.getAverage()); System.out.println(\"the value is:\"+ intSummaryStatistics.getSum()); System.out.println(\"the count is:\"+ intSummaryStatistics.getCount()); 此方法用于返回流当中各种在摘要数据，包括最大值，最小值，平均值，和，元素个数。 summaryStatistics 方法只有 IntStream、LongStream 和 DoubleStream有。 Lambda 表达式 VS 匿名类 从上面举的例子里可以看到，Lambda 表达式用于提到匿名内部类，这两者有一个关键不同之处就是 this. 匿名类的 this 指向匿名类，而 Lambda 表达式的 this 指向包围 Lambda 表达式的类。 还有一点不同就是编译方式。Java 编译器将 Lambda 表达式是编译成类的私有方法的。 总结 Lambda 表达式仅能放入如下代码：预定义使用了 @FunctionalInterface 注释的函数式接口，自带一个抽象函数的方法，或者SAM （Single Abstract Method 单个抽象方法）类型。这些称为 Lambda 表达式的目标类型，可以用作返回类型，或 Lambda 目标代码的参数。例如，若一个方法接收 Runnable、Comparable 或者 Callable 接口，都有单个抽象方法，可以传入 Lambda 表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传 Lambda 表达式。 Lambda 表达式内可以使用方法引用，仅当该方法不修改 Lambda 表达式提供的参数。本例中的 Lambda 表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。 12list.forEach(n -&gt; System.out.println(n)); list.forEach(System.out::println); // 使用方法引用 然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地 Lambda 表达式，如下所示：1list.forEach((String s) -&gt; System.out.println(\"*\" + s + \"*\")); 事实上，可以省略这里的 Lambda 参数的类型声明，编译器可以从列表的类属性推测出来。 Lambda 内部可以使用静态、非静态和局部变量，这称为 Lambda 内的变量捕获。 Lambda 表达式在 Java 中又称为闭包或匿名函数。 Lambda 方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用 JDK 中的 javap 工具来反编译 class 文件。使用 javap -p 或 javap -c -v 命令来看一看 Lambda 表达式生成的字节码。大致应该长这样： 1private static java.lang.Object Lambda $0(java.lang.String); Lambda 表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在 Lambda 内部修改定义在域外的变量。1234List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);int factor = 2;primes.forEach(element -&gt; &#123; factor++; &#125;);Compile time error : \"local variables referenced from a `Lambda` expression must be final or effectively final\" 另外，只是访问它而不作修改是可以的，如下所示：123List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);int factor = 2;primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;); 输出：1234461014 因此，它看起来更像不可变闭包，类似于Python。 刚开始使用 Lambda 表达式的时候，会感觉特别困惑，有时不能理解这一个箭头一个参数代表的是什么，这种写法引用的是哪个接口的回调方法，这个回调方法的实现是什么，但是会出现这种情况，就是因为 Lambda 将原来需要由客户定义的一些流程给封装了，现在用户只要告诉它「应该怎么做」，具体的操作过程，不需要我们用户来实施，所以这就是最开始使用起来，感觉疑惑的原因吧，这也是函数式编程所带来的影响。 引用列表 Java 8 中的 Streams API 详解 Java8中聚合操作collect、reduce方法详解 Java 8 lambda 最佳实践 Java8 lambda表达式10个示例 关于 Lambda 表达式的一些事 函数式编程初探 Java 8新特性探究（一）通往lambda之路_语法篇","categories":[{"name":"Java","slug":"Java","permalink":"http://zengfanyu.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zengfanyu.top/tags/Java/"}]},{"title":"Android官方TODO-MVP项目分析（上）---View 层 Presenter 层以及 Contract 分析","slug":"google-TODO-MVP-sample","date":"2017-11-12T16:37:15.000Z","updated":"2017-11-12T16:19:45.743Z","comments":true,"path":"2017/11/13/google-TODO-MVP-sample/","link":"","permalink":"http://zengfanyu.top/2017/11/13/google-TODO-MVP-sample/","excerpt":"摘要:最近看了一下 google 官方的 sample ,做的是一个 TODO 应用，使用的是 MVP 模式，之前笔者也学习了一段时间的 MVP，前面写了几篇文章记录学习过程，也有一些思考，最后呈现出来的问题就是 Presenter 层臃肿问题，以及 View 层接口难以管理的问题。比方说 View 层，它是负责 UI 的更新工作，我们希望它里面都是 showXXXZZZ（@Nullable Param p） 这样的更新 UI 状态的方法。在这个 sample 里， google 提供了一种解决接口混乱的方法，用「契约」接口，统一管理 View 层和 Presenter 层的接口，下面就分析下我对这个项目的理解。","text":"摘要:最近看了一下 google 官方的 sample ,做的是一个 TODO 应用，使用的是 MVP 模式，之前笔者也学习了一段时间的 MVP，前面写了几篇文章记录学习过程，也有一些思考，最后呈现出来的问题就是 Presenter 层臃肿问题，以及 View 层接口难以管理的问题。比方说 View 层，它是负责 UI 的更新工作，我们希望它里面都是 showXXXZZZ（@Nullable Param p） 这样的更新 UI 状态的方法。在这个 sample 里， google 提供了一种解决接口混乱的方法，用「契约」接口，统一管理 View 层和 Presenter 层的接口，下面就分析下我对这个项目的理解。 项目整体结构分析 因为项目整体使用的是 MVP 模式，所以下面从 MVP 分层的角度来分析；在上面的结构图中，除了 data 包是 Model 层的内容，剩余的四个包里，都是一个包对应一个界面（Activity/Fragment），然后每一个包里有四个类文件,形式分别如下： XxxxActivity：这是 Fragment 的宿主 Acitivity， 同是也是 View 层，但是并没有实现 View 层的接口，主要的 UI 状态更新工作是由 Fragment 来进行的。 YyyyFragment：这是 MVP 模式中的 View 层，它实现了 View 层的接口，都是 showXxxYyy() 形式的更新 UI 的回调方法。 ZzzzPresenter：这是 MVP 模式中的 Presenter 层，它负责处理 UI 的事件，并且和 Model 层打交道，通过 Model 层拿到数据。 PpppContract: 这个类不属于传统 MVP 模式当中的任何一层，它是用于管理 View 层和 Presenter 层的接口的，这个类同一个界面对应的 View 和 Presenter 都要实现， 这样就统一的管理了接口，当我们需要知道 这个 View 层，做了哪些操作的时候，只需要看这个 Contract 类即可，并且对代码模块的移植也有帮助。 整个 data 包下，都是 MVP 模式的 Model 层，用于从数据源取数据，在这个 Sample 里涉及到三种类型的数据，服务器端数据，本地数据库数据和内存缓存中的数据，当然了，这里的服务器端数据时模拟耗时过程的，并没有真正涉及到网络连接的操作。 下面拿 task 包下的类来做说明。(其中 ScrollChildSwipeRefreshLayout 和 TaskFilterType 是业务需求相关的辅助类， 这里暂不做分析。) tasks 包结构分析先看看这个包对应的界面长什么样子： 左边还有一个 DrawerLayout ： 点击 ToolBar 上最右边的 icon： 点击 ToolBar 上次右边的 icon： 当列表中存在任务时： 点击任务，跳转到详情页面，（这个页面不属于这个包下） TasksActivity这是 TasksFragment 的宿主 Activity，它做的工作就是一些控件的初始化操作，然后实例化 TasksFragment 。 初始化 ToolBar 1234567// Set up the toolbar.Toolbar toolbar = (Toolbar) find`View`ById(R.id.toolbar);setSupportActionBar(toolbar);ActionBar ab = getSupportActionBar();ab.setHomeAsUpIndicator(R.drawable.ic_menu);ab.setDisplayHomeAsUpEnabled(true); 初始化 Navigation Drawer 12345678// Set up the navigation drawer.mDrawerLayout = (DrawerLayout) find`View`ById(R.id.drawer_layout);mDrawerLayout.setStatusBarBackground(R.color.colorPrimaryDark);Navigation`View` navigation`View` = (Navigation`View`) find`View`ById(R.id.nav_`View`);if (navigation`View` != null) &#123; setupDrawerContent(navigation`View`);&#125; 初始化对应的 Fragment 123456789TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);if (tasksFragment == null) &#123; // Create the fragment tasksFragment = TasksFragment.newInstance(); ActivityUtils.addFragmentToActivity( getSupportFragmentManager(), tasksFragment, R.id.contentFrame);&#125; Presenter 注入 View 1234// Create the presenter 注入到TaskFragment中mTasksPresenter = new TasksPresenter( Injection.provideTasksRepository(getApplicationContext()), tasksFragment); 这里同时将 Model 层的对象给注入到了 Presenter 中，这个 TasksRepository 就是属于 Model 层的，后面分析。 状态恢复(onCreate 中，也可以直接在 onRestoreInstanceState 方法中操作) 1234567// Load previously saved state, if available.if (savedInstanceState != null) &#123; TasksFilterType currentFiltering = (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY); mTasksPresenter.setFiltering(currentFiltering);&#125; 保存当前显示的 Task 的类别的方法 123456789@Overridepublic void onSaveInstanceState(Bundle outState) &#123; //此处需要保存的信息是当前 Task 列表展示界面展示的 Filter Type 信息, // 目的是为了下一次重其他的页面跳回到此页面时,能够正确的显示 对应 Filter Type 的 Task outState.putSerializable(CURRENT_FILTERING_KEY, mTasksPresenter.getFiltering()); super.onSaveInstanceState(outState);&#125; 从一个 Activity 跳到另外一个 Activity 的时候会调用，用于存储当前 Activity 正在显示的 Task 的类别，类别有三种，分别是 COMPLETED_TASK , ACTIVT_TASK , ALL_TASK; 很好理解，就是用于辨别当前界面是显示已经完成的 Task 还是显示暂未完成的，还是都显示，用于下一次从另外页面回到当前页面的时候，显示的是用户上一次的操作。 剩下的就是 Mene 的初始化 和点击时间的处理了。这里就不贴出代码了。 TasksContract 中 View 层接口分析之前说过， TasksContract 适用于管理 View 层和 Presenter 层的接口的契约接口，我们希望 View 层的方法都是类似于 showXxxZzz() 形式的方法，用于改变 UI 的状态，那么根据上面的截面图，我们分析一下这里的 View 层需要改变哪些状态。 此处涉及到具体的业务逻辑，项目需求，包括每一个控件的点击事件，每一种状态的显示页面 。具体的思路就是，将每一个改变 UI 状态的操作都抽象成接口方法。 当我们从 Model 层取数据的时候，需要展示一个友好交互的页面，提示用户正在加载数据。这里对应接口： 1234567/** * 展示正在加载中的指示器 * * @param active true 展示 false 不展示 */void setLoadingIndicator(boolean active); 当从数据源重拿到数据之后，需要将数据展示到列表上。这里对应接口 1234567/** * 展示列表中的Task * * @param tasks tasks */void showTasks(List&lt;Task&gt; tasks); 当从数据源重拿到数据之后产生错误时回调 12345/** * 加载错误回调 */void showLoadingTasksError(); 点击右下角的 FloatingActionButton，会调到创建任务的界面。 12345/** * 展示添加任务界面,用于跳转至AddEditTaskActivity */void showAddTask(); 点击列表中已经存在的任务，会调转至任务详情页面（图 2.7所示界面），这个操作由点击列表 Item 触发。 123456/** * 展示Task的详细信息,跳转至 TaskDetailActivity * @param taskId taskId */void showTaskDetails`UI`(String taskId); 当任务被标记为 COMPLETED 时更新 UI 状态（图2.6所示），这个操作是 checkBox 被点击触发的。 12345/** * FilterType 被置为 completed 状态时回调 */void showTaskMarkedComplete(); 当任务被标记为 ACTIVE 时更新 UI 状态 （图2.7所示），这个操作是 checkBox 被点击触发的。 12345/** * FilterType 被置为 Active 状态时的回调 */void showTaskMarkedActive(); 当被标记为 COMPLETED 状态的任务被删除时 UI 状态的更新，这个操作是图 2.3 当中所示 Menu 中 Clear Completed 被点击时触发。 12345/** * 清除FilterType为Completed状态的Task */void showCompletedTasksCleared(); 展示所有状态为 ACTIVE 的任务，这个操作是图 2.4 当中所示 Menu 中 Active 被点击时触发 12345/** * 展示所有 FilterType 为 Active 的 Task 的回调 */void showActiveFilterLabel(); 没有状态为 ACTIVE 的任务，更新 UI 界面 12345/** * 展示没有 FilterType为 Active 时的界面 回调 */void showNoActiveTasks(); 展示所有状态为 COMPLETED 的任务，这个操作是图 2.4 当中所示 Menu 中 COMPLETED 被点击时触发 12345/** * 展示所有 FilterType 为 Completed 的Task的回调 */void showCompletedFilterLabel(); 没有状态为 COMPLETED 的任务，更新界面 12345/** * 展示没有 FilterType为 Completed 时的界面 回调 */void showNoCompletedTasks(); 展示所有的任务，这个操作是图 2.4 当中所示 Menu 中 All 被点击时触发 12345/** * 展示所有 FilterType的回调 */void showAllFilterLabel(); 当前还没有任务展示时，更新 UI 的状态 12345/** * 没有Task 时的回调 */void showNoTasks(); 当成功添加了一条任务之后，需要更新 UI 的状态， 12345/** * 展示add一条Task成功后的 回调 */void showSuccessfullySavedMessage(); 因为这里的 View 层是用 Fragment 对象实现的，所以这里用于判断当前 Fragment 视图是否还存在 1234567/** * 当前视图的活跃状态 * * @return true active&lt;p&gt;&lt;/p&gt;false destroy */boolean isActive(); 如图 2.4 所示，这里的显示的效果是使用 PopMenu 做的，所以当我们点击 ToolBar 上次右边的图标时，回调此方法 12345/** * 展示 Toolbar上面的Menu的 选择 展示 FilterType 的popmenu */void showFilteringPopUpMenu(); 可以发现 View 层接口大体分为四类： 涉及到数据更新或者数据获取的改变 UI 状态，第 6，7，8，9 ，11 ，13，15。 页面跳转，第 4 ，5 两个用于启动其他 Activity 的。 不涉及到数据更新和数据获取的改变 UI 状态，1，2，3，10，12 ，14。其中第 2 条只是展示已经获取到的数据，没有涉及到数据的获取和改变。 辅助方法 16，17 Contract 中 Presenter 层接口分析在 TasksContract 当中，不仅仅定义了 View 层的接口，并且还定义了 Presenter 层的接口。这一层的接口肯定是服务于 View 层的，应为 Presenter 层需要响应 View 层的事件，然后和 Model 层交互，然后再根据和 Model 层交互的接口，通知 View 层更新对应的 UI 状态。所以 Presenter 层接口的设置肯定与上面 View 层的 UI 状态改变接口有关，下面来分析一下： 针对 View 层的第 9， 11， 13 ，条需求，分别需要展示 ACTIVE COMPLETED 和所有状态的数据， 那么这个数据从哪儿来呢？就需要 Presenter 层来提供，所以这里需要有一个接口： 1234567/** * 从 `Model` 层获取数据的回调 * * @param forceUpdate 是否刷新 */void loadTasks(boolean forceUpdate); 并且 Presenter 层还需要记录下当前页面的展示哪种类型的数据 1234567/** * 设置当前列表显示的 Task 的 type * * @param requestType &#123;@link TasksFilterType&#125; */void setFiltering(TasksFilterType requestType); 还并且，记下当前页面展示的数据类型，是要在之前 TasksActivity 中的 onSaveInstanceState 方法中获取，然后保存的，所以这里需要提供一个 Getter 方法。 1234567/** * 拿到当前列表显示的 Task 的 type * * @return &#123;@link TasksFilterType&#125; */TasksFilterType getFiltering(); 针对 View 层的第 4 条需求，需要点击 FloatingActionButton 跳转至编辑界面，那么针对这个需求，Presenter 层提供一个接口方法给他调用： 12345/** * 添加新的 Task 的回调 */void addNewTask(); 其实这个方法在最终实现的时候，就是调用 View 第 4 个需求的接口：void showAddTask(); 然后在这个接口的实现方法就是实例化 Intent 然后 startActivityForResult。其实完全可以直接在 FloatingActionButton 的 onClick 回调方法里就调用其本身的 showAddTask 方法跳转至编辑页面，但是人家没有这样做，而是调用 presenter 的 addNewTask 方法，通过 Presenter 层的这个方法在去调用 View 层的 showAddTask 方法，为什么做么做？仔细看项目代码可以发现，View 层「不涉及到数据更新和数据获取的改变 UI 状态」类别的接口方法都是被 Presenter 层调用的，而 Presenter 层所有的接口方法都是被 View 层调用的，因为各自的接口方法是需要对方的事件来驱动。 所以为了保证这一特性的统一表现，这里就采取了这样迂回的方式，来跳转至编辑界面。 针对 View 层的第 5 条需求，点击列表 Item 的时候，会跳转至详情界面，这个过程和上面点击 FloatingActionButton 一样，不做分析。 1234567/** * 查看Task详情的回调 * * @param requestedTask special task */void openTaskDetails(@NonNull Task requestedTask); 针对 View 层第 6 条需求，需要将某一条任务标记为 COMPLETED 状态，那么不仅仅是在 UI 上要做改变，还要将数据源中的本条数据给标记为 COMPLETED 状态，所以 Presenter 层要提供这个需求的数据支撑： 1234567/** * 列表Item的checkBox 从false到true时的回调 * * @param completedTask special task */void completeTask(@NonNull Task completedTask); 针对 View 层的第 7 条需求，和上一条一样，不做分析。 1234567/** * 列表Item的checkBox 从true到false时的回调 * * @param activeTask special task */void activateTask(@NonNull Task activeTask); 针对 View 层的第 8 条需求，删除标记为 COMPLETED 的任务，不仅仅要在 UI 上做改变，在数据源中也是需要将它删除的，所以在 Presenter 层提供这个需求的数据支撑。 12345/** * 清除FilterType为Completed状态的Task */void clearCompletedTasks(); 针对 View 层的第 15 条需求，showSuccessfullySavedMessage 这个方法是成功添加了一条数据返回此界面之后调用，那么就本应该是在此界面的的 onActivityResult 方法中调用，但是由于和 Presenter 层第 4 个方法一样的原因，这里也是采取了迂回的方式，先通知 Presenter 层，再由 Presenter 层来回调。 12345678/** * 当一个Task成功添加进来时,返回到TasksFragment时的回调 * * @param requestCode requestCode * @param resultCode resultCode */void result(int requestCode, int resultCode); View 层接口的基类根据 MVP 模式的原理，View 层是一定持有一个 Presenter 层对象的引用的，所以这里创建一个所有 View 层接口的基类，里面就一个接口方法，用于设置 View 对应的 Presenter。 123456789public interface Base`View`&lt;T&gt; &#123; /** * `View`必须要实现的方法,保持对Presenter的引用 * @param presenter */ void setPresenter(T presenter);&#125; Presenter 层接口的基类由于每一次回到 View 层界面的时候，我们都需要展示当前需要被展示的数据（需要被展示的数据是根据当前的 FilterType 来决定的），由于 View 层不涉及数据的缓存，那么我们就需要有一个方法在每一次回到一个 View 层界面的时候都通知 Presenter 层去取数据。 123456789public interface BasePresenter &#123; /** * Presenter必须实现的方法,用于开始获取数据并且刷新界面, * 在Fragment的onResume方法中调用 */ void start();&#125; 对于 Fragment 来说，每一次回到一个 Fragment 的时候，onResume 都会调用，就放在这里调用适合。 TasksContract 接口分析这么多，最终这个接口长这个样子： 1234567891011public interface TasksContract &#123; interface `View` extends Base`View`&lt;Presenter&gt; &#123; //2.2小结中分析的所有接口 &#125; interface Presenter extends BasePresenter &#123; //2.3小结中分析的所有接口 &#125;&#125; 这个接口 View 层和 Presenter 层各自实现其中的子接口。 tasks 包下 View 层和 Presenter 层实现类接口都定义好了，接下来就是用 TasksFragment 和 TaskPresenter 分别去实现 TasksContract 中的接口了，这部分涉及到具体的业务逻辑，所以不做分析，这里只分析项目结构方面。下面笔者从 google 库中 fork 过来的，添加了部分注释： TasksContract.java TasksActivity.java TasksFragment .java TasksPresenter.java 小结 View 层和 Presenter 层接口方法 到这里，View 层和 Presenter 层的接口都都分析完了，回过头来再看看，可以发现一个很有意思的地方，在分析完 View 层接口之后，笔者将 View 层接口归纳为了四类，那么在结合 Presenter 层的接口方法看看就会发现，Presenter 层接口方法是针对上面总结的 「涉及到数据更新或者数据获取的改变 UI 状态」，「页面跳转」，这两类接口方法的辅助，去除掉「页面跳转」，这个不在 MVP 范畴之内，那么剩下的就是，「涉及到数据更新或者数据获取的改变 UI 状态」 这个类别下的接口方法了。 「涉及到数据更新或者数据获取的改变 UI 状态」 这个类别下的接口方法是需要数据作为支撑的，而 View 层本身只负责 UI 的状态改变，不涉及到数据的获取操作，所以这些数据就需要从 Presenter 层中获取。 获取到了之后，再到 Presenter 层的接口方法中去回调 View 层的 「不涉及到数据更新或者数据获取的改变 UI 状态」的接口方法。 这么一来，View 层和 Presenter 层通过 TasksContract 契约类，完美的契合在一起，这两层的实现类代码中，互相之间都是接口依赖，大大增加了代码的可扩展性。 View 层接口方法的设置完全是从业务逻辑出发的，也就是从需求的角度出发。 Presenter 层是服务于 Presenter 层，所以它的接口的设置是为了支撑 View 层的逻辑。。举个例子：比如说用户点击这个按钮，需要有什么样的一个效果，那么我就针对这个操作，在 View 层接口里写一个接口方法；获取数据成功之后，我们需要展示出来，针对这个操作在 View 层接口里写一个接口方法；没有获取到任何数据，需要给用户显示一个友好的界面，针对这个操作，又在 View 层接口里写一个接口方法。但是这些操作是需要有支撑的，因为 View 层本身是不具备它将要更新的 UI 所需要的的数据的，所以这时候就是靠 Presenter 层来支撑 。 这种方式，也让我联想到，如果是团队开发的话，当产品给出原型图了之后，针对每一张原型图当中每一个控件的操作，需要展示的状态，先定好接口，写好 Contract 契约接口，然后团队成员在到各自的分支上并行开发，是否可以大大提高工作效率？这个还有待商榷。 看完这个 Sample 之后的一些感受 如果不看人家 google 工程师的源码，只给我看 app 最后的效果，我也能百分百复制出来一个一模一样的，但是我的代码在复用性，鲁棒性，可扩展性方面肯定没有人家的棒，看这个项目的代码真的很舒服，行云流水般的感觉，在编码习惯方面有几点真的十分赞： 分包很明确，每一包下只有和这个包功能相关的代码，不用到处去找相关类，关看包结构就能得到项目大致结构。 包、类、变量、方法、接口等的命名十分规范，命名都是有意义的，更不存在什么 MyXXXX 这种命名方式，观看名字就能知道这个东西是干嘛的。 注释十分详细，虽然我在阅读的过程中，添加了中文注释，但是人家本身的英文注释就有很多，每一个文件都有注释用于说明这个文件的用途；用途不是那么显而易见的方法也都有注释，真的是大大减少了我们的阅读难度。这一点很多第三方的框架也做的特别棒，前阵子看 Universal-Image-Loader 的源码，注释也十分详细，并且使用 javadoc。 代码在多处做了容错性处理，变量只要在使用的时候，就会去 checkNullOrEmpty，这个项目里用的是 Guava 中的 Preconditions 工具类，很方便。 发现自己基础方面不够扎实，整个项目涉及到很多 Android 的基础知识，比如说 Activity 和 Fragment 的生命周期，重要生命周期方法的作用，调用时机；Activity 和 Fragment 之间的通信；关于 ToolBar 的使用；关于 Menu 菜单的使用；关于 android.support.v4.app.NavUtils 这个工具类的使用等等，不一一列举了。总之体现了一个问题，我真的还很菜。 contract 接口和 Model 层的设计，确实很棒，让传统 MVP 模式如虎添翼。 希望自己以后再工作当中，从编码习惯方面入手，增强代码的规范性，同时也不能忘了基础的巩固，要学的真的有很多。 好像是 Linux 的爸爸说过 Read the fuck code !阅读源码，真的可以学习很多姿势，也能暴露出自己身上存在的很多问题，当然了，前提是这个源码十分优秀，这个是谷歌官方的 Sample 库，我感觉维护这个库的人就是官方文档 API 示例编写的那一群老哥，因为很多代码的风格和使用的方式，和官方文档上一模一样，比如说在 Model 层使用 SQLite 的代码，就和官网上的文档一模一样，所以这个源码，必须是很优秀的！ TODO上面相当于只分析了 View 层和 Presenter 层的结构和实现思路，还有 Model 层没有分析，Model 层是这个 Sample 在传统 MVP 模式当中，除了 Contract 之外，最优雅的设计方式，由于篇幅的原因，Model 层相关的留到下一篇文章分析。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（七）终篇---关于对MVP模式中代码臃肿问题的思考","slug":"MVP7","date":"2017-11-05T13:27:15.000Z","updated":"2017-11-05T13:27:20.461Z","comments":true,"path":"2017/11/05/MVP7/","link":"","permalink":"http://zengfanyu.top/2017/11/05/MVP7/","excerpt":"摘要：在学习 MVP 模式的过程当中，见到很多文章都提到一句话：「使用 MVP 模式引入了 Presenter 层，这样可以将 View 层和 Model 层解耦，但是项目的代码量会大大增加，不过这个牺牲是值得的。」但是这个如果不做处理的话，随着项目体量的扩大，项目当中会充斥着很多相同逻辑的代码，是在是不能忍，通过前面几章的封装可以缓解这个情况，但是还剩下一个问题是目前解决不了的，那就是 Presenter 的管理问题和 View 层无关代码问题，这一篇就针对这两个问题记录一下思路。","text":"摘要：在学习 MVP 模式的过程当中，见到很多文章都提到一句话：「使用 MVP 模式引入了 Presenter 层，这样可以将 View 层和 Model 层解耦，但是项目的代码量会大大增加，不过这个牺牲是值得的。」但是这个如果不做处理的话，随着项目体量的扩大，项目当中会充斥着很多相同逻辑的代码，是在是不能忍，通过前面几章的封装可以缓解这个情况，但是还剩下一个问题是目前解决不了的，那就是 Presenter 的管理问题和 View 层无关代码问题，这一篇就针对这两个问题记录一下思路。 学习 MVP 模式的过程中引发的一些思考最近一个月都在学习 MVP 模式，自己也动手做了几个小 Demo，由于 Demo 规模不大，所以代码臃肿的问题没有很好的反映出来，不过却是反应出来了其他的问题。比如当我需要实现另外一个需求的时候，我需要去重新创建 M V P 三层的代码，而这三层的代码很多逻辑都是相似的，比如说 Model 层就是去访问服务器端请求数据，然后将数据回调到 Presenter 层，只是访问的服务器端 URL 地址不同，返回的数据不同，这个差异性通过对网络请求工具做封装，并且封装 Model 层相同逻辑代码，可以很好的解决；再比如说 View 层会涉及到很多 UI 界面的刷新问题，常用的 ProgressBar，Toast ，显示错误信息状态码等基本功能，也可以通过封装 BaseMvpActivity 和 IBaseView 来解决，所以这就是前面六篇文章的由来。至于代码臃肿所体现出的问题，我总结为如下两个： View 层中充斥这各种事件的分发和事件的注册，我们希望 View 层是这样的：只有 onXxxxZzzz() 形式的回调方法用于改变UI，比如： onLoadMessage(List&lt;Message&gt;) 回调在加载完 Message 之后来进行UI的更新，那么事件的注册和分发就需要到其他地方去处理。 View 层和 Prensenter 层接口的管理问题，比如当我们需要移植一个模块的时候，由于 View 层和 Presenter 是紧密相连的，所以这两层需要一同移植，不过可能由于项目体量的原因，Presenter 和 View 的接口比较多，没办法一次性的移植，需要不断的测试。 英国计算机学家说过一句话：All problems in computer science can be solved by another level of indirection.翻译成中文就是：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。比如十分复杂的Internet国际互联网络中数据传输的问题，也是通过分层来决绝的，这可以体现在 TCP/IP 四层模型和 OSI 七层模型当中。 这么复杂的问题都可以引入中间层来解决，那么 MVP 中的问题就更不在话下了。 关于解决上述两个问题的思路View 层臃肿问题解决思路第一个问题，天天_byconan，大神的博客中有很好的解决思路，下图也是摘抄自他的博客。 先上两张图： 引入 PresenterProxy 层 通过使用一个 Presenter 层代理的方式，在 PresenterProxy 中处理各种时间机制，View 中维护一个对 PresenterProxy 的引用，PresenterProxy 也实现了真实 Presenter 层的接口，这样就可以在 View 中通过代理调用真实的 Presenter 层对象。 引入 Controller 层 为 MVP 模式增加一层专门用于处理各种时间派发的 Controller 层，Controller 层的作用仅仅是用于处理事件，并根据事件通过维护的 Presenter 层对象派发到对应的业务当中去，也就是说 View 层只有一个 Controller 对象， View 层不会主动的去调用 Presenter 层对象，但是 Controller 层和 Presenter 层都可能回调到 View 层来刷新UI。 这两张图就为我们提供了很好的解决思路，虽然我还没有动手实践过，但是从思路上来说，是没有问题的。 Presenter 和 View 层接口管理问题解决思路在笔者查看了大量的文章资料之后，发现这个问题 Google 已经给出了一个十分好的的解决思路，这个答案就在 官方的TODO-MVP Sample里，这个 Demo 通过用 MVP 模式实现了一个TODO应用，先贴一下这个应用在 Android Studio 中的代码分包情况： 整个 APP 等架构十分的清晰，不愧是出自 Google 大牛之手！！！ 管理接口的核心类是每一个模块当中的 XXXXContract 接口 并且这个项目当中的 Model 层是它最大亮点， 上图中 data 包下就是它的 Model 层， TasksRepository 维护了两个数据源，一个是本地（SQLite 数据库），一个是远程（网络服务器），并且将不同的数据源抽象成为 TaskDataSource 接口，这种面向接口编程的思想，让我们很容易的修改数据源，或者是扩展数据源，这也是依赖倒置原则的体现。 放一下项目整体架构图： 出自：https://github.com/googlesamples/android-architecture/tree/todo-mvp/ 接下来准备好好研究一下这个项目的架构和实现，并且这个 Google 的开源库是用不同的架构去实现相同的 APP，提供了很多架构的基本应用：clean dagger rxjava databinding 等，有空一定好好研究。 又立 Flag MVP 模式也算是入门了吧，后面准备结合上面的 TODO-MVP 项目，在练练手，然后把上面提到的几个思路好好梳理一下，关于 TODO-MVP 项目也准备写一篇文章总结记录一下。 关于 Retrofit 的使用我也看了好几篇文章，基本的使用应该是没问题的了，不过在这个过程中，感觉自己缺乏服务器端知识，什么 RESTful API ，什么 URL 的构成什么的，没有系统的了解过(对，就是写 Retrofit 的网络请求接口的时候，有点迷失了~)，后面这一块要恶补一下。 下一个就是 Dagger2 了， 关于 Dagger2 也看了几篇文章，感觉它的概念性的东西确实挺多的，上手不是太容易，不过也没关系，慢慢来。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Dagger2基础内容归纳","slug":"Dagger","date":"2017-11-04T06:37:15.000Z","updated":"2017-11-04T10:08:19.466Z","comments":true,"path":"2017/11/04/Dagger/","link":"","permalink":"http://zengfanyu.top/2017/11/04/Dagger/","excerpt":"摘要：最近看了很多讲 Dagger2 的文章，发现Dagger中很多基础的概念问题真的挺缥缈，很难理解透彻，其中有几篇确实写得不错，这里将他们总结一下，底部给上参考文章链接。","text":"摘要：最近看了很多讲 Dagger2 的文章，发现Dagger中很多基础的概念问题真的挺缥缈，很难理解透彻，其中有几篇确实写得不错，这里将他们总结一下，底部给上参考文章链接。 @Inject@Inject 注解只是 JSR-330 中定义的注解,这个注解本身是没有意义的,它需要依赖于注入框架才有意义,用于标记需要被注入框架注入的方法,属性,构造方法,也就是说呗 @Inject 标记的就是用于提供依赖的. @Inject 定义123public @interface Inject &#123;&#125; @Inject 的使用 构造方法注入 @inject 注解在在构造器注入上又有两层意思 告诉 Dragger2 可以使用这个构造方法构建对象用于提供依赖 注入构造方法所需要的参数的依赖 属性注入 用于标注在属性上,被标注的属性不能用 private 修饰,否则无法注入 方法注入 标注在 public 方法上,Dagger2 会在构造方法执行结束之后,立刻调用被 @inject 标注的方法. 方法注入和属性注入没有本质的区别，那么什么时候用该使用方法注入，什么时候应该使用属性注入呢，比如依赖需要使用 this 对象的时候，就适合使用方法注入，因为方法注入是在构造方法执行结束之后就调用的，所以它可以提供安全的 this 对象。 Inject 的 弊端 假设我们现在依赖了第三方的框架,这个第三方的框架我们是不能修改的,所以我们无法注入. 如果某个用于提供依赖的类具有多个构造方法,我们只能标注一个,无法标注多个 当我们使用依赖倒置原则的时候，因为需要注入的对象是抽象的，因此也如法注入 @ComponentComponent 负责将 被依赖对象 给注入到 需要依赖对象 当中,类似于一个中间层. Component 定义Dagger2 是使用 @Component 来完成依赖注入的, 定义如下: 12345public @interface Component &#123; Class&lt;?&gt;[] modules() default &#123;&#125;; Class&lt;?&gt;[] dependencies() default &#123;&#125;;&#125; 需要注意几点: Component 需要用接口来定义, 接口命名方式推荐为: *TargetClassName*Component 在编译之后,Dagger2 会生成 Dagger*TargetClassName*Component ,这是 *TargetClassName*Component 接口的实现 在 TargetClass 中使用 DaggerTargetClassNameComponent 就可以实现依赖注入 @Component 中定义方法的方式1. void inject(TargetClassName calss) Dagger2 会从 TargetClass 开始查找 @Inject 注解,自动生成依赖注入的代码,调用 inject 即可完成依赖的注入 2. TargetClass getTargetClass() Dagger2 会到 TargetClass 中寻找被@Inject 注解的构造方法,自动生成提供 TargetClass 依赖的代码,这种方式一般用于为其他的 Component 提供依赖,即一个 Component 作为另外一个 Component 的依赖 3. 使用 @SubComponent 的方式 123456789@Componentinterface AComponpent &#123; XxxComponent plus(Module... modules)&#125;@Subcomponent(modules = xxxxx)interface XxxComponent &#123;&#125; xxxComponent 是该 AComponpent 的依赖，被 @Subcomponent 标注。 modules 参数则是 xxxComponent 指定的 Module。 在重新编译后，Dagger2 生成的代码中，Subcomponent 标记的类是 Componpent 的内部类。 总结一下 目前为止(后面还有Module注解) Component 的作用: Dagger2 以 Component 中定义的方法作为入口,到 TargetClass 中去寻找被 @Inject 标注的属性,查找到这个属性之后,就会去接着查找该属性对应的 用 @Inject 标注的构造函数,剩下的工作就是初始化该属性的实例,并且将实例赋值给属性.这是通过生成一系列提供依赖的 Factory 类和注入依赖的 Injector 类,来实现的. Component 和 Inject 的关系小结 用 @Inject 标注目标类中的其他类 用 @Inject 标注其他类中的构造方法 若其他类中还依赖于别的类，那么重复上述两个步骤 调用 Component 的 injectXXX 方法，Component 会把目标类依赖的实例给注入到目标类当中，用于初始化目标类当中的依赖。 @ModuleModule 定义1234public @interface Module &#123; Class&lt;?&gt;[] includes() default &#123;&#125;;&#125; @Module 引入原因如果我们项目当中使用了第三方的框架，那么可能某个 TargetClass 就持有对框架中某个类 C 实例的引用，那么按照上面两个注解的方式，我们就需要到框架当中 C 类的构造方法上面去标注一个 @Inject，况且不说构造方法多样性的问题（比如 Universal-Image-Loader 的 ImageLoader 类构造方法二三十个），框架当中的源码我们是不可以修改的啊。这个时候 @Inject 就失效了，我们就需要一个新的工具去注解，这时就引入了 @Module 了。 12345678@Modulepublic class ModuleClass&#123; //A是第三方类库中的一个类 A provideA()&#123; return A(); &#125;&#125; Module 是一个简单工厂模式，Module 里面的方法基本上都是创建类实例的方法，那么此时如何让 Component 和 Module 产生联系呢？ Component 的新职责Component 是注入器，它一端连接 TargetClass，另一端连接 TargetClass 依赖的实例，它把 TargetClass 依赖实例注入到 TargetClass 中。上文中的 Module 是一个提供类实例的类，所以 Module 应该是属于 Component 的实例端的（连接各种目标类依赖实例的端），Component 的新职责就是管理好 Module，Component 中的 modules 属性可以把 Module 加入 Component，modules 可以加入多个 Module。 那么接下来的问题就是，如何将 Module 中各种提供实例的方法同 TargetClass 中 Inject 标注的类属性给链接起来，这个时候 Provides 就可以出来了。 ##@Provides## ###Provides 定义### 123public @interface Provides &#123;&#125; Module 中创建实例的方法是用 Provides 标注的，之前说过，Component 搜索到 TargetClass 中用 @Inject 标注的属性之后，他就会去这个属性的类中寻找标注了 @Inject 的构造方法 ，其实在这个步骤之前，它优先去 @Module 标注的类中查找 @Provides 标注的用于创建实例的方法，如果没有找到，那么才会去查找标注了 @Inject 的构造方法。 这么一来，第三方类库的依赖注入问题就解决了。 上述注解小结1.Inject 是用于标注 TargetClass 中的依赖和依赖类中的构造函数的。 2.Component 是一个注入器（Injector） ，同时也起着桥梁的作用， 一端是类创建实例端(即负责创建生产类的实例),另外一端是 TargetClass 端（即需要进行依赖初始化的类），同时也负责管理 Module。 3.Module 和 Provides 是为觉得第三方库注入问题而引出的，Module 是一个简单工厂模式，Module 包含创建实例的方法，这个方法用 Provides 来标注。 4.创建依赖类有两个途径：通过 @Inject 标注的构造方法来创建； 通过 @Provides 标注的创建实例的方法来创建； 但是后者的优先级要大于前者，也就是说，Component 如果找到了后者，他就不会再接着去找前者。 5.@Module 要和 @Provides 配套使用，并且 @Component 也指定了该 Module 的时候，才能正常使用，@Module 告诉 @Component ，你可以从我这儿标注了 @Privides 的方法中获取实例。 6.Component 和 Module 是匹配关系 ， Component 依赖哪一个 Module 就需要在注解中用 muduls 属性标明。 @Inject @Component @Module @Provides 就是 Dagger2 框架中最核心的部分，奠定了整个框架的基础，下面的标签就是针对细节问题的处理。 @Qualifier问题的引出现在有种情况，用上述注解无法解决： 根据依赖倒置原则，我们应该面向接口编程，或者是面向抽象编程，在 Java 中多态的性质很好的支持了这一原则，所以我们经常会在类中申明的是某一属性的接口，或者是抽象类，这样操作在程序编译的时刻，是不能确定这个属性的具体实例是哪一个子类，只能在运行时才能确定下来，那么这个时候 Component 怎么知道应该将哪一个子类给注入到 TargetClass 的属性当中 ？ 基于上面两个问题，就提出了 @Qualifier 注解，它就是用于解决上述问题的。 这个时候就需要给各个 抽象类或者接口 的子类的构造方法标注 @Qualifier，类似于给他们一个 ID ，通过这个 ID 就可以区分不同的子类。 Qualifier 的定义123public @interface Qualifier &#123;&#125; 这个注解跟 @Inject 一样，不是 Dagger 定义的， 而是 JSR-330 中定义的。 Qualifier 是用于定义注解的。 Qualifier 使用方法 使用 @Qualifier 根据子类的不同，分别定义新的注解，注解要有含义 分别使用新的注解去标注生成不同子类实例的地方，然后要使用哪一个子类的实例，是到抽象属性上标注子类对应的新的注解。 @Scope 和 @SingleScole 的定义123public @interface Scope &#123;&#125; 也是 JSR-330 定义的，不是 Dagger 中定义的 用于自定义注解 @Single 是 @Scope 的默认实现，如下： 12345@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; Scope 的作用 它的作用只是保证依赖在 @Component 中是唯一的，可以理解为“局部单例”。 @Scope 是需要成对存在的，在 Module 的 Provide 方法中使用了 @Scope，那么对应的 Component 中也必须使用 @Scope 注解，当两边的 @Scope 名字一样时（比如同为 @Singleton）, 那么该 Provide 方法提供的依赖将会在 Component 中保持“局部单例”。 而在 Component 中标注 @Scope，provide 方法没有标注，那么这个 Scope 就不会起作用，而 Component 上的 Scope 的作用也只是为了能顺利通过编译。 这么说 @Single 是没有创建单例的能力，因为他只是保证在 Component 中的唯一的，那怎么实现真正的单例呢？ 单例的实现 依赖在 Component 中是单例的（供该依赖的 provide 方法和对应的 Component 类使用同一个 Scope 注解。） 对应的 Component 在 App 中只初始化一次，每次注入依赖都使用这个 Component 对象。（在 Application 中创建该 Component） Lazy这个比较简单，延迟加载模式，用 Lazy&lt;T&gt; 装饰需要被 @Inject 标注的属性 T ，这样，在 Inject 的时候并不会初始化它，而是在使用 T 的时候，通过 T.gey() 来得到他的实例，然后再使用。 Component 组织方式这是重中之重，前面的概念都是做铺垫，这里从一个 APP 的角度将他们融合起来。 一个app中应该根据什么来划分Component假如一个 app （app 指的是 Android app）中只有一个 Component，那这个 Component 是很难维护、并且变化率是很高，很庞大的，就是因为 Component 的职责太多了导致的。所以就有必要把这个庞大的 Component 进行划分，划分为粒度小的 Component。那划分的规则这样的： 要有一个全局的 Component (可以叫 ApplicationComponent ),负责管理整个 app 的全局类实例（全局类实例整个 app 都要用到的类的实例，这些类基本都是单例的） 每个页面对应一个 Component，比如一个 Activity 页面定义一个 Component，一个 Fragment 定义一个 Component。当然这不是必须的，有些页面之间的依赖的类是一样的，可以公用一个 Component。 第一个规则应该很好理解，具体说下第二个规则，为什么以页面为粒度来划分 Component？ 一个 app 是由很多个页面组成的，从组成 app 的角度来看一个页面就是一个完整的最小粒度了。 一个页面的实现其实是要依赖各种类的，可以理解成一个页面把各种依赖的类组织起来共同实现一个大的功能，每个页面都组织着自己的需要依赖的类，一个页面就是一堆类的组织者。 划分粒度不能太小了。假如使用 mvp 架构搭建 app，划分粒度是基于每个页面的m 、v 、p 各自定义 Component 的，那 Component 的粒度就太小了，定义这么多的 Component，管理、维护就很非常困难。 所以以页面划分 Component 在管理、维护上面相对来说更合理。 组织Component我们已经把一个 app 按照上面的规则划分为不同的 Component 了，全局类实例也创建了单例模式。问题来了：其他的 Component 想要把全局的类实例注入到目标类中该怎么办呢？这就涉及到类实例共享的问题了，因为 Component 有管理创建类实例的能力。因此只要能很好的组织 Component 之间的关系，问题就好办了。具体的组织方式分为以下2种： 依赖方式一个 Component 是依赖于一个或多个 Component，Component 中的 dependencies 属性就是依赖方式的具体实现 包含方式一个 Component 是包含一个或多个 Component 的，被包含的 Component 还可以继续包含其他的 Component。这种方式特别像 Activity 与 Fragment 的关系。SubComponent 就是包含方式的具体实现。 Dagger 注入一次的流程步骤1：查找 Module 中是否存在创建该类的方法。 步骤2：若存在创建类方法，查看该方法是否存在参数 步骤2.1：若存在参数，则按从**步骤1**开始依次初始化每个参数 步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 步骤3：若不存在创建类方法，则查找 Inject 注解的构造函数，看构造函数是否存在参数 步骤3.1：若存在参数，则从**步骤1**开始依次初始化每个参数 步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束 总结对象 Android：dagger2让你爱不释手-基础依赖注入框架篇 Android：dagger2让你爱不释手-重点概念讲解、融合篇 Android：dagger2让你爱不释手-终结篇","categories":[{"name":"Dagger","slug":"Dagger","permalink":"http://zengfanyu.top/categories/Dagger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"Dagger","slug":"Dagger","permalink":"http://zengfanyu.top/tags/Dagger/"}]},{"title":"Android当中的MVP模式（六）View 层 Activity 的基类--- BaseMvpActivity 的封装","slug":"MVP6","date":"2017-11-03T12:37:15.000Z","updated":"2017-11-04T09:49:07.998Z","comments":true,"path":"2017/11/03/MVP6/","link":"","permalink":"http://zengfanyu.top/2017/11/03/MVP6/","excerpt":"摘要：使用封装之后的 MVP 模式实现一个新的界面，也就是 Vie 层，那么就需要去实现 IBaseView 接口，可能还需要针对当前要实现的界面情况，在 IBaseView 的基础之上派生出一个新的接口 IXxxView,之前的 SohuAlbumInfoActivity 用于展示搜狐电视剧主要信息的 View 就是这种情况,由 IBaseView 派生了一个 ISohuSerials ,再由 SohuAlbumInfoActivity 去实现,那么随着需要展示的界面越来越多,它们坐着大量重复的工作,我们就要像个方法来简化这个过程了。","text":"摘要：使用封装之后的 MVP 模式实现一个新的界面，也就是 Vie 层，那么就需要去实现 IBaseView 接口，可能还需要针对当前要实现的界面情况，在 IBaseView 的基础之上派生出一个新的接口 IXxxView,之前的 SohuAlbumInfoActivity 用于展示搜狐电视剧主要信息的 View 就是这种情况,由 IBaseView 派生了一个 ISohuSerials ,再由 SohuAlbumInfoActivity 去实现,那么随着需要展示的界面越来越多,它们坐着大量重复的工作,我们就要像个方法来简化这个过程了。 回顾前几篇中 View 层的写法根据MVP系列第二篇当中的分析， View 层的职责如下： Loading 状态的展示隐藏 接收 Presenter 层处理后的数据 接收 Presenter 层处理后的错误信息 接收 Presenter 层处理后的服务器拒绝信息 所以当就将着一些职责抽象成方法，放在 IBaseView 接口中，看看之前的的 IBaseView： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by fanyuzeng on 2017/10/20. * @author : ZengFanyu */public interface IBaseView &#123; /** * 进行耗时操作时的用户友好交互接口，比如显示ProgressBar * * @param isShow * @author zfy * @created at 2017/10/21/021 14:12 */ void showProgress(boolean isShow); /** * 显示网络请求错的的接口 * * @param errorCode * @param errorDesc * @param errorUrl * @author zfy * @created at 2017/10/21/021 14:14 */ void showOkHttpError(int errorCode, String errorDesc, String errorUrl); /** * 现实服务器端请求错误的接口 * * @param errorCode * @param errorDesc * @author zfy * @created at 2017/10/21/021 14:14 */ void showServerError(int errorCode, String errorDesc); /** * 请求成功或者失败之后，对应UI做出改变的接口 * * @param isSuccess * @author zfy * @created at 2017/10/21/021 14:15 */ void showSuccess(boolean isSuccess); View 层每需要添加一个类， View 层的对象都需要在它的基础上去实现，比如说，在 MVP系列第三篇中，需要对搜狐视频电视剧频道的主要信息做分页展示，当时是在 IBaseView 的基础上派生出了一个 ISohuSerials ： 1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 然后再使用 SohuAlbumInfoActivity 去实现这个接口，对 IBaseView 和 ISohuSerials 中的方法又做了一遍实现，但是这次的实现过程，跟MVP系列第二篇中的 LatestNewsTitleActivity 实现的功能几乎一致，并且这个时候，我就意识到 IBaseView 接口设计的缺陷，我们在 IBaseView 的基础上派生出 ISohuSerials 接口 ILatestNewsView 接口，无非就是要展示不同类型的数据，那这个功能完全可以整合进 IBaseView 接口中，至于不同页面的数据类型不同，我们完全可以使用泛型来解决。 下面就来解决这两个问题： 将展示 Presenter 层实例好的数据的方法，由派生接口整合至基类接口中，使用泛型解决数据类型不同的问题。 封装 BaseMvpActivity，实现共有逻辑，子类不重复处理 View 层基类接口（IBaseView）中的方法。 IBaseView 的重构再回顾一下，之前要展示知乎日报的最新消息的标题内容，我写了一个 ILatestNewsView 接口，它长这样： 12345public inerface ILatestNewsView extends IBaseView &#123; void showLatestNewsTitle(List&lt;String&gt; titles)&#125; 后来又需要展示搜狐电视剧主要信息，于是写了一个 ISohuSerials ，： 12345public interface ISohuSerials extends IBaseView &#123; void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 当时怎么想的，要整个这接口出来 - - ！ 现在把他们都整合进 IBaseView： 12345678910public interface IBaseView&lt;Data&gt; &#123; //省略代码/** * 显示presenter层处理好之后的数据 * @param data data */ void showDataFromPresenter(Data data); 此处添加了一个泛型 Data ，它就可以用于指代上面两个接口中的 List&lt;String&gt; titles 和 List&lt;VideoInfo&gt; videoList ，或者是其他的数据了类型，然后在实现接口的类中去指明参数的类型就可以动态的更改它的类型了。 BaseMvpActivity 的封装上述是对之前遗留问题的一个解决，从这儿开始才正式对基类 BaseMvpActivity 进行封装。 ToolBar 的统一处理首先， Demo 是在 API 25 ，所以对 ToolBar 也要有良好的支持，所以首先是对 ToolBar 的封装，将 ToolBar 写到一个单独的 Layout 文件之中，方便其他文件引用。top_action_bar： 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt;&lt;!-- android:popupTheme 用于自定义弹出的菜单的样式--&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_tool_bar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" android:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:titleTextColor=\"#ffffff\" &gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 在 BaseMvpActivity 中的统一处理如下： 1234567891011121314151617protected void setSupportActionBar() &#123; if (mToolbar != null) &#123; setSupportActionBar(mToolbar); &#125;&#125;protected void setActionBarIcon(int resId) &#123; if (mToolbar != null) &#123; mToolbar.setNavigationIcon(resId); &#125;&#125;protected void setSupportArrowActionBar(boolean isSupport) &#123; getSupportActionBar().setDisplayHomeAsUpEnabled(isSupport);&#125; 这样处理了之后，在子类当中，就可以直接调用上述方法，就可以使用 ToolBar了， 当然，对 ToolBar 的自定义需要另外去处理。 BaseMvpActivity 的布局文件的处理由于 BaseMvpActivity 是要作为 MVP 模式下，所有 View 层的基类，所以它自己需要有布局文件，将 IBaseView 中的接口实现， activity_base_mvp： 123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;include layout=\"@layout/top_action_bar\"/&gt; &lt;TextView android:id=\"@+id/id_tip_content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_horizontal\" android:textSize=\"16sp\" android:text=\"tip\"/&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:id=\"@+id/id_content_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;ProgressBar android:id=\"@+id/id_progress_bar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:visibility=\"gone\"/&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 第 7 行的 include 文件，就是对上面 top_action_bar 的引用。 第 10 行的 TextView 这里用来实现 IBaseView 中 showOkHttpError 和 showServerError接口的。 第 22 行的 FrameLayout 很重要，看 id 就知道了，它是用于展示子类页面的方法的，直接将子类的布局文件给 add 进来。类似于： 1234View contentView = LayoutInflater.from(this).inflate(R.layout.activity_album_view, null);FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);mContentContainer.addView(contentView, lp); 第 27 行的 ProgressBar 就是用于实现 IBaseView 中 showProgress 的。 BaseMvpActivity 对 IBaseView 的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * @author:fanyuzeng * @date: 2017/10/30 13:50 * @desc: */public abstract class BaseMvpActivity&lt;Data&gt; extends AppCompatActivity implements IBaseView&lt;Data&gt; &#123; private static final String TAG = \"BaseMvpActivity\"; protected Toolbar mToolbar; protected ProgressBar mProgressBar; protected TextView mTipView; protected FrameLayout mContentContainer; protected Handler mHandler = new Handler(Looper.getMainLooper()); protected Context mContext; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_base_mvp); mContext = this; mToolbar = bindViewId(R.id.id_tool_bar); mProgressBar = bindViewId(R.id.id_progress_bar); mTipView = bindViewId(R.id.id_tip_content); mContentContainer = bindViewId(R.id.id_content_container); beforeInitViews(); initViews(); afterInitViews(); &#125; protected &lt;T extends View&gt; T bindViewId(int resId) &#123; return (T) findViewById(resId); &#125; //统一处理ToolBar @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTipView.setText(\"errorCode:\" + errorCode + \",errorDesc:\" + errorDesc + \",errorUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTipView.setText(\"errorCode:\" + errorCode + \",errorDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContentContainer.setBackgroundResource(android.R.color.white); &#125; else &#123; mContentContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: finish(); break; default: break; &#125; return super.onOptionsItemSelected(item); &#125; /** * 子类实现,用于初始化控件 */ protected abstract void initViews(); /** * 子类实现 在初始化控件之后进行的操作 */ protected abstract void afterInitViews(); /** * 子类实现, 在初始化控件之前的操作 */ protected abstract void beforeInitViews();&#125; 做了几点事情 实现了 IBaseView 中的接口 对 ToolBar 做统一处理 findViewById方法处理 Menu Item 中返回按键的处理 还有一个问题，似乎少了一个方法？就是在上一小节中，整合进 IBaseView 接口中的 void showDataFromPresenter(Data data) ,还没有实现。由于这里的 BaseMvpView 是 abstract 的，所以它可以不实现，也实现不了，因为实现这方法需要知道泛型参数 Data 的具体类型，所以这个函数是留给子类去实现的。上面三个抽象方法也很好理解，就是用于子类初始化操作的，并且都在基类初始化之后才执行，这一点很重要，因为子类中是需要将布局文件给 add 到基类布局当中的，所以基类的组件也必须提前初始化好。下面就看看子类中是如何处理的。 SohuAlbumInfoActivity 的重构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * @author：ZengFanyu * Function: */public class SohuAlbumInfoActivity extends BaseMvpActivity&lt;List&lt;VideoInfo&gt;&gt; &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam = new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; private boolean mIsFromRefresh = false;// private View mContentView; @Override protected void beforeInitViews() &#123; mRecyclerView = new PullLoadRecyclerView(this); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); mContentContainer.addView(mRecyclerView, lp); // View contentView = LayoutInflater.from(this).inflate(R.layout.activity_album_view, null);// FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);// mContentContainer.addView(contentView, lp); &#125; @Override protected void initViews() &#123; setSupportActionBar(); //表示当前页面支持ActionBar setTitle(TAG); setSupportArrowActionBar(true); mAlbumPresenter = new AlbumPresenter(this, Album.class); mTipView.setText(TAG);// mRecyclerView = (PullLoadRecyclerView)mContentView.findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); &#125; &#125;); &#125; @Override protected void afterInitViews() &#123; &#125; @Override public void showDataFromPresenter(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); mTipView.setText(TAG); &#125; &#125;); &#125; &#125;&#125; 15 行的 beforeInitViews 方法，就是用于初始化子类的布局的，由于这个子类布局比较简单， 就是一个 RecyclerView ，所以可以直接用代码实现，然后给 add 进父类的 mContentContainer，或者用下面注释掉的，常规尝试来实现。 第 5 行，泛型参数为 List&lt;VideoInfo&gt; ,这个参数就是用于上面提到的，未实现的方法当中的，指定了泛型参数的类型。 第 26 行的 initViews 方法就用户初始化子类的 View showDataFromPresenter 的写法和未封装之前是一样的。 LatestNewsTitleActivity 的重构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author ZengFanyu */public class LatestNewsTitleActivity extends BaseMvpActivity&lt;List&lt;String&gt;&gt; &#123; private ListView mListView; private LatestNewsPresenter mBasePresenter; LatestNewsAdapter mAdapter; private View mContentView; @Override protected void beforeInitViews() &#123; mContentView = LayoutInflater.from(this).inflate(R.layout.activity_latest_news, null); FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); mContentContainer.addView(mContentView, lp); &#125; @Override protected void initViews() &#123; mBasePresenter = new LatestNewsPresenter(this, LatestNews.class); mTipView.setText(LatestNews.class.getSimpleName()); mListView = (ListView) mContentView.findViewById(R.id.id_list_view); Button btnLatestNews = (Button) mContentView.findViewById(R.id.id_btn_latest_news); btnLatestNews.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mBasePresenter.requestServer(null); &#125; &#125;); &#125; @Override protected void afterInitViews() &#123; &#125; @Override public void showDataFromPresenter(List&lt;String&gt; titles) &#123; if (mAdapter != null) &#123; mAdapter.clear(); mAdapter = null; &#125; mAdapter = new LatestNewsAdapter(titles, mContext); mListView.setAdapter(mAdapter); mAdapter.notifyDataSetChanged(); mTipView.setText(LatestNews.class.getSimpleName()); &#125;&#125; 写法和上面一样，但是比起之前的代码量来说，已经少了很多了，并且对比这两个子类，都没有重复的实现方法，只专注于自己需要实现的逻辑。 还有其他的 View 层类和上述的实现过程类似，此处不再赘述。 下一篇这个系列的最后一篇准备些关于 MVP 模式在开发中使用，随着项目的复杂程度的提高， Presenter 会越来越臃肿的问题的解决思路。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（五）封装之后的OkHttp工具在Model层的使用","slug":"MVP5","date":"2017-11-02T12:37:15.000Z","updated":"2017-11-04T09:39:14.077Z","comments":true,"path":"2017/11/02/MVP5/","link":"","permalink":"http://zengfanyu.top/2017/11/02/MVP5/","excerpt":"摘要:在上一篇中对 OkHttp 进行了简单的封装,但是没有使用到这个系列当中的 Demo 里面,这一章就使用上一篇封装的 OkHttp 工具,替换掉之前 Demo 里面的 Model 层的网络请求.并且之前的部分接口方法都没有使用,比如说 IBasePresenter 接口中的 HashMap getParams() 方法, IBasePaginationPresenter 中的 boolean hasMoreData() 方法，算是对上一篇的补充。","text":"摘要:在上一篇中对 OkHttp 进行了简单的封装,但是没有使用到这个系列当中的 Demo 里面,这一章就使用上一篇封装的 OkHttp 工具,替换掉之前 Demo 里面的 Model 层的网络请求.并且之前的部分接口方法都没有使用,比如说 IBasePresenter 接口中的 HashMap getParams() 方法, IBasePaginationPresenter 中的 boolean hasMoreData() 方法，算是对上一篇的补充。 Model 层原来的写法拿分页数据获取的 Model 层举例,当时在 SohuAlbumModel 中是这样获取数据的: 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void sendRequestToServer(Param param) &#123; String validUrl = null; Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"has more data ?\" + mPaginationPresenter.hasMoreData()); if (param != null &amp;&amp; !TextUtils.isEmpty(url) &amp;&amp; mPaginationPresenter.hasMoreData()) &#123; validUrl = getValidUrl(url, param); Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl); &#125; if (!TextUtils.isEmpty(validUrl)) &#123; HttpUtils.executeByGet(validUrl, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \"); e.printStackTrace(); mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\"); mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url); &#125; String responseJson = response.body().string(); Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson); mPaginationPresenter.accessSuccess(responseJson); &#125; &#125;); &#125; else &#123; Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\"); &#125;&#125;private String getValidUrl(String url, Param param) &#123; return String.format(url, param.getPageIndex(), param.getPageSize());&#125; url 当中的参数是直接在 sendRequestToServer 方法中传递进来的,这么一来会让 Model 层的职责变得不那么单一,因为 Model 层只应该负责数据相关的工作,此处的 params 传递进来,还需要进行一个 url 的拼接工作,所以在这里是可以优化的地方。 在看看上一篇中的 OkHttpManager 类中请求服务器数据的核心方法： 123456789101112131415161718192021/** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 使用 OkHttpManager 来请求服务器获得数据，第二个参数 HashMap&lt;String, String&gt; paramsMap 就是已经在 Presenter 层中处理好的键值对参数，然后在 CommonRequest.createGetRequest(baseUrl, requestParams); 或者是 CommonRequest.createPostRequest(baseUrl, requestParams) 中就已经把完整的 url 拼接出来了。具体如何拼接，如何构造 Request 对象，Model 层完全不用关心，它只需要在请求成功或者是请求失败的回调接口中将数据回调到 Presenter 层去即可。 那么现在就开始重构 Model 层的方法。 Model 层现在的写法12345678910111213141516171819202122@Overridepublic void sendRequestToServer() &#123; if (mPaginationPresenter.hasMoreData()) &#123; OkHttpManager.getInstance().requestServerData(method, baseUrl, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; @Override public void onSuccess(Object responseObj) &#123; String responseJson = (String) responseObj; Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); mPaginationPresenter.accessSuccess(responseJson); &#125; @Override public void onFailure(OkHttpException exception) &#123; Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode()); mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url); &#125; &#125;, null)); &#125;else &#123; Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"No more data!\"); &#125;&#125; 是不是简单了很多！和之前的方法相比较，有三处不同的地方： 第 2 行的 sendRequestToServer() 方法中已经没有了 param 参数了。（那么参数从哪儿来呢？） 第 3 行多了一个 hasMoreData() 的方法，用于判断服务器端还有没有更多的数据。若没有，那就没有必要去请求了。它是在哪儿初始化的？ 第 4 行的多了 mPaginationPresenter.getParams() ，它是在什么地方初始化的? 第 4 行的 baseurl 不是之前 Model 层的 url 下面就解释为什么可以这么操作。 BasePaginationPresenter 的修改观察之前 Model 层的写法就知道，这个地方的参数，主要是从其中取出 pageIndex 和 pageSize ，用于拼接新的 url ，然后再请求数据，这儿不需要这个参数了， 那肯定就是有地方已经提供了这个参数了咯。 对，就是 mPaginationPresenter.getParams() 这个之前没有用过的方法，先回顾一下这个方法在哪儿定义的： 1234567891011public interface IBasePresenter&lt;Param&gt; &#123; //省略部分代码 /** * 在Model层中调用，此方法用于获取Presenter层处理好的参数 * @author zfy * @return 请求参数 * @Created at 2017/10/21/021 15:05 */ HashMap&lt;String, String&gt; getParams();&#125; 在第二篇中，针对每一层封装的时候，这个接口就已经定义好了，只是一直没有使用上，在这儿就用上了。而 BasePaginationPresenter 类是实现这个街口的，并且这个 Presenter 是分页请求数据中 Presenter 层的基类，在第三篇也提到过。下面看看 BasePaginationPresenter ： 1234567891011121314151617181920212223242526272829303132333435/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePaginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; //省略部分代码 /** * 子类实现，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); /** * 子类实现,用于返回请求服务器的url当中的参数 * * @return HashMap&lt;String,String&gt; url 中的 kay value 对 */ public abstract HashMap&lt;String, String&gt; getHttpRequestParams(); //省略部分代码 @Override public HashMap&lt;String, String&gt; getParams() &#123; return getHttpRequestParams(); &#125; @Override public boolean hasMoreData() &#123; return serverHaveMoreData(); &#125;&#125; 只贴出和之前不同的部分， 多了一个 serverHaveMoreData() 抽象方法，子类去实现的，用于判断服务器还有没有更多的数据。 多了以个 getHttpRequestParams() 抽象方法，子类去实现，用于将参数填充到 HashMap 中，供 Model 层使用。 接下里看看子类 AlbumPresenter 的实现： AlbumPresenter 的修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private int mTotalCount=-1; public AlbumPresenter(BaseMvpActivity baseListView, Class&lt;Album&gt; aClass) &#123; super(baseListView, aClass); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL_BASE); &#125; //省略代码 @Override public void serverResponse(Album album) &#123; //省略代码 mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际适用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); //第一次需要返回true 才能进到 serverResponse 方法中去初始化 mTotalCount 值 return mTotalCount == -1 || (pageIndex * pageSize) &lt;= mTotalCount; &#125; @Override public HashMap&lt;String, String&gt; getHttpRequestParams() &#123; HashMap&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); paramsMap.put(\"cid\", \"2\"); paramsMap.put(\"o\", \"1\"); paramsMap.put(\"plat\", \"6\"); paramsMap.put(\"poid\", \"1\"); paramsMap.put(\"api_key\", \"9854b2afa779e1a6bff1962447a09dbd\"); paramsMap.put(\"sver\", \"6.2.0\"); paramsMap.put(\"sysver\", \"4.4.2\"); paramsMap.put(\"partner\", \"47\"); paramsMap.put(\"page\", String.valueOf(mParam.getPageIndex())); paramsMap.put(\"page_size\", String.valueOf(mParam.getPageSize())); return paramsMap; &#125;&#125; 与之前实现不同地方在于： 构造方法当中设置的 url ，现在是 baseUrl ，后面的参数由 getHttpRequestParams方法生成，在CommonRequest 中生成完整 url。 serverResponse() 方法中，对 mTotalCount 进行了初始化， 这个值就是记录服务器端一共有多少条数据的。 serverHaveMoreData()拿当前已经加载的数据条数和 mTotalCount 进行对比，判断是否还有数据。 getHttpRequestParams() 构造参数的 HashMap 。 小结从这一章的从重构部分代码，很明显可以看到，各层之间的依赖关系： 主要是替换网络请求的工具，那么就是只涉及到 Model 层的改动。 这里 Presenter 层改动了，其实是不需要改动的， 这里改动了的原因是，我把之前没有实现的功能补上了，并且将sendRequestToServer() 的参数去掉了导致的。 可以发现， View 层代码没有进行一点修改，也就是 Activity 并没有动。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（四）插曲-封装OkHttp","slug":"MVP4","date":"2017-10-27T14:37:15.000Z","updated":"2017-10-29T12:38:18.194Z","comments":true,"path":"2017/10/27/MVP4/","link":"","permalink":"http://zengfanyu.top/2017/10/27/MVP4/","excerpt":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，并且可用性也不高，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。","text":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，并且可用性也不高，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。 官方给的例子 同步方法 1234567891011OkHttpClient client = new OkHttpClient();String run(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string();&#125; 异步方法 1234567891011121314151617OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125; 封装思路结合上面异步方法，稍作分析，涉及到如下几个对象 OkHttpClient , Request , Call,Response ,其他的都一些方法的调用，而 Response 是返回结果的对象，所以我们的封装应该重点针对剩余三个对象来进行。 RequestRequest 在 Okhttp 当中是抽象出来的一个请求对象，它封装了请求报文信息：请求的 Url 地址，请求的方法（Get Post等），各种请求头（Content-Type Cookie）以及可以选择的请求体，一般通过内部的 Builder 类来构建对象，建筑者设计模式。 那么我们这里就针对 Post Get 两种请求方式做封装，但是这里又涉及到一个问题，就是我们还需要参数，用于拼接请求 Url 的参数，举个栗子： 这是搜狐电视剧频道的 API 接口： 12http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22?cid=2&amp;o=1&amp;plat=6&amp;poid=1&amp;api_key=9854b2afa779e1a6bff1962447a09dbd&amp;%22%20+%20%22sver=6.2.0&amp;sysver=4.4.2&amp;partner=47&amp;page=1&amp;page_size=10 这么看可能特别的麻烦，我们把它拆分一下： 12String baseUrl=http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22 然后剩下的都是参数了，以键值对的形式存在： 这些参数拼接在 baseUrl 后面的顺序是没有要求的，不一定要按照上面的顺序来，只要每个参数都按照固定的格式出现就可以。 看上面的完整 Url 可以发现规律，在 baseUrl 后面有一个 ？， 然后就就是 key1=value1&amp;key2=value2&amp;key3=value3 这种形式的 其实遵循 RESTful API 设计的接口，都会是这种形式，所以这里也利于我们进行封装了。而 key-value 这种形式，就特别适合使用 Map 结构来封装。 说这么多，上代码，首先是对参数进行封装： RequestParam 12345678910111213141516171819202122232425262728293031323334353637/** * @author:fanyuzeng * @date: 2017/10/27 13:55 * @desc: 封装url中的参数 */public class RequestParams &#123; /** * 使用&#123;@link ConcurrentHashMap&#125;是为了保证线程安全 */ private ConcurrentHashMap&lt;String, String&gt; urlParams = new ConcurrentHashMap&lt;&gt;(); public RequestParams() &#123; &#125; public RequestParams(Map&lt;String, String&gt; source) &#123; for (Map.Entry&lt;String, String&gt; entry : source.entrySet()) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; public RequestParams(String key, String value) &#123; put(key, value); &#125; private void put(String key, String value) &#123; if (!TextUtils.isEmpty(key) &amp;&amp; !TextUtils.isEmpty(value)) &#123; urlParams.put(key, value); &#125; &#125; public ConcurrentHashMap&lt;String, String&gt; getUrlParams() &#123; return urlParams; &#125;&#125; 这地方使用 ConcurrentHashMap 就是为了保证线程安全的，这个类使用的是锁分段技术，不同于一般的同步方法或者是同步代码块，它只会锁住其中一个 segment，其他的 segment 仍然是可以访问的，所以他的效率会比 synchronized 高。 有了 RequestParam 之后，就可以使用它来拼接 url，有了 url 之后，就可以使用它来构建 Request对象了。 CommonRequest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1 /** 2 * @author: fanyuzeng 3 * @date: 2017/10/27 14:08 4 * @desc: response for build various kind of &#123;@link okhttp3.Request&#125; include Get Post upload etc. 5 */ 6 public class CommonRequest &#123; 7 private static final String TAG = \"CommonRequest\"; 8 /** 9 * create a Get request10 *11 * @param baseUrl base url12 * @param params see &#123;@link RequestParams&#125;13 * @return &#123;@link Request&#125;14 * @created at 2017/10/27 14:3915 */16 public static Request createGetRequest(@NonNull String baseUrl, @Nullable RequestParams params) &#123;17 StringBuilder urlBuilder = new StringBuilder(baseUrl).append(\"?\");18 if (params != null) &#123;19 //将请求参数合并进url中20 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;21 urlBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&amp;\");22 &#125;23 24 Log.d(TAG,\"&gt;&gt; createGetRequest &gt;&gt; \" + urlBuilder.toString());25 &#125;26 return new Request.Builder().get().url(urlBuilder.substring(0, urlBuilder.length() - 1)).build();27 &#125;28 29 /**30 * create a post request31 *32 * @param baseUrl base url33 * @param params see &#123;@link RequestParams&#125;34 * @return &#123;@link Request&#125;35 * @created at 2017/10/27 14:3936 */37 public static Request createPostRequest(@NonNull String baseUrl, @NonNull RequestParams params) &#123;38 FormBody.Builder mFormBodyBuilder = new FormBody.Builder();39 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;40 mFormBodyBuilder.add(entry.getKey(), entry.getValue());41 &#125;42 FormBody formBody = mFormBodyBuilder.build();43 return new Request.Builder().post(formBody).url(baseUrl).build();44 &#125;45 46 &#125; 第 16 行的 createGetRequest 方法是用于创建一个 Get 请求，主要就是使用 StringBuilder 进行 Url 的拼接，第 37 行的 createPostRequest 方法是用于创建一个 Post 请求的。 Post 请求是先创建 FormBody ，然后和 baseUrl 一个构造 Request 。 封装到这里， Request 就算是封装完了， 当然这里只封装了 Post Get ，也可以继续封装文件上传和文件下载的Request。 CallCall 代表的是一个实际的 HTTP 请求，它是链接 Request 和 Response 的桥梁，通过 Request 对象的 newCall 方法可以得到一个 Call 对象，既支持同步获取数据，也支持异步，在上面官方例子里，也可以看出来，在异步回调中，当获取到数据，会将 Response 对象传入 Callback 的 onSuccess 方法中，如果请求没有成功，就会调用 onFailure 方法（Response 下面说）。那么看看 Callback 是什么。 先看看官方的 Callback 是什么 ： 1234567public interface Callback &#123; void onFailure(Call call, IOException e); void onResponse(Call call, Response response) throws IOException;&#125; 对，把注释删除了之后，其实就是两个接口，简单的理解成，一个是请求成功时的回调，一个是请求失败时的回调。 那么对这一层的封装思路是这样子的： 一般来说，在上层，我们是需要去处理上面两个回调的，在 onFailure 中，请求失败，应该做什么操作，在 onResponse 中，HTTP 返回的状态码在 [200,300）之间应该有什么操作，在其他区间又应该有什么操作。那么在这里，我们就创建一个类，去实现这个接口，将基本的处理都在这个类里写好，出错误了，就拿到 erroeCode errorMsg 回调给上层，正确的返回信息，就直接回调给上一层。 那么这里就涉及到我们自定义的一个 Exception 和 Listener 以及实现了 Callback 接口的 CommonCallback 类。 OkHttpException 1234567891011121314151617181920212223/** * @author:fanyuzeng * @date: 2017/10/27 13:44 * @desc: */public class OkHttpException extends Exception &#123; private int mErrorCode; private String mErrorMsg; public OkHttpException(int errorCode, String errorMsg) &#123; this.mErrorCode = errorCode; this.mErrorMsg = errorMsg; &#125; public int getErrorCode() &#123; return mErrorCode; &#125; public String getErrorMsg() &#123; return mErrorMsg; &#125;&#125; DisposeDataListener 123456789101112131415161718192021/** * @author:fanyuzeng * @date: 2017/10/27 13:49 * @desc: */public interface DisposeDataListener &#123; /** * 请求服务器数据成功时回调的方法 * * @param responseObj 需要回调到上层的请求结果 */ void onSuccess(Object responseObj); /** * 请求服务器失败时候的回调方法 * * @param exception 需要回调到上层的错误反馈 */ void onFailure(OkHttpException exception);&#125; 再将这个 Listener 用代理设计模式再封装一层 DisposeDataHandler12345678910111213141516171819202122232425262728293031/** * @author:fanyuzeng * @date: 2017/10/27 13:52 * @desc: 代理模式,使用DisposeDataHandler 代理 DisposeDataListener的操作 */public class DisposeDataHandler &#123; public DisposeDataListener mListener; public Class&lt;?&gt; mClass; public DisposeDataHandler(DisposeDataListener listener) &#123; mListener = listener; &#125; public DisposeDataHandler(DisposeDataListener listener, Class&lt;?&gt; aClass) &#123; mListener = listener; mClass = aClass; &#125; public void onSuccess(Object responseObj) &#123; mListener.onSuccess(responseObj); &#125; public void onFailure(OkHttpException exception) &#123; mListener.onFailure(exception); &#125; public Class&lt;?&gt; getClassType() &#123; return mClass; &#125;&#125;此处用代理模式，主要是为了优雅（装X）的处理 Class&lt;?&gt; 这个对象，这是用于映射的类型，在调用 Listener 的回到方法之后做判断这个对象是否存在，是，则再映射在返回，否，直接返回。然后将三面三个类聚合到一起CommonJsonCallback 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @author:fanyuzeng * @date: 2017/10/27 14:41 * @desc: */public class CommonJsonCallback implements Callback &#123; private static final String TAG = \"CommonJsonCallback\"; private static final String MSG_RESULT_EMPTY = \"request could not be ececuted\"; private static final String MSG_JSON_EMPTY = \"json is empty or null\"; private static final String MSG_RETURN_CODE = \"http return code is not [200,300)\"; private static final int NETWORK_ERROR = -1; private static final int JSON_ERROR = -2; private Handler mDeliveryHandler = new Handler(Looper.getMainLooper()); private Gson mGson = new Gson(); private DisposeDataHandler mDisposeDataHandler; public CommonJsonCallback(DisposeDataHandler dataHandler) &#123; mDisposeDataHandler = dataHandler; &#125; @Override public void onFailure(@NonNull Call call, @NonNull final IOException e) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RESULT_EMPTY + e.getMessage())); &#125; &#125;); &#125; @Override public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RETURN_CODE + response.message())); &#125; &#125;); &#125; final String resultJson = response.body().string(); mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; handleResponse(resultJson); &#125; &#125;); &#125; private void handleResponse(String resultJson) &#123; if (TextUtils.isEmpty(resultJson)) &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_JSON_EMPTY)); return; &#125; if (mDisposeDataHandler.getClassType() == null) &#123; mDisposeDataHandler.onSuccess(resultJson); &#125; else &#123; Object mappedDataType = mGson.fromJson(resultJson, mDisposeDataHandler.getClassType()); if (mappedDataType == null) &#123; mDisposeDataHandler.onFailure(new OkHttpException(JSON_ERROR, MSG_JSON_EMPTY)); &#125; else &#123; mDisposeDataHandler.onSuccess(mappedDataType); &#125; &#125; &#125;&#125; 自我感觉用代理之后，处理对象都是 DisposeHandler ，不会在看到 Listener Class&lt;?&gt; ,适应起来方便些了。 要注意一点是，在 onResponse 方法中，还是在子线程中的，要及时切换线程。 到这里，就对 Call 这个对象封装完成了。 ResponseResponse 类封装了响应报文信息：状态吗（200、404 等）、响应头（Content-Type、Server 等）以及可选的响应体。可以通过 Call 对象的 execute() 方法获得 Response 对象，异步回调执行 Callback 对象的 onResponse 方法时也可以获取 Response 对象。 这东西人家已经给我们封装好了， 需要什么直接去拿就行， 也不需要在封装。 OkHttpClient官方文档有这么一句话： OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools. 翻译一下：当你使用一个全局的 OkHttpClient ，并且重用它发起 HTTP 请求的时候，OkHttp 的能够发挥最 NB 的性能，因为每一个客户端都持有它的连接池和线程池，如果这俩东西可以重用的话，那么就能减少潜在的因素，并且节省内存，相反的，如果为每一个客户端的每一个请求都创建一个 OkHttpClient ，那么就会浪费空闲的连接池和线程池中的资源。 叽叽歪歪这么多，就是说用 OkHttpClient 的时候要用单例模式。 刚开始我是这么设计的： CommonokHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author:fanyuzeng * @date: 2017/10/27 15:21 * @desc: */@Deprecatedpublic class CommonOkHttpClient &#123; private static final int TIME_OUT = 30; private static OkHttpClient sOkHttpClient; static &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https sOkHttpClient = builder.build(); &#125; /** * 请求服务器数据的方法 * * @param request Use &#123;@link com.project.fanyuzeng.mvpdemo.utils.okhttp.request.CommonRequest&#125; to build * @param handler see &#123;@link DisposeDataHandler&#125; proxy class */ public static void requestServerData(Request request, DisposeDataHandler handler) &#123; sOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 恩，静态代码块中初始化实例化 OkHttpClient，我认为饿汉模式没有本质的区别， 但是这种方式比饿汗模式的初始化时间更早。 好吧 ，我承认我懒，不想在整个单例类出来。。 这样写，也没什么问题，但是外界在使用的使用，比较麻烦 创建RequestParams，涉及到 HashMap 的好多 put 操作 用 RequestParam 去初始化 CommonRequest 在上层根据请求方式去创建对应的 Request 再实例化一个DisposeHandler 所以只好接着封装吧，分析上面 4 个步骤，其中步骤 1 那是不能再简化了的，因为具体的请求参数肯定是要从外界传进来的，这里涉及到的 HashMap 以及它的 put 操作是不可避免的。步骤 2 和步骤 3 完全是可以封装一下的，步骤 4 也是需要从外外界回调的方法，类似于点击监听的 onClick 方法回调。 所以把 CommonOkHttpClient 给 Deprecated 掉，重新来一个 OkHttpManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author:fanyuzeng * @date: 2017/10/27 17:57 * @desc: */public class OkHttpManager &#123; private static volatile OkHttpManager sManager; private OkHttpClient mOkHttpClient; private OkHttpManager() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https mOkHttpClient = builder.build(); &#125; public static OkHttpManager getInstance() &#123; if (sManager == null) &#123; synchronized (OkHttpManager.class) &#123; if (sManager == null) &#123; sManager = new OkHttpManager(); &#125; &#125; &#125; return sManager; &#125; /** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */ public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125; &#125;&#125; 好吧，还是用双重锁模式的单例比较放心 。 到此就封装完了，下面简单的使用一下。 使用姿势12345678910111213 1 OkHttpManager.getInstance().requestServerData(method, url, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; 2 @Override 3 public void onSuccess(Object responseObj) &#123; 4 String responseJson = (String) responseObj; 5 Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); 6 mPaginationPresenter.accessSuccess(responseJson); 7 &#125; 8 @Override 9 public void onFailure(OkHttpException exception) &#123;10 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode());11 mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url);12 &#125;13 &#125;,null)); 没有将 Json 数据映射成实体类， 所以在 13 行构造 DisposeDataHandler 的时候，第二个 类参数传的是 null。 这个例子是结合上一篇请求分页数据来用的，所以这里直接将 Json 数据抛给 Presenter 层，让它去处理。 第 1 行的 mPaginationPresenter.getParams() 就是拿 url 中的参数。 由于篇幅的限制，这一篇先到这里，下一篇再把这个封装的 OkHttp 工具用于 MVP 模式的 Demo 当中 最后，贴个 AS 中封装之后工具的结构图。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（三）基于分页列表的封装","slug":"MVP3","date":"2017-10-25T12:37:15.000Z","updated":"2017-10-28T10:30:28.153Z","comments":true,"path":"2017/10/25/MVP3/","link":"","permalink":"http://zengfanyu.top/2017/10/25/MVP3/","excerpt":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。","text":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。 presenter 层作为 MVP 模式的桥梁， 那就先从这一层开始说起吧。 Presenter上一篇中对 Presenter 层的公共方法进行了抽取并且封装成了一个接口 IBasePresenter ，那么现在我们需要实现分页加载还有刷新的功能，那么在 IBasePresenter 接口的基础之上，在对其封装一个接口 IBasePeginationPresenter：123456789101112131415161718192021222324252627/** * Created by fanyuzeng on 2017/10/23. * Function:在IBasePresenter的基础上扩展的接口，适用于分页加载的情况 */public interface IBasePaginationPresenter&lt;Param&gt; extends IBasePresenter&lt;Param&gt; &#123;/** * 刷新数据的接口 * * @param param 访问服务器的参数 * @created at 2017/10/23 20:07 */void refresh(Param param);/** * 加载更多的接口 * * @created at 2017/10/23 20:07 */void loadingNext();/** * 用于判断服务器端是否还有更多的数据 * @return true -还有更多数据 - false 没有更多的数据 */boolean hasMoreData();&#125; 也是一个泛型的接口，增加的三个方法 ： refresh(Param param) 在 View 层调用，用于通知 Model 层刷新数据 loadingNext() 在 View 层调用，用于通知 Model 层加载下一页数据 hasMoreData() 在 Model 层请求网络数据前调用做判断，是否还有下一页数据 有了针对分页刷新的接口之后，还需要有一个实现它的基类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePeginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; private static final String TAG = \"BasePaginationPresenter\"; private IBaseModel mBaseModel; private IBaseView mBaseListView; private Param mParam; private Class&lt;Data&gt; mClazz; private Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mHasMoreData=true; /** * 子类中调用，用于传递服务器返回的，处理好的结果 * * @param data View层需要的数据类型 * @created at 2017/10/23 20:10 */ public abstract void serverResponse(Data data); /** * 子类中调用，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); public BasePaginationPresenter(IBaseView baseListView, Class&lt;Data&gt; Clazz) &#123; this.mBaseListView = baseListView; mClazz = Clazz; mBaseModel = new SohuAlbumModel(this); &#125; @Override public void refresh(Param param) &#123; requestServer(param); &#125; @Override public void loadingNext() &#123; if (mParam != null) &#123; int pageIndex = mParam.getPageIndex(); mParam.setPageIndex(pageIndex + 1); requestServer(mParam); &#125; &#125; @Override public void requestServer(@Nullable Param param) &#123; mBaseListView.showProgress(true); mParam = param; Log.d(TAG, \"&gt;&gt; requestServer &gt;&gt; \"); getModel().sendRequestToServer(param); &#125; @Override public void accessSuccess(String responseJson) &#123; mBaseListView.showProgress(false); Gson gson = new Gson(); serverResponse(gson.fromJson(responseJson, mClazz)); mBaseListView.showSuccess(true); &#125; @Override public void cancelRequest() &#123; mBaseModel.cancelRequest(); &#125; @Override public void okHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showOkHttpError(errorCode, errorDesc, errorUrl); mBaseListView.showProgress(false); mBaseListView.showSuccess(false); &#125; &#125;); &#125; @Override public IBaseModel getModel() &#123; return mBaseModel; &#125; @Override public HashMap&lt;String, String&gt; getParams() &#123; return null; &#125; @Override public boolean hasMoreData() &#123; return ServerHaveMoreData(); &#125;&#125; 在类申明时，可以看到 Param extends BasePeginationParam ，这里的 BasePeginationParam主要是封装了摘要中提到的 PageIndex 和 PageSize 两个参数，以及他们的 Getter Seeter 方法。 重点看 IBasePeginationPresenter 中新增加的三个方法，refresh(Param param) 会重新调用一次 requestServer(Param param) （此方法在上一篇也提过了，就是通知 Model 层获取数据）； loadingNext() ，加载下一页数据的方法，就是将参数中的 PageIndex + 1 之后，重新调用 requestServer(Param param) 方法。此处只改变了页码，如果需要改变请求数据的条数，也是相应的在 loadingNext() 中修改 PageSize 的值。 hasMoreData() ,这里返回抽象方法 serverhaveMoreData() ，这个方法是在子类中实现的，子类解析了数据之后，判断服务器是否还有数据返回。 然后有需要实现分页功能的 Presenter 就可以直接继承 BasePaginationPresenter 。 Model 层由于 Model 层的职责比较单一，就是向数据源请求数据，并且返回给 Presenter 层，所以此处不需要额外封装接口或者是基类，只需要重新实现上一篇中提到的 IBaseModel 接口即可。 View 层此处和请求一次数据相比较， View 层就是需要在两个事件触发的时候，重新设置参数通知 Presenter 去请求数据，然后再展示出来。这两个事件分别是：上拉到底时加载更多、下拉时刷新数据（当然可以别的）。 针对上一小节中封装类的具体实现View 层的具体实现主要是展示电视剧的主要信息，那么需要提供一个接口方法，给 Presenter 层调用，展示处理好的 JavaBean：1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 此处的 VideoInfo 是一个JavaBean，对应的就是电视剧信息的实体类。1234567891011121314public class VideoInfo &#123; @SerializedName(\"main_actor\") private String mMainActor; @SerializedName(\"total_video_count\") private int mTotalVideoCount; @SerializedName(\"album_name\") private String mAlbumName; @SerializedName(\"director\") private String mDirector; @SerializedName(\"publish_time\") private String mPublishTime; //Getter and setter methods&#125; 之前映射数据需要保证字段名和 Json 数据的字段名一致，其实本来把这个类的字段名改得一致就行啦，但是服务器端返回的数据字段，很多都是以“_”进行连接，而不是使用驼峰命名法则，这个时候 Gson 的 @SerializedName 注解就派上用场了，注解中用服务器端返回值字段，成员变量仍然使用驼峰命名法。但是上个周末安装了最近 Alibaba 10 月 14 日 推出的 Coding Guidelines 插件，发现代码中很多不规范的地方，并且人家规定了成员变量就必须要使用驼峰命名！所以我决定要按照这个插件的规范来写代码了，虽然现在进不了大厂，但是先熟悉大厂的代码规范也是好事，哈哈~ 咳咳，按照大厂的代码规范，成员变量的命名必须使用驼峰命名法！这个插件是真心好用，比如对类名要 javadoc 注释 参数、返回值、异常说明、此方法做什么事情、实现什么功能（领域模型相关命名除外，比如：DO、BO、DAO），并且是全中文的！直接在 AS 的 Inspection Results 窗口中显示，这 IDE 内置功能啥时候讲过中文反馈结果的？ 《阿里巴巴Java开发规约》插件全球首发！ 广告时间结束，言归正传！ 这个 Activity 实现了 ISohuSerials 接口，布局文件和上一篇一样，只是把 ListView 换成了自定义的 PullLoadRecyclerView 了，这个RecycyclerView 支持上拉加载更多和下拉刷新， 这里不展开说了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author：ZengFanyu */public class SohuAlbumInfoActivity extends AppCompatActivity implements ISohuSerials &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private Context mContext; private ProgressBar mProgressBar; private TextView mTip; private RelativeLayout mContainer; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam= new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mIsFromRefresh = false; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_album_view); mContext = this; mAlbumPresenter = new AlbumPresenter(this, Album.class); mContainer = (RelativeLayout) findViewById(R.id.id_success_content); mTip = (TextView) findViewById(R.id.id_tip); mProgressBar = (ProgressBar) findViewById(R.id.id_progress_bar); mRecyclerView = (PullLoadRecyclerView) findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); //通知Presenter层刷新数据 mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); //通知Presenter层加载下一页数据 &#125; &#125;); &#125; @Override public void showAlbumMainInfo(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;); &#125; &#125; @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"http err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc + \",errUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"server err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContainer.setBackgroundResource(android.R.color.white); mTip.setText(\"Sohu Serials album\"); &#125; else &#123; mContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125;&#125; 在上面代码中可以看到: 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onRefresh() 回调方法中，核心代码就是这一行 mAlbumPresenter.refresh(mParam); ，通知 Presenter 层去刷新数据， 至于 Presenter 层如何刷新。。 关我 View 层 X 事~ 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onLoadMore() 回调方法中,也是直接调用 mAlbumPresenter.loadingNext()。 下面说说 Presenter 层的代码 Presenter 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private ISohuSerials mBaseListView; private Handler mHandler = new Handler(Looper.getMainLooper()); private int mTotalCount; public AlbumPresenter(ISohuSerials baseListView, Class&lt;Album&gt; CLazz) &#123; super(baseListView, CLazz); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL); &#125; @Override public void serverResponse(Album album) &#123; mBaseListView.showAlbumMainInfo(album.getData().getVideos()); mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showProgress(false); &#125; &#125;); mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际使用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); return (pageIndex * pageSize) &lt;= mTotalCount; &#125;&#125; 首先是要继承之前编写的 BasePaginationPresenter类，泛型参数 BasePaginationParam 可以根据实际需求进行拓展，基本使用在前面已经介绍过，此处不做赘述。 Album 是搜狐视频电视剧频道返回数据的实体类，上面提到的 VideoInfo 包含在 Album 里面，因为现在只需要展示 VideoInfo 里的信息， 所以在 serverRespomse 方法里，有一个转换 mBaseListView.showAlbumMainInfo(album.getData().getVideos()); 实现父类 BasePaginationPresenter 中的抽象方法 serverHaveMoreData() ,思路就是 当前页面数 * 每一页的数据量，然后和 数据总量 比较大小。 Model 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 1 /** 2 * @author：ZengFanyu 3 */ 4 public class SohuAlbumModel&lt;Param extends BasePaginationParam&gt; implements IBaseModel&lt;Param&gt; &#123; 5 private static final String TAG = \"SohuAlbumModel\"; 6 private String url; 7 private int method; 8 private IBasePaginationPresenter mPaginationPresenter; 9 10 public SohuAlbumModel(IBasePaginationPresenter paginationPresenter) &#123;11 mPaginationPresenter = paginationPresenter;12 &#125;13 14 @Override15 public void sendRequestToServer(Param param) &#123;16 String validUrl = null;17 if (param != null &amp;&amp; !TextUtils.isEmpty(url)&amp;&amp;mPaginationPresenter.hasMoreData()) &#123;18 validUrl = getValidUrl(url, param);19 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl);20 &#125;21 Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"check param,url and server have data or not!\")22 if (!TextUtils.isEmpty(validUrl)) &#123;23 HttpUtils.executeByGet(validUrl, new Callback() &#123;24 @Override25 public void onFailure(Call call, IOException e) &#123;26 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \");27 e.printStackTrace();28 mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url);29 &#125;30 31 @Override32 public void onResponse(Call call, Response response) throws IOException &#123;33 if (!response.isSuccessful()) &#123;34 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\");35 mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url);36 &#125;37 38 String responseJson = response.body().string();39 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson);40 mPaginationPresenter.accessSuccess(responseJson);41 42 &#125;43 &#125;);44 &#125; else &#123;45 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\");46 &#125;47 &#125;48 49 private String getValidUrl(String url, Param param) &#123;50 return String.format(url, param.getPageIndex(), param.getPageSize());51 &#125;52 53 54 @Override55 public void setRequestUrl(String url) &#123;56 this.url = url;57 &#125;58 59 @Override60 public void setRequestMethod(int method) &#123;61 this.method = method;62 &#125;63 64 @Override65 public void cancelRequest() &#123;66 HttpUtils.cancelCall();67 &#125;68 &#125; Model 层的实现还是跟之前的一样，直接实现 IBaseModel 接口即可。 在 17 行可以看到，mPaginationPresenter.hasMoreData() ，这个就是对服务器点是否还有数据可以返回的判断，如果这里返回 false 那么就不回去进行网络请求,然后在 22 行打印个 Log 提醒。 在看看 49 行的 getVaildUrl 方法，这个方法主要就是把传进来的 param 参数拼接进 url 中，形成有效的，可以请求到数据的 Url。 效果图 Item 就展示了一下电视剧的 主演、名字、导演、集数、更新时间的信息。 小结通过上面的封装和例子，起码证明了这一套封装能够跑的通了，以后如果还有关于分页请求的需求，可以直接继承上面的基类来实现，无非就是修改param 和 Data 两个泛型的参数。 前者是请求 url 的参数，根据具体的业务需求，封装 BasePaginationParam 的子类即可。 后者是服务器端返回数据的实体类，也是根据数据的结构来封装的，在 Android Studio 中有 Gson Formatter 这个插件，封装 JavaBean 插件也轻松很多，在结合上面提到的 Gson 注解，全套了。 下一篇准备封装一下 OkHttp ,然后将封装之后的 OkHttp 整合到当前框架中,当然了,还是以分页接在为例","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android 当中的 MVP 模式（二）封装","slug":"MVP2","date":"2017-10-22T14:00:15.000Z","updated":"2017-10-28T10:38:12.190Z","comments":true,"path":"2017/10/22/MVP2/","link":"","permalink":"http://zengfanyu.top/2017/10/22/MVP2/","excerpt":"摘要：在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。","text":"摘要：在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。 一个简单的网络请求 一个简单的需求：通过 url 获取数据，然后用 Gson 解析成 JavaBean，然后展示到 ListView上。这里使用知乎日报的获取最新消息的 API 接口 https://news-at.zhihu.com/api/4/news/latest 那么按照普通 MVP 的思路，首先 view 层： 为了突出重点，当前View层只做一件事情：就是展示获取的数据 ILatestVIew 此接口需要一个 String 类型的列表数据，主要是用于给 Adapter 展示用。 LatestViewActivity 很简答，就是实现接口。 IRequestLatestModel 请求服务器端数据的接口 RequestLatestNewsModel 使用 okhttp 请求数据，然后将返回的json类型数据传递给 Presenter 层。 ILatestNewsPresenter 一个接口用于处理 Json 数据，一个接口用于通知 model 层向服务器发起请求 。 LatestNewsPresenter 实现接口定义的方法 其中 HttpUtils 方法如下： 此处 OKhttp 也可以进行封装， 后面再写一篇文章， 专门记录，先暂时简单的使用。 运行之后，点击 button， 即可发起网络请求，运行效果如下： 弊端： 假设我们现在又有另外的一个需求， 请求知乎日报过往的消息， 对应的 API 接口为URL: https://news-at.zhihu.com/api/4/news/before/20131119,那么我就需要按照上述的方式，又写一套MVP的代码，最少又得留个类，如此一来，随着需求的增多，代码量会极具增大，但是多余增加的每层代码所做的事情又大多数相同，只是具体细节不一样，那么我们可不可以把每一层要做的事情给抽取出来，封装成基类，然后让子类去继承，去实现，这样就可以大量减少代码量？ 抱着这个问题，我就来分析一下 MVP 每一层所做的事情。 以简单网络请求为例，分析 MVP 各层的职责以上面请求知乎日报的最新消息为例，分析每一层的职责。 Model 层Model 角色主要是提供数据的存取功，并且将数据或者是错误信息回调给 Presenter 层。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。所以它主要的功能是： 1. 向数据源发起请求 2. 取消发起的请求 3. 通知 Presenter 处理结果 Presenter 层一般是通知 Model 向服务器发起请求，然后接收 Model 层的请求结果，包括成功的数据和错误的信息，同时也负责将处理之后的数据或者是错误信息通知 View 层，由 View 层作展示。所以他的主要功能是： 1. 通知 Model 层向服务器发起数据请求 2. 通知 Model 层取消这次请求 3. 接收 Model 层返回的数据 4. 接收 Model 层返回的错误信息 5. 通知 View 层接收处理之后的结果或者是错误信息 View 层此处 View 层的作用就比较专一化，只用于处理 UI 相关的事情，不再负责业务逻辑。主要职责如下： 1. Loading 状态的展示隐藏 2. 接收 Presenter 层处理后的数据 3. 接收 Presenter 层处理后的错误信息 4. 接收 Presenter 层处理后的服务器拒绝信息 嗯，差不多就是这么多吧 既然将每一层的主要职责总结了出来， 很明显就可以将这些职责「在代码中就是对应的方法」抽象成方法，然后让子类去个性化的实现。 抽取共性封装网络请求Model 层IBaseModel 其中 setMethod 和 setRequestUrl 方法直接在 Presenter 的构造方法中调用，设置好请求的方式和请求的 Url 地址，这样方便 model 层在请求服务器数据时，使用对应的参数，使用对应的请求方式。 此处没有用到 method 是因为知乎日报的最新新闻 API 接口是 Get 方式，不需要参数，所以此处没有根据请求方式来调用不同的请求方法 Presenter 层IBasePresenter Presenter 层是逻辑控制层，是 Model 层和 View 层的桥梁，对这一层抽取共性进行封装的时候，不能像 Model 层一样，把全部的功能装好好，原因如下： 1.如果将其全部封装起来，是没办法复用同一个功能模块的，并且会导致部分业务逻辑需要在 view 层中做处理，这样和 MVP 的思想相悖。 2.Presenter 层需要处理和 View 层的交互逻辑以及 Model 层返回的数据。 但是 Model 层是可以的，我是认为，Model 层就是从数据源中拿数据，并且将数据传递给 Presenter 层，所有的 Model 层做的都是这个操作，只是访问数据源的参数不同，数据源类型不同，访问数据源的方法不同而已，所以很明显可以全部抽取出来放基类中，然后各个子类去各自实现。 1. requestServer 在View层调用的接口，用于通知Model层想服务器发起请求，参数可为空，比如，有些Get方式的请求就不需要参数 2. requestSuccess 在Model层调用，通过此方法将服务器返回的数据传递给给Presenter层处理 3. cancelRequest 在View层调用，用于通知Model层取消请求 4. okHttpError 在Model层调用，当网络请求产生错误的时候 5. getModel 在子类中调用，用于拿到Model对象 6. getParams 在Model层中调用，此方法用于获取Presenter层处理好的参数 BasePresenter public abstract class BasePresenter&lt;Params, Data&gt; implements IBasePresenter&lt;Params&gt;这是一个泛型的抽象类，其中泛型Params是用于model层向服务器发起请求的请求参数，Data是服务器返回的Json类对应的JavaBean类。 BasePresenter处理了View层和model层中大多数的逻辑，我们要做的就是在子类中实现public abstract void serverResponse(Data data);这个抽象方法就好了。 public abstract void serverResponse(Data data);这个方法是在用于处理model层返回的结果，然后进行处理之后回调给view层。 可以看到46、47、50、51、52行的代码给注释掉了，其实一般情况下这里是不需要注释的，这里是用于判断返回数据的errorNum errorType errorDesc信息的，这么操作，是为了实现如下功能：若返回的信息有误，则BasePresenter直接回调给View层，如果正确，才会传递给子类。 上述最后一条，需要对泛型Data在进行一次封装，并且使用上 Gson 的@SerializedName(value = &quot;...&quot;,alternate = {&quot;...&quot;,&quot;...&quot;,&quot;...&quot;})这个注解，并且这里涉及到泛型擦除的问题，这一块我还没有很好的解决办法，所以此处没有进行封装。 View 层还是按照上面分析的 View 层职责来写： IBaseView 到此为止，对 MVP 模式的每一层都写出了对应的基类，有了这件基类作为基础之后，在进行同样的网络请求。 使用上述封装好的类进行相同的网络请求LatestNewsModel LatestNewsPresenter 其中Param泛型参数填的是nullable是因为这个请求是get方式，没有涉及到参数。LatestNews作为Data的泛型，主要是用于BasePresenter解析并映射。 ILatestNewsView IlatestNewsVIew接口是继承IBaseView接口的，是因为它需要在IBaseView接口所定义的功能之上，还需要实现将数据展示到列表中这么一个操作，所以添加上了一个showLatestViewTitle方法。 LatestNewsTitleActivity 这个类写起来就简单了，跟着接口来， 把之前每一个接口提到的功能给实现以下就可以了。 顺便贴个 XML 文件： 搞定，实现的效果和上面是一样的。 回过头一看，MMP，这代码量似乎也没有少很多啊，-。- ，没事没事，需求多了就少了~ 小结先看看上一篇中提到的一张图此处将MVP模式封装后，MVP的流程图如下： 后面的文章将使用上面封装的框架，通过扩展 BasePresenter 来增加新的模块。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（一）基本概念","slug":"MVP1","date":"2017-10-20T12:37:15.000Z","updated":"2017-10-28T10:45:23.740Z","comments":true,"path":"2017/10/20/MVP1/","link":"","permalink":"http://zengfanyu.top/2017/10/20/MVP1/","excerpt":"摘要：Github上看到很多项目，都是 MVP+RxJava+Retrofit+Dragger2 这种架构，再加上一个 OkHttp， 虽说这几个东西，我都或多或少听过，用过，但是从来没有认真的研究过，没有把他们整合起来开发一个应用。从 MVP 开始，认真学习这几个框架，然后整合起来，做一个应用。先立一个 FLAG！","text":"摘要：Github上看到很多项目，都是 MVP+RxJava+Retrofit+Dragger2 这种架构，再加上一个 OkHttp， 虽说这几个东西，我都或多或少听过，用过，但是从来没有认真的研究过，没有把他们整合起来开发一个应用。从 MVP 开始，认真学习这几个框架，然后整合起来，做一个应用。先立一个 FLAG！ 为什么要使用MVP在传统的Android开发中，我们一般是使用MVC模式进行开发的。 传统MVC模式介绍： View: 视图层，对应xml文件 Controller: 控制层，对应Activity和Fragment层，进行数据处理 Model：实体层，负责获取实体数据 采用MVC模式的一个最大的弊端就是xml作为View层视图能力实在太弱，所以一般情况下我们都是通过Controller层来辅助处理一些视图的。这样的结果就导致Controller既作为控制层的同时又承担了View层的大部分功能，采用MVC模式往往会导致Activity和Fragment中的代码非常复杂。我们将Android中采用的MVC模式称为MV模式更加恰当。 MVP模式介绍： View: 视图层，对应xml文件与Activity/Fragment Presenter: 逻辑控制层，同时持有View和Model对象 Model: 实体层，负责获取实体数据 MVP模式的流程图如下： 采用MVP模式的优势是： 把业务逻辑抽离到Presenter层中，View层专注于UI的处理。 分离视图逻辑与业务逻辑，达到解耦的目的。 提高代码的阅读性。 Presenter被抽象成接口，可以根据Presenter的实现方式进行单元测试。可拓展性强。 采用MVP模式的缺点： 项目结构会对后期的开发和维护有一定的影响。具体视APP的体量而定。 代码量会增多，如何避免编写过多功能相似的重复代码是使用MVP开发的一个重点要处理的问题。 有一定的学习成本。综上所述，在Android上采用MVP模式的优势是：大大优化代码的维护性与拓展性的同时对代码进行深度解耦，使各个层级的分工更加明晰。 一个简单的应用模拟Android中登陆的功能 界面 项目结构 从上图中可以看到，一个简单的基于 MVP 的项目，最少也需要创建 6 个文件夹，分别是 M、V、P 的接口和它们各自的实现类，其中 LoginActivity 就是 View 层的具体实现，它只需要负责处理 UI 的逻辑，而业务相关的逻辑都抽象到 LoginPresenter 中，这样就避免了传统开发中 Activity 、Fragment 既处理 UI 又负责业务逻辑的情况。 代码实现ILoginView： view层只负责和 UI 相关的操作，那么在这个小 Demo 中，和 UI 相关的操作有如下几点： 1. 从EditText中拿到用户输入的userName 2. 从EditText中拿到用户输入的password 3. 在登录过程中需要展示一个progressbar，登录过程结束之后隐藏这个progressbar 4. 展示登录成功后的view 5. 展示登录失败后的view 综上五个操作，所以有了ILoginView中的五个接口 LoginActivity： 当点击登录按钮时，会将请求服务器合适账号密码这个过程交给presenter层去处理，所以在LoginActivity里，会有preserent的引用。 ILoginPersenter： presenter层处理业务逻辑，有如下几点: 1. 负责接收model的返回结果并且处理 2. 将处理的结果以特定的形式，传递给view层，让view层去展示 3. 通知model层去向数据源请求数据 LoginPresenter： 因为presenter层相当于一个中间交互人，所以它必须要持有对 view 、model 层对象的引用。 ILoginModel： model负责数据的存取： 在这个Demo中，数据的存取使用一个线程和简单的字符串判断来模拟。 LoginModel： 因为model层需要将获取的数据传递给presenter层去做处理，所以此处也需要持有对presenter层的引用。 这样一来就成功的将简单的登录案例，由MVP模式来实现了, 在 LoginActivity 中处理的都是和 UI 相关的， 在 LoginPresenter 中处理的是业务的逻辑， 在 LoginModel 中处理的是网络数据获取。 小结 Presenter—交互中间人 主要作为沟通 View 和 Model 的桥梁，它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务从 View 角色上抽离出来。 View—用户界面 View 通常是指Activity、Fragment或者某个 View 控件，它含有一个 Presenter 成员变量。通常 View 需要实现一个逻辑接口，将 View 上的操作转换给 Presenter 进行实现，最后，Presenter 调用 View 逻辑接口将结果返回给 View 元素。 Model—数据的存取 对于一个结构化的 APP 来说，Model角色主要是提供数据的存取功能。Presenter 需要通过 Model 层存储、获取数据，Model就想一个数据仓库。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。 MVP 并不是一个标准化的模式，它有很多种实现方式，也可以根据自己的需求去修正MVP的实现方式，可以随着 Presenter 的复杂程度而变化，只要保证是通过 Presenter 将 View 和 Model 解耦，降低类型复杂度，各个模块单元可以独立测试、独立变化，这就是正确的方向。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-14T15:40:28.953Z","updated":"2017-10-21T16:06:55.127Z","comments":true,"path":"2017/10/14/hello-world/","link":"","permalink":"http://zengfanyu.top/2017/10/14/hello-world/","excerpt":"","text":"To be a better man1Hello , 个人博客搭好了，老规矩，先来个 Hello World！，然后，撸起袖子就是干！","categories":[],"tags":[]}]}