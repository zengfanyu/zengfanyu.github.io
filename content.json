{"meta":{"title":"THIS IS BIGZ","subtitle":"Every little makes a mickel","description":null,"author":"BigZ","url":"http://zengfanyu.top"},"pages":[{"title":"分类","date":"2017-10-25T14:59:18.000Z","updated":"2017-10-25T15:05:10.156Z","comments":false,"path":"categories/index.html","permalink":"http://zengfanyu.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-25T14:58:45.000Z","updated":"2017-10-25T15:05:14.395Z","comments":false,"path":"tags/index.html","permalink":"http://zengfanyu.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android当中的MVP模式（四）插曲-封装OkHttp","slug":"MVP4","date":"2017-10-27T12:37:15.000Z","updated":"2017-10-28T07:16:51.820Z","comments":true,"path":"2017/10/27/MVP4/","link":"","permalink":"http://zengfanyu.top/2017/10/27/MVP4/","excerpt":"","text":"摘要：前两篇中使用的网络请求工具是 OkHttp ，并没有经过封装，都是简单的使用 get 请求，并且将错误全部都抛到上层去解决了， 这无形之中增加了上层的编码复杂度，即使要抛向上层，起码也要给一个 errorCode 或者是 errorMsg 吧，所以这边文章就针对 OkHttp 进行封装，然后将封装之后的工具使用到上一小结的 Demo 之中。 官方给的例子 同步方法 1234567891011OkHttpClient client = new OkHttpClient();String run(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string();&#125; 异步方法 1234567891011121314151617OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125; 对异步方法的分析结合上面异步方法，稍作分析，涉及到如下几个对象 OkHttpClient , Request , Call,Response ,其他的都一些方法的调用，所以我们的封装应该重点针对这三个对象来进行。 RequestRequest 在 Okhttp 当中是抽象出来的一个请求对象，它封装了请求报文信息：请求的 Url 地址，请求的方法（Get Post等），各种请求头（Content-Type Cookie）以及可以选择的请求体，一般通过内部的 Builder 类来构建对象，建筑者设计模式。 那么我们这里就针对 Post Get 两种请求方式做封装，但是这里又涉及到一个问题，就是我们还需要参数，用于拼接请求 Url 的参数，举个栗子： 这是搜狐电视剧频道的 API 接口： 12http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22?cid=2&amp;o=1&amp;plat=6&amp;poid=1&amp;api_key=9854b2afa779e1a6bff1962447a09dbd&amp;%22%20+%20%22sver=6.2.0&amp;sysver=4.4.2&amp;partner=47&amp;page=1&amp;page_size=10 这么看可能特别的麻烦，我们把它拆分一下： 12String baseUrl=http://api.tv.sohu.com/v4/search/channel.json%22%20+%20%22 然后剩下的都是参数了，以键值对的形式存在： 这些参数拼接在 baseUrl 后面的顺序是没有要求的，不一定要按照上面的顺序来，只要每个参数都按照固定的格式出现就可以。 看上面的完整 Url 可以发现规律，在 baseUrl 后面有一个 ？， 然后就就是 key1=value1&amp;key2=value2&amp;key3=value3 这种形式的 其实遵循 RESTful API 设计的接口，都会是这种形式，所以这里也利于我们进行封装了。而 key-value 这种形式，就特别适合使用 Map 结构来封装。 说这么多，上代码，首先是对参数进行封装： RequestParam 12345678910111213141516171819202122232425262728293031323334353637/** * @author:fanyuzeng * @date: 2017/10/27 13:55 * @desc: 封装url中的参数 */public class RequestParams &#123; /** * 使用&#123;@link ConcurrentHashMap&#125;是为了保证线程安全 */ private ConcurrentHashMap&lt;String, String&gt; urlParams = new ConcurrentHashMap&lt;&gt;(); public RequestParams() &#123; &#125; public RequestParams(Map&lt;String, String&gt; source) &#123; for (Map.Entry&lt;String, String&gt; entry : source.entrySet()) &#123; put(entry.getKey(), entry.getValue()); &#125; &#125; public RequestParams(String key, String value) &#123; put(key, value); &#125; private void put(String key, String value) &#123; if (!TextUtils.isEmpty(key) &amp;&amp; !TextUtils.isEmpty(value)) &#123; urlParams.put(key, value); &#125; &#125; public ConcurrentHashMap&lt;String, String&gt; getUrlParams() &#123; return urlParams; &#125;&#125; 这地方使用 ConcurrentHashMap 就是为了保证线程安全的，这个类使用的是锁分段技术，不同于一般的同步方法或者是同步代码块，它只会锁住其中一个 segment，其他的 segment 仍然是可以访问的，所以他的效率会比 synchronized 高。 有了 RequestParam 之后，就可以使用它来拼接 url，有了 url 之后，就可以使用它来构建 Request对象了。 CommonRequest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 1 /** 2 * @author: fanyuzeng 3 * @date: 2017/10/27 14:08 4 * @desc: response for build various kind of &#123;@link okhttp3.Request&#125; include Get Post upload etc. 5 */ 6 public class CommonRequest &#123; 7 private static final String TAG = \"CommonRequest\"; 8 /** 9 * create a Get request10 *11 * @param baseUrl base url12 * @param params see &#123;@link RequestParams&#125;13 * @return &#123;@link Request&#125;14 * @created at 2017/10/27 14:3915 */16 public static Request createGetRequest(@NonNull String baseUrl, @Nullable RequestParams params) &#123;17 StringBuilder urlBuilder = new StringBuilder(baseUrl).append(\"?\");18 if (params != null) &#123;19 //将请求参数合并进url中20 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;21 urlBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"&amp;\");22 &#125;23 24 Log.d(TAG,\"&gt;&gt; createGetRequest &gt;&gt; \" + urlBuilder.toString());25 &#125;26 return new Request.Builder().get().url(urlBuilder.substring(0, urlBuilder.length() - 1)).build();27 &#125;28 29 /**30 * create a post request31 *32 * @param baseUrl base url33 * @param params see &#123;@link RequestParams&#125;34 * @return &#123;@link Request&#125;35 * @created at 2017/10/27 14:3936 */37 public static Request createPostRequest(@NonNull String baseUrl, @NonNull RequestParams params) &#123;38 FormBody.Builder mFormBodyBuilder = new FormBody.Builder();39 for (Map.Entry&lt;String, String&gt; entry : params.getUrlParams().entrySet()) &#123;40 mFormBodyBuilder.add(entry.getKey(), entry.getValue());41 &#125;42 FormBody formBody = mFormBodyBuilder.build();43 return new Request.Builder().post(formBody).url(baseUrl).build();44 &#125;45 46 &#125; 第 16 行的 createGetRequest 方法是用于创建一个 Get 请求，主要就是使用 StringBuilder 进行 Url 的拼接，第 37 行的 createPostRequest 方法是用于创建一个 Post 请求的。 Post 请求是先创建 FormBody ，然后和 baseUrl 一个构造 Request 。 封装到这里， Request 就算是封装完了， 当然这里只封装了 Post Get ，也可以继续封装文件上传和文件下载的Request。 CallCall 代表的是一个实际的 HTTP 请求，它是链接 Request 和 Response 的桥梁，通过 Request 对象的 newCall 方法可以得到一个 Call 对象，既支持同步获取数据，也支持异步，在上面官方例子里，也可以看出来，在异步回调中，当获取到数据，会将 Response 对象传入 Callback 的 onSuccess 方法中，如果请求没有成功，就会调用 onFailure 方法（Response 下面说）。那么看看 Callback 是什么。 先看看官方的 Callback 是什么 ： 1234567public interface Callback &#123; void onFailure(Call call, IOException e); void onResponse(Call call, Response response) throws IOException;&#125; 对，把注释删除了之后，其实就是两个接口，简单的理解成，一个是请求成功时的回调，一个是请求失败时的回调。 那么对这一层的封装思路是这样子的： 一般来说，在上层，我们是需要去处理上面两个回调的，在 onFailure 中，请求失败，应该做什么操作，在 onResponse 中，HTTP 返回的状态码在 [200,300）之间应该有什么操作，在其他区间又应该有什么操作。那么在这里，我们就创建一个类，去实现这个接口，将基本的处理都在这个类里写好，出错误了，就拿到 erroeCode errorMsg 回调给上层，正确的返回信息，就直接回调给上一层。 那么这里就涉及到我们自定义的一个 Exception 和 Listener 以及实现了 Callback 接口的 CommonCallback 类。 OkHttpException 1234567891011121314151617181920212223/** * @author:fanyuzeng * @date: 2017/10/27 13:44 * @desc: */public class OkHttpException extends Exception &#123; private int mErrorCode; private String mErrorMsg; public OkHttpException(int errorCode, String errorMsg) &#123; this.mErrorCode = errorCode; this.mErrorMsg = errorMsg; &#125; public int getErrorCode() &#123; return mErrorCode; &#125; public String getErrorMsg() &#123; return mErrorMsg; &#125;&#125; DisposeDataListener 123456789101112131415161718192021/** * @author:fanyuzeng * @date: 2017/10/27 13:49 * @desc: */public interface DisposeDataListener &#123; /** * 请求服务器数据成功时回调的方法 * * @param responseObj 需要回调到上层的请求结果 */ void onSuccess(Object responseObj); /** * 请求服务器失败时候的回调方法 * * @param exception 需要回调到上层的错误反馈 */ void onFailure(OkHttpException exception);&#125; 再将这个 Listener 用代理设计模式再封装一层 DisposeDataHandler12345678910111213141516171819202122232425262728293031/** * @author:fanyuzeng * @date: 2017/10/27 13:52 * @desc: 代理模式,使用DisposeDataHandler 代理 DisposeDataListener的操作 */public class DisposeDataHandler &#123; public DisposeDataListener mListener; public Class&lt;?&gt; mClass; public DisposeDataHandler(DisposeDataListener listener) &#123; mListener = listener; &#125; public DisposeDataHandler(DisposeDataListener listener, Class&lt;?&gt; aClass) &#123; mListener = listener; mClass = aClass; &#125; public void onSuccess(Object responseObj) &#123; mListener.onSuccess(responseObj); &#125; public void onFailure(OkHttpException exception) &#123; mListener.onFailure(exception); &#125; public Class&lt;?&gt; getClassType() &#123; return mClass; &#125;&#125;此处用代理模式，主要是为了优雅（装X）的处理 Class&lt;?&gt; 这个对象，这是用于映射的类型，在调用 Listener 的回到方法之后做判断这个对象是否存在，是，则再映射在返回，否，直接返回。然后将三面三个类聚合到一起CommonJsonCallback 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @author:fanyuzeng * @date: 2017/10/27 14:41 * @desc: */public class CommonJsonCallback implements Callback &#123; private static final String TAG = \"CommonJsonCallback\"; private static final String MSG_RESULT_EMPTY = \"request could not be ececuted\"; private static final String MSG_JSON_EMPTY = \"json is empty or null\"; private static final String MSG_RETURN_CODE = \"http return code is not [200,300)\"; private static final int NETWORK_ERROR = -1; private static final int JSON_ERROR = -2; private Handler mDeliveryHandler = new Handler(Looper.getMainLooper()); private Gson mGson = new Gson(); private DisposeDataHandler mDisposeDataHandler; public CommonJsonCallback(DisposeDataHandler dataHandler) &#123; mDisposeDataHandler = dataHandler; &#125; @Override public void onFailure(@NonNull Call call, @NonNull final IOException e) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RESULT_EMPTY + e.getMessage())); &#125; &#125;); &#125; @Override public void onResponse(@NonNull Call call, @NonNull final Response response) throws IOException &#123; if (!response.isSuccessful()) &#123; mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_RETURN_CODE + response.message())); &#125; &#125;); &#125; final String resultJson = response.body().string(); mDeliveryHandler.post(new Runnable() &#123; @Override public void run() &#123; handleResponse(resultJson); &#125; &#125;); &#125; private void handleResponse(String resultJson) &#123; if (TextUtils.isEmpty(resultJson)) &#123; mDisposeDataHandler.onFailure(new OkHttpException(NETWORK_ERROR, MSG_JSON_EMPTY)); return; &#125; if (mDisposeDataHandler.getClassType() == null) &#123; mDisposeDataHandler.onSuccess(resultJson); &#125; else &#123; Object mappedDataType = mGson.fromJson(resultJson, mDisposeDataHandler.getClassType()); if (mappedDataType == null) &#123; mDisposeDataHandler.onFailure(new OkHttpException(JSON_ERROR, MSG_JSON_EMPTY)); &#125; else &#123; mDisposeDataHandler.onSuccess(mappedDataType); &#125; &#125; &#125;&#125; 自我感觉用代理之后，处理对象都是 DisposeHandler ，不会在看到 Listener Class&lt;?&gt; ,适应起来方便些了。 要注意一点是，在 onResponse 方法中，还是在子线程中的，要及时切换线程。 到这里，就对 Call 这个对象封装完成了。 ResponseResponse 类封装了响应报文信息：状态吗（200、404 等）、响应头（Content-Type、Server 等）以及可选的响应体。可以通过 Call 对象的 execute() 方法获得 Response 对象，异步回调执行 Callback 对象的 onResponse 方法时也可以获取 Response 对象。 这东西人家已经给我们封装好了， 需要什么直接去拿就行， 也不需要在封装。 OkHttpClient官方文档有这么一句话： OkHttp performs best when you create a single OkHttpClient instance and reuse it for all of your HTTP calls. This is because each client holds its own connection pool and thread pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a client for each request wastes resources on idle pools. 翻译一下：当你使用一个全局的 OkHttpClient ，并且重用它发起 HTTP 请求的时候，OkHttp 的能够发挥最 NB 的性能，因为每一个客户端都持有它的连接池和线程池，如果这俩东西可以重用的话，那么就能减少潜在的因素，并且节省内存，相反的，如果为每一个客户端的每一个请求都创建一个 OkHttpClient ，那么就会浪费空闲的连接池和线程池中的资源。 叽叽歪歪这么多，就是说用 OkHttpClient 的时候要用单例模式。 刚开始我是这么设计的： CommonokHttpClient 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author:fanyuzeng * @date: 2017/10/27 15:21 * @desc: */@Deprecatedpublic class CommonOkHttpClient &#123; private static final int TIME_OUT = 30; private static OkHttpClient sOkHttpClient; static &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https sOkHttpClient = builder.build(); &#125; /** * 请求服务器数据的方法 * * @param request Use &#123;@link com.project.fanyuzeng.mvpdemo.utils.okhttp.request.CommonRequest&#125; to build * @param handler see &#123;@link DisposeDataHandler&#125; proxy class */ public static void requestServerData(Request request, DisposeDataHandler handler) &#123; sOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125;&#125; 恩，静态代码块中初始化实例化 OkHttpClient，我认为饿汉模式没有本质的区别， 但是这种方式比饿汗模式的初始化时间更早。 好吧 ，我承认我懒，不想在整个单例类出来。。 这样写，也没什么问题，但是外界在使用的使用，比较麻烦 创建RequestParams，涉及到 HashMap 的好多 put 操作 用 RequestParam 去初始化 CommonRequest 在上层根据请求方式去创建对应的 Request 再实例化一个DisposeHandler 所以只好接着封装吧，分析上面 4 个步骤，其中步骤 1 那是不能再简化了的，因为具体的请求参数肯定是要从外界传进来的，这里涉及到的 HashMap 以及它的 put 操作是不可避免的。步骤 2 和步骤 3 完全是可以封装一下的，步骤 4 也是需要从外外界回调的方法，类似于点击监听的 onClick 方法回调。 所以把 CommonOkHttpClient 给 Deprecated 掉，重新来一个 OkHttpManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author:fanyuzeng * @date: 2017/10/27 17:57 * @desc: */public class OkHttpManager &#123; private static volatile OkHttpManager sManager; private OkHttpClient mOkHttpClient; private OkHttpManager() &#123; OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); builder.connectTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.readTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); builder.writeTimeout(Constants.HTTP_TIME_OUT, TimeUnit.SECONDS); //允许重定向 builder.followRedirects(true); // TODO: 2017/10/27 https mOkHttpClient = builder.build(); &#125; public static OkHttpManager getInstance() &#123; if (sManager == null) &#123; synchronized (OkHttpManager.class) &#123; if (sManager == null) &#123; sManager = new OkHttpManager(); &#125; &#125; &#125; return sManager; &#125; /** * 使用&#123;@link OkHttpClient&#125;想服务器端请求数据的方法 * @param method &#123;@link Constants#HTTP_GET_METHOD&#125; Get方式,&#123;@link Constants#HTTP_POST_METHOD&#125; Post方式 * @param baseUrl baseUrl * @param paramsMap 请求url的参数,以键值对的形式存放 * @param handler */ public void requestServerData(int method, String baseUrl, HashMap&lt;String, String&gt; paramsMap, DisposeDataHandler handler) &#123; RequestParams requestParams = new RequestParams(paramsMap); Request request = null; if (method == Constants.HTTP_GET_METHOD) &#123; request = CommonRequest.createGetRequest(baseUrl, requestParams); &#125; else if (method == Constants.HTTP_POST_METHOD) &#123; request = CommonRequest.createPostRequest(baseUrl, requestParams); &#125; if (request != null) &#123; mOkHttpClient.newCall(request).enqueue(new CommonJsonCallback(handler)); &#125; &#125;&#125; 好吧，还是用双重锁模式的单例比较放心 。 到此就封装完了，下面简单的使用一下。 使用姿势12345678910111213 1 OkHttpManager.getInstance().requestServerData(method, url, mPaginationPresenter.getParams(), new DisposeDataHandler(new DisposeDataListener() &#123; 2 @Override 3 public void onSuccess(Object responseObj) &#123; 4 String responseJson = (String) responseObj; 5 Log.d(TAG, \"&gt;&gt; onSuccess &gt;&gt; \" + responseJson); 6 mPaginationPresenter.accessSuccess(responseJson); 7 &#125; 8 @Override 9 public void onFailure(OkHttpException exception) &#123;10 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \" + exception.getErrorCode());11 mPaginationPresenter.okHttpError(exception.getErrorCode(), exception.getErrorMsg(), url);12 &#125;13 &#125;,null)); 没有将 Json 数据映射成实体类， 所以在 13 行构造 DisposeDataHandler 的时候，第二个 类参数传的是 null。 这个例子是结合上一篇请求分页数据来用的，所以这里直接将 Json 数据抛给 Presenter 层，让它去处理。 第 1 行的 mPaginationPresenter.getParams() 就是拿 url 中的参数。 由于篇幅的限制，这一篇先到这里，下一篇再把这个封装的 OkHttp 工具用于分页数据的请求。 最后，贴个 AS 中封装之后工具的结构图。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"},{"name":"okHttp","slug":"okHttp","permalink":"http://zengfanyu.top/tags/okHttp/"}]},{"title":"Android当中的MVP模式（三）基于分页列表的封装","slug":"MVP3","date":"2017-10-25T12:37:15.000Z","updated":"2017-10-28T07:15:26.281Z","comments":true,"path":"2017/10/25/MVP3/","link":"","permalink":"http://zengfanyu.top/2017/10/25/MVP3/","excerpt":"","text":"摘要：在上一篇中对MVP模式进行了封装，然后通过封装之后的类，实现了一个网络请求，但是请求到网络数据之后，就直接展示到了 View 层，并没有其他的操作，然而我们在开发过程中， 经常会用到分页加载，一般在滑动控件向上滚动，加载更多事件触发是调用，并且这个过程设计到两个参数，一个是 PageIndex ：页码；一个是 PageSize 一页数据的大小， 分页加载就是通过在某一具体事件触发时，调用修改这两个或者一个参数，重新请求网络，从而拿到下一页的数据，这边文章还是基于MVP模式，对分页数据的请求进行封装。 presenter 层作为 MVP 模式的桥梁， 那就先从这一层开始说起吧。 Presenter上一篇中对 Presenter 层的公共方法进行了抽取并且封装成了一个接口 IBasePresenter ，那么现在我们需要实现分页加载还有刷新的功能，那么在 IBasePresenter 接口的基础之上，在对其封装一个接口 IBasePeginationPresenter：123456789101112131415161718192021222324252627/** * Created by fanyuzeng on 2017/10/23. * Function:在IBasePresenter的基础上扩展的接口，适用于分页加载的情况 */public interface IBasePaginationPresenter&lt;Param&gt; extends IBasePresenter&lt;Param&gt; &#123;/** * 刷新数据的接口 * * @param param 访问服务器的参数 * @created at 2017/10/23 20:07 */void refresh(Param param);/** * 加载更多的接口 * * @created at 2017/10/23 20:07 */void loadingNext();/** * 用于判断服务器端是否还有更多的数据 * @return true -还有更多数据 - false 没有更多的数据 */boolean hasMoreData();&#125; 也是一个泛型的接口，增加的三个方法 ： refresh(Param param) 在 View 层调用，用于通知 Model 层刷新数据 loadingNext() 在 View 层调用，用于通知 Model 层加载下一页数据 hasMoreData() 在 Model 层请求网络数据前调用做判断，是否还有下一页数据 有了针对分页刷新的接口之后，还需要有一个实现它的基类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @author：ZengFanyu * @date：2017/10/20 */public abstract class BasePaginationPresenter&lt;Param extends BasePeginationParam, Data&gt; implements IBasePaginationPresenter&lt;Param&gt; &#123; private static final String TAG = \"BasePaginationPresenter\"; private IBaseModel mBaseModel; private IBaseView mBaseListView; private Param mParam; private Class&lt;Data&gt; mClazz; private Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mHasMoreData=true; /** * 子类中调用，用于传递服务器返回的，处理好的结果 * * @param data View层需要的数据类型 * @created at 2017/10/23 20:10 */ public abstract void serverResponse(Data data); /** * 子类中调用，用于确认服务器端是否还有数据 * * @return true-还有数据 false-没有数据 */ public abstract boolean serverHaveMoreData(); public BasePaginationPresenter(IBaseView baseListView, Class&lt;Data&gt; Clazz) &#123; this.mBaseListView = baseListView; mClazz = Clazz; mBaseModel = new SohuAlbumModel(this); &#125; @Override public void refresh(Param param) &#123; requestServer(param); &#125; @Override public void loadingNext() &#123; if (mParam != null) &#123; int pageIndex = mParam.getPageIndex(); mParam.setPageIndex(pageIndex + 1); requestServer(mParam); &#125; &#125; @Override public void requestServer(@Nullable Param param) &#123; mBaseListView.showProgress(true); mParam = param; Log.d(TAG, \"&gt;&gt; requestServer &gt;&gt; \"); getModel().sendRequestToServer(param); &#125; @Override public void accessSuccess(String responseJson) &#123; mBaseListView.showProgress(false); Gson gson = new Gson(); serverResponse(gson.fromJson(responseJson, mClazz)); mBaseListView.showSuccess(true); &#125; @Override public void cancelRequest() &#123; mBaseModel.cancelRequest(); &#125; @Override public void okHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showOkHttpError(errorCode, errorDesc, errorUrl); mBaseListView.showProgress(false); mBaseListView.showSuccess(false); &#125; &#125;); &#125; @Override public IBaseModel getModel() &#123; return mBaseModel; &#125; @Override public HashMap&lt;String, String&gt; getParams() &#123; return null; &#125; @Override public boolean hasMoreData() &#123; return ServerHaveMoreData(); &#125;&#125; 在类申明时，可以看到 Param extends BasePeginationParam ，这里的 BasePeginationParam主要是封装了摘要中提到的 PageIndex 和 PageSize 两个参数，以及他们的 Getter Seeter 方法。 重点看 IBasePeginationPresenter 中新增加的三个方法，refresh(Param param) 会重新调用一次 requestServer(Param param) （此方法在上一篇也提过了，就是通知 Model 层获取数据）； loadingNext() ，加载下一页数据的方法，就是将参数中的 PageIndex + 1 之后，重新调用 requestServer(Param param) 方法。此处只改变了页码，如果需要改变请求数据的条数，也是相应的在 loadingNext() 中修改 PageSize 的值。 hasMoreData() ,这里返回抽象方法 serverhaveMoreData() ，这个方法是在子类中实现的，子类解析了数据之后，判断服务器是否还有数据返回。 然后有需要实现分页功能的 Presenter 就可以直接继承 BasePaginationPresenter 。 Model 层由于 Model 层的职责比较单一，就是向数据源请求数据，并且返回给 Presenter 层，所以此处不需要额外封装接口或者是基类，只需要重新实现上一篇中提到的 IBaseModel 接口即可。 View 层此处和请求一次数据相比较， View 层就是需要在两个事件触发的时候，重新设置参数通知 Presenter 去请求数据，然后再展示出来。这两个事件分别是：上拉到底时加载更多、下拉时刷新数据（当然可以别的）。 针对上一小节中封装类的具体实现View 层的具体实现主要是展示电视剧的主要信息，那么需要提供一个接口方法，给 Presenter 层调用，展示处理好的 JavaBean：1234567891011121314/** * 展示搜狐电视剧频道具体信息的接口 * * @author：ZengFanyu */public interface ISohuSerials extends IBaseView &#123; /** * 展示搜狐视频API电视剧主要信息的方法 * * @param videoList 处理好的VideoInfo集合 */ void showAlbumMainInfo(List&lt;VideoInfo&gt; videoList);&#125; 此处的 VideoInfo 是一个JavaBean，对应的就是电视剧信息的实体类。1234567891011121314public class VideoInfo &#123; @SerializedName(\"main_actor\") private String mMainActor; @SerializedName(\"total_video_count\") private int mTotalVideoCount; @SerializedName(\"album_name\") private String mAlbumName; @SerializedName(\"director\") private String mDirector; @SerializedName(\"publish_time\") private String mPublishTime; //Getter and setter methods&#125; 之前映射数据需要保证字段名和 Json 数据的字段名一致，其实本来把这个类的字段名改得一致就行啦，但是服务器端返回的数据字段，很多都是以“_”进行连接，而不是使用驼峰命名法则，这个时候 Gson 的 @SerializedName 注解就派上用场了，注解中用服务器端返回值字段，成员变量仍然使用驼峰命名法。但是上个周末安装了最近 Alibaba 10 月 14 日 推出的 Coding Guidelines 插件，发现代码中很多不规范的地方，并且人家规定了成员变量就必须要使用驼峰命名！所以我决定要按照这个插件的规范来写代码了，虽然现在进不了大厂，但是先熟悉大厂的代码规范也是好事，哈哈~ 咳咳，按照大厂的代码规范，成员变量的命名必须使用驼峰命名法！这个插件是真心好用，比如对类名要 javadoc 注释 参数、返回值、异常说明、此方法做什么事情、实现什么功能（领域模型相关命名除外，比如：DO、BO、DAO），并且是全中文的！直接在 AS 的 Inspection Results 窗口中显示，这 IDE 内置功能啥时候讲过中文反馈结果的？ 《阿里巴巴Java开发规约》插件全球首发！ 广告时间结束，言归正传！ 这个 Activity 实现了 ISohuSerials 接口，布局文件和上一篇一样，只是把 ListView 换成了自定义的 PullLoadRecyclerView 了，这个RecycyclerView 支持上拉加载更多和下拉刷新， 这里不展开说了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author：ZengFanyu */public class SohuAlbumInfoActivity extends AppCompatActivity implements ISohuSerials &#123; private static final String TAG = \"SohuAlbumInfoActivity\"; private PullLoadRecyclerView mRecyclerView; private Context mContext; private ProgressBar mProgressBar; private TextView mTip; private RelativeLayout mContainer; private AlbumPresenter mAlbumPresenter; private BasePaginationParam mParam= new BasePaginationParam(1, 10); private VideoInfoAdapter mAdapter; Handler mHandler = new Handler(Looper.getMainLooper()); private boolean mIsFromRefresh = false; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_album_view); mContext = this; mAlbumPresenter = new AlbumPresenter(this, Album.class); mContainer = (RelativeLayout) findViewById(R.id.id_success_content); mTip = (TextView) findViewById(R.id.id_tip); mProgressBar = (ProgressBar) findViewById(R.id.id_progress_bar); mRecyclerView = (PullLoadRecyclerView) findViewById(R.id.id_recycler_view); mRecyclerView.setLinearLayout(); mAdapter = new VideoInfoAdapter(mContext); mAlbumPresenter.requestServer(mParam); mRecyclerView.setAdapter(mAdapter); mRecyclerView.setOnPullLoadMoreListener(new PullLoadRecyclerView.OnPullLoadMoreListener() &#123; @Override public void onRefresh() &#123; mIsFromRefresh = true; mParam.setPageIndex(1); mAlbumPresenter.refresh(mParam); //通知Presenter层刷新数据 mRecyclerView.setRefreshCompleted(); &#125; @Override public void onLoadMore() &#123; mAlbumPresenter.loadingNext(); mRecyclerView.setLoadMoreCompleted(); //通知Presenter层加载下一页数据 &#125; &#125;); &#125; @Override public void showAlbumMainInfo(List&lt;VideoInfo&gt; albumList) &#123; if (mIsFromRefresh) &#123; mAdapter.cleanData(); mIsFromRefresh = false; &#125; if (albumList != null &amp;&amp; albumList.size() &gt; 0) &#123; for (VideoInfo videoInfo : albumList) &#123; mAdapter.addData(videoInfo); &#125; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAdapter.notifyDataSetChanged(); &#125; &#125;); &#125; &#125; @Override public void showProgress(final boolean isShow) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isShow) &#123; mProgressBar.setVisibility(View.VISIBLE); &#125; else &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; @Override public void showOkHttpError(final int errorCode, final String errorDesc, final String errorUrl) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"http err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc + \",errUrl:\" + errorUrl); &#125; &#125;); &#125; @Override public void showServerError(final int errorCode, final String errorDesc) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mTip.setText(\"server err:\" + \"errCode:\" + errorCode + \",errDesc:\" + errorDesc); &#125; &#125;); &#125; @Override public void showSuccess(final boolean isSuccess) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; if (isSuccess) &#123; mContainer.setBackgroundResource(android.R.color.white); mTip.setText(\"Sohu Serials album\"); &#125; else &#123; mContainer.setBackgroundResource(R.color.colorAccent); &#125; &#125; &#125;); &#125;&#125; 在上面代码中可以看到: 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onRefresh() 回调方法中，核心代码就是这一行 mAlbumPresenter.refresh(mParam); ，通知 Presenter 层去刷新数据， 至于 Presenter 层如何刷新。。 关我 View 层 X 事~ 在 PullLoadRecycler.OnPullLoadMoreListenre 的 onLoadMore() 回调方法中,也是直接调用 mAlbumPresenter.loadingNext()。 下面说说 Presenter 层的代码 Presenter 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author：ZengFanyu * Function: */public class AlbumPresenter extends BasePaginationPresenter&lt;BasePaginationParam, Album&gt; &#123; private ISohuSerials mBaseListView; private Handler mHandler = new Handler(Looper.getMainLooper()); private int mTotalCount; public AlbumPresenter(ISohuSerials baseListView, Class&lt;Album&gt; CLazz) &#123; super(baseListView, CLazz); this.mBaseListView = baseListView; getModel().setRequestMethod(Constants.HTTP_GET_METHOD); getModel().setRequestUrl(Constants.SOHU_SERIALS_URL); &#125; @Override public void serverResponse(Album album) &#123; mBaseListView.showAlbumMainInfo(album.getData().getVideos()); mHandler.post(new Runnable() &#123; @Override public void run() &#123; mBaseListView.showProgress(false); &#125; &#125;); mTotalCount = album.getData().getCount(); &#125; @Override public boolean serverHaveMoreData() &#123; //此处pageIndex是从1开始的， 实际使用需要注意pageIndex的起始值 int pageSize = mParam.getPageSize(); int pageIndex = mParam.getPageIndex(); return (pageIndex * pageSize) &lt;= mTotalCount; &#125;&#125; 首先是要继承之前编写的 BasePaginationPresenter类，泛型参数 BasePaginationParam 可以根据实际需求进行拓展，基本使用在前面已经介绍过，此处不做赘述。 Album 是搜狐视频电视剧频道返回数据的实体类，上面提到的 VideoInfo 包含在 Album 里面，因为现在只需要展示 VideoInfo 里的信息， 所以在 serverRespomse 方法里，有一个转换 mBaseListView.showAlbumMainInfo(album.getData().getVideos()); 实现父类 BasePaginationPresenter 中的抽象方法 serverHaveMoreData() ,思路就是 当前页面数 * 每一页的数据量，然后和 数据总量 比较大小。 Model 层的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 1 /** 2 * @author：ZengFanyu 3 */ 4 public class SohuAlbumModel&lt;Param extends BasePaginationParam&gt; implements IBaseModel&lt;Param&gt; &#123; 5 private static final String TAG = \"SohuAlbumModel\"; 6 private String url; 7 private int method; 8 private IBasePaginationPresenter mPaginationPresenter; 9 10 public SohuAlbumModel(IBasePaginationPresenter paginationPresenter) &#123;11 mPaginationPresenter = paginationPresenter;12 &#125;13 14 @Override15 public void sendRequestToServer(Param param) &#123;16 String validUrl = null;17 if (param != null &amp;&amp; !TextUtils.isEmpty(url)&amp;&amp;mPaginationPresenter.hasMoreData()) &#123;18 validUrl = getValidUrl(url, param);19 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"ValidUrl:\" + validUrl);20 &#125;21 Log.d(TAG,\"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"check param,url and server have data or not!\")22 if (!TextUtils.isEmpty(validUrl)) &#123;23 HttpUtils.executeByGet(validUrl, new Callback() &#123;24 @Override25 public void onFailure(Call call, IOException e) &#123;26 Log.d(TAG, \"&gt;&gt; onFailure &gt;&gt; \");27 e.printStackTrace();28 mPaginationPresenter.okHttpError(Constants.URL_ERROR, e.getMessage(), url);29 &#125;30 31 @Override32 public void onResponse(Call call, Response response) throws IOException &#123;33 if (!response.isSuccessful()) &#123;34 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"Not successful\");35 mPaginationPresenter.okHttpError(Constants.SERVER_ERROR, response.message(), url);36 &#125;37 38 String responseJson = response.body().string();39 Log.d(TAG, \"&gt;&gt; onResponse &gt;&gt; \" + \"responseJson:\" + responseJson);40 mPaginationPresenter.accessSuccess(responseJson);41 42 &#125;43 &#125;);44 &#125; else &#123;45 Log.d(TAG, \"&gt;&gt; sendRequestToServer &gt;&gt; \" + \"Valid Url is empty\");46 &#125;47 &#125;48 49 private String getValidUrl(String url, Param param) &#123;50 return String.format(url, param.getPageIndex(), param.getPageSize());51 &#125;52 53 54 @Override55 public void setRequestUrl(String url) &#123;56 this.url = url;57 &#125;58 59 @Override60 public void setRequestMethod(int method) &#123;61 this.method = method;62 &#125;63 64 @Override65 public void cancelRequest() &#123;66 HttpUtils.cancelCall();67 &#125;68 &#125; Model 层的实现还是跟之前的一样，直接实现 IBaseModel 接口即可。 在 17 行可以看到，mPaginationPresenter.hasMoreData() ，这个就是对服务器点是否还有数据可以返回的判断，如果这里返回 false 那么就不回去进行网络请求,然后在 22 行打印个 Log 提醒。 在看看 49 行的 getVaildUrl 方法，这个方法主要就是把传进来的 param 参数拼接进 url 中，形成有效的，可以请求到数据的 Url。 效果图 Item 就展示了一下电视剧的 主演、名字、导演、集数、更新时间的信息。 小结通过上面的封装和例子，起码证明了这一套封装能够跑的通了，以后如果还有关于分页请求的需求，可以直接继承上面的基类来实现，无非就是修改param 和 Data 两个泛型的参数。 前者是请求 url 的参数，根据具体的业务需求，封装 BasePaginationParam 的子类即可。 后者是服务器端返回数据的实体类，也是根据数据的结构来封装的，在 Android Studio 中有 Gson Formatter 这个插件，封装 JavaBean 插件也轻松很多，在结合上面提到的 Gson 注解，全套了。 下一篇准备封装一下 OkHttp ,然后将封装之后的 OkHttp 整合到当前框架中,当然了,还是以分页接在为例","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android 当中的 MVP 模式（二）封装","slug":"MVP2","date":"2017-10-22T14:00:15.000Z","updated":"2017-10-23T15:04:26.414Z","comments":true,"path":"2017/10/22/MVP2/","link":"","permalink":"http://zengfanyu.top/2017/10/22/MVP2/","excerpt":"","text":"在Android当中的MVP模式（一）基本概念中，用了一个简单的的登录Demo展示了一下 MVP 模式的基本姿势，虽然项目结构是更加清晰了，但是代码量明显增多了，原来的网络请求操作只用 1 个类可以搞定，现在需要 4 个类，并且每当有不同作用的 model 出现时，我们就需要相应的为他们添加 presenter 层的对象，但是细细查看，这些model 的作用都大体相似，与获取数据相关，类似于网络请求或者是数据库 DAO 的操作，所以此处可以考虑将他们的共性抽取出来，封装成基累，然后子类去继承即可。 一个简单的网络请求 一个简单的需求：通过 url 获取数据，然后用 Gson 解析成 JavaBean，然后展示到 ListView上。这里使用知乎日报的获取最新消息的 API 接口 https://news-at.zhihu.com/api/4/news/latest 那么按照普通 MVP 的思路，首先 view 层： 为了突出重点，当前View层只做一件事情：就是展示获取的数据 ILatestVIew 此接口需要一个 String 类型的列表数据，主要是用于给 Adapter 展示用。 LatestViewActivity 很简答，就是实现接口。 IRequestLatestModel 请求服务器端数据的接口 RequestLatestNewsModel 使用 okhttp 请求数据，然后将返回的json类型数据传递给 Presenter 层。 ILatestNewsPresenter 一个接口用于处理 Json 数据，一个接口用于通知 model 层向服务器发起请求 。 LatestNewsPresenter 实现接口定义的方法 其中 HttpUtils 方法如下： 此处 OKhttp 也可以进行封装， 后面再写一篇文章， 专门记录，先暂时简单的使用。 运行之后，点击 button， 即可发起网络请求，运行效果如下： 弊端： 假设我们现在又有另外的一个需求， 请求知乎日报过往的消息， 对应的 API 接口为URL: https://news-at.zhihu.com/api/4/news/before/20131119,那么我就需要按照上述的方式，又写一套MVP的代码，最少又得留个类，如此一来，随着需求的增多，代码量会极具增大，但是多余增加的每层代码所做的事情又大多数相同，只是具体细节不一样，那么我们可不可以把每一层要做的事情给抽取出来，封装成基类，然后让子类去继承，去实现，这样就可以大量减少代码量？ 抱着这个问题，我就来分析一下 MVP 每一层所做的事情。 以简单网络请求为例，分析 MVP 各层的职责以上面请求知乎日报的最新消息为例，分析每一层的职责。 Model 层Model 角色主要是提供数据的存取功，并且将数据或者是错误信息回调给 Presenter 层。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。所以它主要的功能是： 1. 向数据源发起请求 2. 取消发起的请求 3. 通知 Presenter 处理结果 Presenter 层一般是通知 Model 向服务器发起请求，然后接收 Model 层的请求结果，包括成功的数据和错误的信息，同时也负责将处理之后的数据或者是错误信息通知 View 层，由 View 层作展示。所以他的主要功能是： 1. 通知 Model 层向服务器发起数据请求 2. 通知 Model 层取消这次请求 3. 接收 Model 层返回的数据 4. 接收 Model 层返回的错误信息 5. 通知 View 层接收处理之后的结果或者是错误信息 View 层此处 View 层的作用就比较专一化，只用于处理 UI 相关的事情，不再负责业务逻辑。主要职责如下： 1. Loading 状态的展示隐藏 2. 接收 Presenter 层处理后的数据 3. 接收 Presenter 层处理后的错误信息 4. 接收 Presenter 层处理后的服务器拒绝信息 嗯，差不多就是这么多吧 既然将每一层的主要职责总结了出来， 很明显就可以将这些职责「在代码中就是对应的方法」抽象成方法，然后让子类去个性化的实现。 抽取共性封装网络请求Model 层IBaseModel 其中 setMethod 和 setRequestUrl 方法直接在 Presenter 的构造方法中调用，设置好请求的方式和请求的 Url 地址，这样方便 model 层在请求服务器数据时，使用对应的参数，使用对应的请求方式。 此处没有用到 method 是因为知乎日报的最新新闻 API 接口是 Get 方式，不需要参数，所以此处没有根据请求方式来调用不同的请求方法 Presenter 层IBasePresenter Presenter 层是逻辑控制层，是 Model 层和 View 层的桥梁，对这一层抽取共性进行封装的时候，不能像 Model 层一样，把全部的功能装好好，原因如下： 1.如果将其全部封装起来，是没办法复用同一个功能模块的，并且会导致部分业务逻辑需要在 view 层中做处理，这样和 MVP 的思想相悖。 2.Presenter 层需要处理和 View 层的交互逻辑以及 Model 层返回的数据。 但是 Model 层是可以的，我是认为，Model 层就是从数据源中拿数据，并且将数据传递给 Presenter 层，所有的 Model 层做的都是这个操作，只是访问数据源的参数不同，数据源类型不同，访问数据源的方法不同而已，所以很明显可以全部抽取出来放基类中，然后各个子类去各自实现。 1. requestServer 在View层调用的接口，用于通知Model层想服务器发起请求，参数可为空，比如，有些Get方式的请求就不需要参数 2. requestSuccess 在Model层调用，通过此方法将服务器返回的数据传递给给Presenter层处理 3. cancelRequest 在View层调用，用于通知Model层取消请求 4. okHttpError 在Model层调用，当网络请求产生错误的时候 5. getModel 在子类中调用，用于拿到Model对象 6. getParams 在Model层中调用，此方法用于获取Presenter层处理好的参数 BasePresenter public abstract class BasePresenter&lt;Params, Data&gt; implements IBasePresenter&lt;Params&gt;这是一个泛型的抽象类，其中泛型Params是用于model层向服务器发起请求的请求参数，Data是服务器返回的Json类对应的JavaBean类。 BasePresenter处理了View层和model层中大多数的逻辑，我们要做的就是在子类中实现public abstract void serverResponse(Data data);这个抽象方法就好了。 public abstract void serverResponse(Data data);这个方法是在用于处理model层返回的结果，然后进行处理之后回调给view层。 可以看到46、47、50、51、52行的代码给注释掉了，其实一般情况下这里是不需要注释的，这里是用于判断返回数据的errorNum errorType errorDesc信息的，这么操作，是为了实现如下功能：若返回的信息有误，则BasePresenter直接回调给View层，如果正确，才会传递给子类。 上述最后一条，需要对泛型Data在进行一次封装，并且使用上 Gson 的@SerializedName(value = &quot;...&quot;,alternate = {&quot;...&quot;,&quot;...&quot;,&quot;...&quot;})这个注解，并且这里涉及到泛型擦除的问题，这一块我还没有很好的解决办法，所以此处没有进行封装。 View 层还是按照上面分析的 View 层职责来写： IBaseView 到此为止，对 MVP 模式的每一层都写出了对应的基类，有了这件基类作为基础之后，在进行同样的网络请求。 使用上述封装好的类进行相同的网络请求LatestNewsModel LatestNewsPresenter 其中Param泛型参数填的是nullable是因为这个请求是get方式，没有涉及到参数。LatestNews作为Data的泛型，主要是用于BasePresenter解析并映射。 ILatestNewsView IlatestNewsVIew接口是继承IBaseView接口的，是因为它需要在IBaseView接口所定义的功能之上，还需要实现将数据展示到列表中这么一个操作，所以添加上了一个showLatestViewTitle方法。 LatestNewsTitleActivity 这个类写起来就简单了，跟着接口来， 把之前每一个接口提到的功能给实现以下就可以了。 顺便贴个 XML 文件： 搞定，实现的效果和上面是一样的。 回过头一看，MMP，这代码量似乎也没有少很多啊，-。- ，没事没事，需求多了就少了~ 小结先看看上一篇中提到的一张图此处将MVP模式封装后，MVP的流程图如下： 后面的文章将使用上面封装的框架，通过扩展 BasePresenter 来增加新的模块。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Android当中的MVP模式（一）基本概念","slug":"MVP1","date":"2017-10-20T12:37:15.000Z","updated":"2017-10-23T15:04:38.919Z","comments":true,"path":"2017/10/20/MVP1/","link":"","permalink":"http://zengfanyu.top/2017/10/20/MVP1/","excerpt":"","text":"为什么要使用MVP在传统的Android开发中，我们一般是使用MVC模式进行开发的。 传统MVC模式介绍： View: 视图层，对应xml文件 Controller: 控制层，对应Activity和Fragment层，进行数据处理 Model：实体层，负责获取实体数据 采用MVC模式的一个最大的弊端就是xml作为View层视图能力实在太弱，所以一般情况下我们都是通过Controller层来辅助处理一些视图的。这样的结果就导致Controller既作为控制层的同时又承担了View层的大部分功能，采用MVC模式往往会导致Activity和Fragment中的代码非常复杂。我们将Android中采用的MVC模式称为MV模式更加恰当。 MVP模式介绍： View: 视图层，对应xml文件与Activity/Fragment Presenter: 逻辑控制层，同时持有View和Model对象 Model: 实体层，负责获取实体数据 MVP模式的流程图如下： 采用MVP模式的优势是： 把业务逻辑抽离到Presenter层中，View层专注于UI的处理。 分离视图逻辑与业务逻辑，达到解耦的目的。 提高代码的阅读性。 Presenter被抽象成接口，可以根据Presenter的实现方式进行单元测试。可拓展性强。 采用MVP模式的缺点： 项目结构会对后期的开发和维护有一定的影响。具体视APP的体量而定。 代码量会增多，如何避免编写过多功能相似的重复代码是使用MVP开发的一个重点要处理的问题。 有一定的学习成本。综上所述，在Android上采用MVP模式的优势是：大大优化代码的维护性与拓展性的同时对代码进行深度解耦，使各个层级的分工更加明晰。 一个简单的应用模拟Android中登陆的功能 界面 项目结构 从上图中可以看到，一个简单的基于 MVP 的项目，最少也需要创建 6 个文件夹，分别是 M、V、P 的接口和它们各自的实现类，其中 LoginActivity 就是 View 层的具体实现，它只需要负责处理 UI 的逻辑，而业务相关的逻辑都抽象到 LoginPresenter 中，这样就避免了传统开发中 Activity 、Fragment 既处理 UI 又负责业务逻辑的情况。 代码实现ILoginView： view层只负责和 UI 相关的操作，那么在这个小 Demo 中，和 UI 相关的操作有如下几点： 1. 从EditText中拿到用户输入的userName 2. 从EditText中拿到用户输入的password 3. 在登录过程中需要展示一个progressbar，登录过程结束之后隐藏这个progressbar 4. 展示登录成功后的view 5. 展示登录失败后的view 综上五个操作，所以有了ILoginView中的五个接口 LoginActivity： 当点击登录按钮时，会将请求服务器合适账号密码这个过程交给presenter层去处理，所以在LoginActivity里，会有preserent的引用。 ILoginPersenter： presenter层处理业务逻辑，有如下几点: 1. 负责接收model的返回结果并且处理 2. 将处理的结果以特定的形式，传递给view层，让view层去展示 3. 通知model层去向数据源请求数据 LoginPresenter： 因为presenter层相当于一个中间交互人，所以它必须要持有对 view 、model 层对象的引用。 ILoginModel： model负责数据的存取： 在这个Demo中，数据的存取使用一个线程和简单的字符串判断来模拟。 LoginModel： 因为model层需要将获取的数据传递给presenter层去做处理，所以此处也需要持有对presenter层的引用。 这样一来就成功的将简单的登录案例，由MVP模式来实现了, 在 LoginActivity 中处理的都是和 UI 相关的， 在 LoginPresenter 中处理的是业务的逻辑， 在 LoginModel 中处理的是网络数据获取。 小结 Presenter—交互中间人 主要作为沟通 View 和 Model 的桥梁，它从 Model 层检索数据后，返回给 View 层，使得 View 和 Model 之间没有耦合，也将业务从 View 角色上抽离出来。 View—用户界面 View 通常是指Activity、Fragment或者某个 View 控件，它含有一个 Presenter 成员变量。通常 View 需要实现一个逻辑接口，将 View 上的操作转换给 Presenter 进行实现，最后，Presenter 调用 View 逻辑接口将结果返回给 View 元素。 Model—数据的存取 对于一个结构化的 APP 来说，Model角色主要是提供数据的存取功能。Presenter 需要通过 Model 层存储、获取数据，Model就想一个数据仓库。更直白的说，Model 就是封装了数据库 DAO 或者网络获取数据的角色，或者两种数据获取方式的集合。 MVP 并不是一个标准化的模式，它有很多种实现方式，也可以根据自己的需求去修正MVP的实现方式，可以随着 Presenter 的复杂程度而变化，只要保证是通过 Presenter 将 View 和 Model 解耦，降低类型复杂度，各个模块单元可以独立测试、独立变化，这就是正确的方向。","categories":[{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/categories/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zengfanyu.top/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"http://zengfanyu.top/tags/MVP/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-14T15:40:28.953Z","updated":"2017-10-21T16:06:55.127Z","comments":true,"path":"2017/10/14/hello-world/","link":"","permalink":"http://zengfanyu.top/2017/10/14/hello-world/","excerpt":"","text":"To be a better man1Hello , 个人博客搭好了，老规矩，先来个 Hello World！，然后，撸起袖子就是干！","categories":[],"tags":[]}]}